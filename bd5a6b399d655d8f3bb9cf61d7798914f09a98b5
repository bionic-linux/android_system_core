{
  "comments": [
    {
      "key": {
        "uuid": "e4b01d50_807a3d27",
        "filename": "init/mount_handler.cpp",
        "patchSetId": 2
      },
      "lineNbr": 76,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-10-07T15:31:54Z",
      "side": 1,
      "message": "Does not clear dev.mnt.part when umount\u0027d. rename value to mount_blk_value for maitnenance clarity. rename mount_prop to mount_blk_prop for clarity.\n\n    std::string mount_part_value, mount_blk_value;\n    if (add) {\n        mount_blk_value \u003d mount_part_value \u003d entry.blk_device.substr(strlen(devblock));\n. . .\n    }\n. . .\n    if (!mount_blk_value.empty() || !android::base:GetProperty(mount_blk_prop, \"\").empty()) {\n        property_set(mount_blk_prop, mount_blk_value);\n    }\n    if (!mount_part_value.empty() || !android::base::GetProperty(mount_part_prop, \"\").empty()) {\n        property_set(mount_part_prop, mount_part_value);\n    }\n\n[TL;DR]\n\nNow some random thoughts about the above logic and performance details. It is not required to make the following suggested changes as that would overload this change, such changes could be in followup CLs unrelated to the immediate requirements.\n\nA case can be made to adjust the existing GetProperty checks above to reduce all of the associated property_set calls, we recognize that there is currently a 4 property setting queue for the property socket, which can be overloaded easily, so we try to reduce the pressure, this pressure is not an issue for internal init operations such as we have here. But in the future will be when the property service is spawned to a separate thread (tomcherry@). I suggest a check for identity should be used to prevent calling property_set, but this logic does not accomplish that. The goal of the current check is apparently to not set the property to empty, if it already is, to prevent errant creation of a property node for \u0027do-not-add noise\u0027 on the uevent as we get several, and not one. Maybe a logic should be adjusted and simplified so that we do not doom the new (?) property service to failure:\n\n    auto old_value \u003d android::base::GetProperty(mount_blk_prop, \"\");\n    if (mount_blk_value !\u003d old_value) {\n        property_set(mount_blk_prop, mount_blk_value);\n    }\n    old_value \u003d android::base::GetProperty(mount_part_prop, \"\");\n    if (mount_part_value !\u003d old_value) {\n        property_set(mount_part_prop, mount_part_value);\n    }\n\nMaybe when tomcherry@ sets up the new property service he could explicitly and internally increase the /proc/sys/net/unix/max_dgram_qlen to 600 (which is the value set later, or too late?, in init.rc), provide that value to the socket setup as well (which defaults to 4) before instantiating the property socket, or setup the property_set operations to filter out non-changes (which may be wrong, a non-change triggers an \u0027on property\u0027, which may be desireable or expected elsewhere, but is not desireable here). The point being, the filter here is desireable to set this standard in the near future, so I suggest adding it, but that could change before we are finished with the additional features.\n\nAnother change for the future is to add explicit calls in __mount and __umount in fs_mgr/vold, keep this here to catch all others that do not call, so that this is mostly synchronous.\n\nUltimately, tomcherry@ should arbitrate what kind of logic (if any) exists here for property_set filtration based on his designed needs elsewhere.",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 76,
        "endChar": 58
      },
      "revId": "bd5a6b399d655d8f3bb9cf61d7798914f09a98b5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "148295b1_7d7ffe65",
        "filename": "init/mount_handler.cpp",
        "patchSetId": 2
      },
      "lineNbr": 76,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-10-07T17:06:09Z",
      "side": 1,
      "message": "\u003e But in the future will be when the property service is spawned to a separate thread\n\nProperty service is now in its own thread.  That change relanded Sept 10th.\n\n\u003e Maybe when tomcherry@ sets up the new property service he could explicitly and internally increase the /proc/sys/net/unix/max_dgram_qlen to 600\n\nDoes that work retroactively when the proc node is set or only on new sockets?  I\u0027ve been wondering if we need to tune any of these settings, but in the absence of failures, I haven\u0027t made any changes.  We only set ~430 properties on cuttlefish through boot complete, so I don\u0027t think there\u0027s much pressure on this socket in any case.\n\nAssuming we\u0027re not running into any limits, I don\u0027t think we need to put a filter in SetProperty() in the generic case; we\u0027d need to traverse the property trie twice to set a property that is not already set to a given value (once to check that the property isn\u0027t different and once to actually set it).\n\n\u003e Another change for the future is to add explicit calls in __mount and __umount in fs_mgr/vold, keep this here to catch all others that do not call, so that this is mostly synchronous.\n\nFWIW, I think we should either only make the explicit calls in __mount and __umount or leave it how it is.  I think it would be more confusing if these properties are \"mostly synchronous\"; either we should make that guarantee or we shouldn\u0027t.",
      "parentUuid": "e4b01d50_807a3d27",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 76,
        "endChar": 58
      },
      "revId": "bd5a6b399d655d8f3bb9cf61d7798914f09a98b5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6993f652_94526264",
        "filename": "init/mount_handler.cpp",
        "patchSetId": 2
      },
      "lineNbr": 76,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-10-07T18:32:21Z",
      "side": 1,
      "message": "Good to know!\n\nThe max_dgram_qlen setting is used _when_ the socket is instantiated by a listen, not retroactively. listen(sockfd, backlog) ... backlog has the advantage(?) of setting the number of outstanding requests _and_ dgram packets allowed in the queue once connected.\n\nIf the queue is large, then properties can be used as an IPC. It _shouldn\u0027t_ be used as an IPC IMHO, so I am of a mixed mind when it comes to allowing a large queue. Large queue, and coincidentally a dedicated thread, both mitigate the lost message problem. Users should not be stuffing the properties with any high volume IMHO. This, and ueventd if it ever gets involved, both have the ability to produce a large volume of messages in quick succession though like no other. Filtration is not enough to mitigate the pressure, however, if we keep this worker and filter, and _also_ set the properties right after a mount or umount (in fs_mgr and vold) before this races into action, we get the \u0027population\u0027 of the properties when second stage init starts, and the synchronous behavior expectation for mountall. I do not think we will have a \u0027mostly synchronous\u0027 behavior, only an asynchronous backup for any mounts _not_ performed by fs_mgr or vold (which should be no one), with this engine handling when we mess up (if ever).",
      "parentUuid": "148295b1_7d7ffe65",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 76,
        "endChar": 58
      },
      "revId": "bd5a6b399d655d8f3bb9cf61d7798914f09a98b5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17208cc3_02f22f88",
        "filename": "init/mount_handler.cpp",
        "patchSetId": 2
      },
      "lineNbr": 76,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-10-07T19:30:46Z",
      "side": 1,
      "message": "Sounds reasonable.  I don\u0027t think we should use properties for IPC either and I double checked: we\u0027ve had the same 8 length backlog for quite a while in property service, so unless we\u0027re seeing live failures, I don\u0027t think we need to change anything there.  Note too that __system_property_set() is synchronous, so a single thread setting multiple properties back to back will not blow up the backlog.  It\u0027ll only happen if we have \u003e8 threads all trying to set a property at once.\n\nI\u0027m okay with a filter here if you think it\u0027s necessary, but since setting properties is synchronous, it\u0027ll only help to reduce cycles; it shouldn\u0027t cause issues with property_service\u0027s backlog.\n\n\u003e I do not think we will have a \u0027mostly synchronous\u0027 behavior, only an asynchronous backup for any mounts _not_ performed by fs_mgr or vold (which should be no one), with this engine handling when we mess up (if ever).\n\nIf we don\u0027t expect to have any mounts not performed by fs_mgr or vold, then why would we even have a back up?  We don\u0027t want to encourage behavior that we\u0027re not expecting.  I think it\u0027s totally reasonable to say that we\u0027re setting these dev.mnt.* properties only in response to mounts done by fs_mgr/vold.  It\u0027ll allow us to make them synchronous and cut down on the complexity.",
      "parentUuid": "6993f652_94526264",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 76,
        "endChar": 58
      },
      "revId": "bd5a6b399d655d8f3bb9cf61d7798914f09a98b5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "834c8780_3059d57c",
        "filename": "init/mount_handler.cpp",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-10-07T15:31:54Z",
      "side": 1,
      "message": "nit: The first digit is the mmcblk interface driver instance. mmcblk storage devices instances are enumerated separately from the pool of mmcblk interface pool.",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 83,
        "endChar": 21
      },
      "revId": "bd5a6b399d655d8f3bb9cf61d7798914f09a98b5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9fa7d627_f1f57ddf",
        "filename": "init/mount_handler.cpp",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-10-07T15:31:54Z",
      "side": 1,
      "message": "will leave a value after umount, and will not be mangled if value logic hits early return (see above)",
      "range": {
        "startLine": 104,
        "startChar": 3,
        "endLine": 105,
        "endChar": 1
      },
      "revId": "bd5a6b399d655d8f3bb9cf61d7798914f09a98b5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}