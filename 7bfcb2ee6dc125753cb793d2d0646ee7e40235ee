{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8a2d0f77_ac643986",
        "filename": "fs_mgr/libsnapshot/libsnapshot_cow/writer_v3.cpp",
        "patchSetId": 5
      },
      "lineNbr": 131,
      "author": {
        "id": 1710792
      },
      "writtenOn": "2023-10-31T02:04:28Z",
      "side": 1,
      "message": "This is already computed by `GetOpOffset(header_.op_count);` , do we need to store it using an member variable?",
      "revId": "7bfcb2ee6dc125753cb793d2d0646ee7e40235ee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8bf40353_65590613",
        "filename": "fs_mgr/libsnapshot/libsnapshot_cow/writer_v3.cpp",
        "patchSetId": 5
      },
      "lineNbr": 131,
      "author": {
        "id": 1964171
      },
      "writtenOn": "2023-11-01T18:11:22Z",
      "side": 1,
      "message": "yeah okay, I think if header stores the op_count, we can calculate it on the fly. From a quick look at next_op_pos_ usage in v2, I think we don\u0027t need to store it",
      "parentUuid": "8a2d0f77_ac643986",
      "revId": "7bfcb2ee6dc125753cb793d2d0646ee7e40235ee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91ffe624_77cc6887",
        "filename": "fs_mgr/libsnapshot/libsnapshot_cow/writer_v3.cpp",
        "patchSetId": 5
      },
      "lineNbr": 200,
      "author": {
        "id": 1710792
      },
      "writtenOn": "2023-10-31T02:04:28Z",
      "side": 1,
      "message": "What data do we keep in memory such that processing a large block chunk is stressing memory? Looking at implementation of this loop, we always process each block independently, and every CowOperation is immediately written to disk with no caching, memory should not be an issue here.",
      "revId": "7bfcb2ee6dc125753cb793d2d0646ee7e40235ee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f43d8a1f_d216b4b1",
        "filename": "fs_mgr/libsnapshot/libsnapshot_cow/writer_v3.cpp",
        "patchSetId": 5
      },
      "lineNbr": 200,
      "author": {
        "id": 1964171
      },
      "writtenOn": "2023-11-01T18:11:22Z",
      "side": 1,
      "message": "I think this was here because we had worker threads compressing blocks before writing to disk. In this implementation we write immediately, but once we support compression, we might want to have the limiter on how much we are bringing into memory?\n\nRegardless, I\u0027ll take this out for now",
      "parentUuid": "91ffe624_77cc6887",
      "revId": "7bfcb2ee6dc125753cb793d2d0646ee7e40235ee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9e90089_4ecd7b3d",
        "filename": "fs_mgr/libsnapshot/libsnapshot_cow/writer_v3.cpp",
        "patchSetId": 5
      },
      "lineNbr": 273,
      "author": {
        "id": 1710792
      },
      "writtenOn": "2023-10-31T02:04:28Z",
      "side": 1,
      "message": "do we need to update `next_data_pos_` after writing?",
      "revId": "7bfcb2ee6dc125753cb793d2d0646ee7e40235ee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef2a2079_3f88a3f1",
        "filename": "fs_mgr/libsnapshot/libsnapshot_cow/writer_v3.cpp",
        "patchSetId": 5
      },
      "lineNbr": 273,
      "author": {
        "id": 1964171
      },
      "writtenOn": "2023-11-01T18:11:22Z",
      "side": 1,
      "message": "yeah good catch. Old writer_v2 updated this position through an AddOperation function, but since we aren\u0027t using cluster ops anymore we don\u0027t need the abstraction and just update this variable more simply.",
      "parentUuid": "b9e90089_4ecd7b3d",
      "revId": "7bfcb2ee6dc125753cb793d2d0646ee7e40235ee",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}