{
  "comments": [
    {
      "key": {
        "uuid": "048f817d_638ad3f9",
        "filename": "libcutils/arch-mips/android_memset.c",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1010669
      },
      "writtenOn": "2015-08-27T21:37:49Z",
      "side": 1,
      "message": "In the original sanitize object code for mips, I saw a conditional call to trap() when MSB of value was 1.\nMeaning that uint16 was effectively just uint15.\nThat is likely a bug in mips clang or in sanitize definition.\n\nI hope the above avoids that problem.",
      "revId": "c348a88376c1bfbb86ca47eeca9b253558e6c926",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "248c8586_493b2287",
        "filename": "libcutils/arch-mips/android_memset.c",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1010669
      },
      "writtenOn": "2015-08-27T22:49:30Z",
      "side": 1,
      "message": "Apparently \u0027uval16\u0027 in \u0027uval16\u003c\u003c16\u0027 promotes to signed integer before the shift is done, leading to questions about signed overflows!  Making an explicit promotion to unsigned integer before shifting, avoids the issue and retains the full 16-bit range when checking is on.\n\nWhen sanity\u003dinteger is on,\n   uval16 \u003c\u003c 15\nis handled okay with no checks,\n\n   uval16 \u003c\u003c 16\ngenerates runtime code which traps if uval16 \u0026 0x8000 is on,\nand\n\n   ((unsigned int)uval16) \u003c\u003c 16\nis handled okay with no checks.",
      "parentUuid": "048f817d_638ad3f9",
      "revId": "c348a88376c1bfbb86ca47eeca9b253558e6c926",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4750d3f_9273808e",
        "filename": "libcutils/arch-mips/android_memset.c",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1003966
      },
      "writtenOn": "2015-08-27T23:01:08Z",
      "side": 1,
      "message": "\"value\" is 16 bits, and this was an attempt to shift a 16 bit value by 16 bits. This is undefined behavior. (C standard 6.5.7 item 1185 http://c0x.coding-guidelines.com/6.5.7.html).\n\nThe fact that this was working at all is somewhat amazing. This behavior has changed over time, and certain GCC optimizations rely on this undefined behavior (\"shift-by-bitwidth\" in http://blog.regehr.org/archives/1234).\n\nAre you sure this code was ever working as expected? I bet you\u0027ll find that the old version of this code was broken... I bet nobody ever tested a non-zero memset value.  :-(\n\nYour new code is the proper way it should have been written in the first place.",
      "parentUuid": "248c8586_493b2287",
      "revId": "c348a88376c1bfbb86ca47eeca9b253558e6c926",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}