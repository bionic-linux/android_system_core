{
  "comments": [
    {
      "key": {
        "uuid": "4641d3f4_9302ac3c",
        "filename": "base/file_wait_generic.cpp",
        "patchSetId": 4
      },
      "lineNbr": 38,
      "author": {
        "id": 1108565
      },
      "writtenOn": "2019-06-12T19:30:53Z",
      "side": 1,
      "message": "are we sure this is enough? What about invalid path.c_str() or ENOTDIR",
      "range": {
        "startLine": 38,
        "startChar": 39,
        "endLine": 38,
        "endChar": 54
      },
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d99f6a06_478ea861",
        "filename": "base/file_wait_generic.cpp",
        "patchSetId": 4
      },
      "lineNbr": 38,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2019-06-12T22:05:42Z",
      "side": 1,
      "message": "If we get ENOTDIR here, the inotify will fail early with the same errno. This is clarified in the comment - Dirname(path) must exist.",
      "parentUuid": "4641d3f4_9302ac3c",
      "range": {
        "startLine": 38,
        "startChar": 39,
        "endLine": 38,
        "endChar": 54
      },
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "250261b0_eff41631",
        "filename": "base/file_wait_linux.cpp",
        "patchSetId": 4
      },
      "lineNbr": 91,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-06-12T16:23:26Z",
      "side": 1,
      "message": "I wonder if we should print an error and then fall back to polling here and the other failure returns from this function too.\n\nMaybe even return an enum of Success, Failure, Timedout, and in the Failure case, have WaitForFile() call the generic WaitForFile() with the remaining timeout?",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e6b972c_a014c1e2",
        "filename": "base/file_wait_linux.cpp",
        "patchSetId": 4
      },
      "lineNbr": 91,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2019-06-12T18:29:29Z",
      "side": 1,
      "message": "I was debating something like that too, seems like a good idea. I\u0027ll do that in the next patchset.",
      "parentUuid": "250261b0_eff41631",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9a86a5e_94dedd7f",
        "filename": "base/file_wait_linux.cpp",
        "patchSetId": 4
      },
      "lineNbr": 91,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2019-06-12T22:05:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1e6b972c_a014c1e2",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a39f728_0a79a840",
        "filename": "base/file_wait_linux.cpp",
        "patchSetId": 4
      },
      "lineNbr": 93,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2019-06-12T19:05:41Z",
      "side": 1,
      "message": "why isn\u0027t this a while loop?",
      "range": {
        "startLine": 93,
        "startChar": 2,
        "endLine": 93,
        "endChar": 4
      },
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe842145_a524dffc",
        "filename": "base/file_wait_linux.cpp",
        "patchSetId": 4
      },
      "lineNbr": 93,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2019-06-12T22:05:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9a39f728_0a79a840",
      "range": {
        "startLine": 93,
        "startChar": 2,
        "endLine": 93,
        "endChar": 4
      },
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "85d0e96f_328d7ce1",
        "filename": "base/include/android-base/file.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2019-06-12T19:05:41Z",
      "side": 1,
      "message": "do we actually want anyone to be using these for anything other than mount points?",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39e4771f_b9ac84aa",
        "filename": "base/include/android-base/file.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1108565
      },
      "writtenOn": "2019-06-12T19:30:53Z",
      "side": 1,
      "message": "Some of these devices may not be mount points, but just intermediate device mapper devices when we are building the stack.\n\nOn a side note, I feel the \"assumed\" knowledege about the name of the block device is fragile (these device nodes can just as easily be called /dev/foo-1 depending on the uevent.rc of the device.\nI am in two minds about having an API like this for device node use cases specifically.\n\nIMO, we should solve the device node creation problem by registering with ueventd directly to notify clients whenever it creates a devices based on uevents.\nsimilar to udev_monitor - http://presbrey.scripts.mit.edu/doc/libudev/libudev-udev-monitor.html",
      "parentUuid": "85d0e96f_328d7ce1",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa2d900f_f42c515a",
        "filename": "base/include/android-base/file.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-06-12T20:06:15Z",
      "side": 1,
      "message": "Would we have other users except for these devices?  Seems like a bit overkill if not.  It looks like udev works via a socket, so we\u0027d need to poll on a socket in any case.  If we already have inotify, which accomplishes the same thing, with roughly the same client side implementation, and a standardized libc API, why isn\u0027t this already the best case?",
      "parentUuid": "39e4771f_b9ac84aa",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3bba0b90_2ee0804f",
        "filename": "base/include/android-base/file.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2019-06-12T22:05:42Z",
      "side": 1,
      "message": "Also, /dev/block/loopN nodes also fall into this category. gsid will be creating loop devices but not mounting them. In addition other callers (apexd, vold) set flags on the device before mounting.",
      "parentUuid": "fa2d900f_f42c515a",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39ff5005_d6c0af48",
        "filename": "base/include/android-base/file.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1108565
      },
      "writtenOn": "2019-06-12T22:59:00Z",
      "side": 1,
      "message": "The problem is implicit assumption of what the name of the device node is. For example, device mapper nodes do not have to be /dev/dm-X. They can be anything we want them to be depending on ueventd.rc.\nAs of now, the code that calls into WaitForFile() has no way of knowing that.\n\nSo, if someone does add a rule in their ueventd.rc to call loopback/dm devices something else or even change the location, then our code will break. The udev advantage is that it will notify you of all devices\ndetected of a given subsystem/subtype and their dev node names based on the udev rules. The caller then decides if they are interested in that particular node. IMO this is more accurate than the inotify() approach where we implictly assume what the dev nodes are named.\n\nUnless, We are signing up forever that all device mapper nodes will always be /dev/dm-X and ueventd.rc can\u0027t override it. We have to do the same for every user of this API too. (systemd does that I think).",
      "parentUuid": "3bba0b90_2ee0804f",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c345fab9_022ee12a",
        "filename": "base/include/android-base/file.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2019-06-12T23:40:03Z",
      "side": 1,
      "message": "If we used udev, we\u0027d have to filter for the correct device (probably by dev_t), so it\u0027d be less generic than this code. Also, our baked-in assumptions about dm- aren\u0027t that egregious. It\u0027s basically just libdm. Callers don\u0027t see it:\n\n  std::string path;\n  if (!dm.GetDmDevicePathByName(blah, \u0026path)) ...\n  if (!WaitForFile(path, 5s)) ...\n\nIt\u0027s true libfiemap_writer does hardcode StartsWith(\"dm-\"), but we can fix that.",
      "parentUuid": "39ff5005_d6c0af48",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "150adf40_f3a19ec0",
        "filename": "base/include/android-base/file.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2019-06-13T23:13:48Z",
      "side": 1,
      "message": "Sandeep and I talked offline; the concern is that we\u0027re asking callers to rely on paths that may not be reliable. Tom and I verified that we do, in fact, hardcode /dev/block/dm-N and /dev/block/loopN names:\n\nhttps://cs.corp.google.com/android/system/core/init/devices.cpp?q\u003df:devices.cpp\u0026sq\u003dpackage:%5Eandroid$\u0026dr\u0026l\u003d430\n\nThat said, we also now have /dev/block/mapper/\u003cname\u003e links that do not rely on numbering. We can start to simplify the above pattern:\n\n  if (!WaitForFile(\"/dev/block/mapper/system_gsi\", 5ms)) ...",
      "parentUuid": "c345fab9_022ee12a",
      "revId": "5841fbe7b8b78fa4488d195dd01a3fb648ee638d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}