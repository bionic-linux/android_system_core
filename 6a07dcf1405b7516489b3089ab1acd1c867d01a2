{
  "comments": [
    {
      "key": {
        "uuid": "919c0505_8b014ffd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 26
      },
      "lineNbr": 13,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "event",
      "range": {
        "startLine": 13,
        "startChar": 20,
        "endLine": 13,
        "endChar": 24
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "552509c2_519653cd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 26
      },
      "lineNbr": 13,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "919c0505_8b014ffd",
      "range": {
        "startLine": 13,
        "startChar": 20,
        "endLine": 13,
        "endChar": 24
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "01994183_0fd6c582",
        "filename": "/COMMIT_MSG",
        "patchSetId": 26
      },
      "lineNbr": 14,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "Could you explain further?",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 14,
        "endChar": 67
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e07bce7_ed0a4172",
        "filename": "/COMMIT_MSG",
        "patchSetId": 26
      },
      "lineNbr": 14,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "Depends on how vendor wants to define a non-responding system. Currently this is set to 700ms out of 1sec spent in complete stall. Will add this comment for more clarity.",
      "parentUuid": "01994183_0fd6c582",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 14,
        "endChar": 67
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7cc242c_f2022434",
        "filename": "/COMMIT_MSG",
        "patchSetId": 26
      },
      "lineNbr": 17,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "I believe this work is nicer than old since we could have more fine-grained control based on kernel\u0027s action. However, it seems it define many specific rules so want to review such rules step by step to see we could make them more simple.",
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52f8e9b4_ed29c702",
        "filename": "/COMMIT_MSG",
        "patchSetId": 26
      },
      "lineNbr": 17,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a7cc242c_f2022434",
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dba689b3_dc30849f",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 1928,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "Could we reverse the order of enum?\nSo that, wmark \u003e WMARK_HIGH means no memory pressure.\nwmark \u003e WMARK_LOW means it\u0027s HIGH_MEMORY pressure.\nIt seems to be more straightforward.",
      "range": {
        "startLine": 1925,
        "startChar": 0,
        "endLine": 1928,
        "endChar": 13
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "319f8e1e_89cd1ae1",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 1928,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dba689b3_dc30849f",
      "range": {
        "startLine": 1925,
        "startChar": 0,
        "endLine": 1928,
        "endChar": 13
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "999c1879_c1a4bfaa",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2021,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "Just a wish(it doesn\u0027t matter this patch): I also want to remove this meminfo because vmstat already has most data for us. A thing is free pages for swap. I hope we could add free swap into vmstat and then, finally remove meminfo.",
      "range": {
        "startLine": 2021,
        "startChar": 8,
        "endLine": 2021,
        "endChar": 21
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9a046c9_c5f84921",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2021,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "We can try that upstream and if we can add the missing into there I\u0027ll happily remove the meminfo parsing.",
      "parentUuid": "999c1879_c1a4bfaa",
      "range": {
        "startLine": 2021,
        "startChar": 8,
        "endLine": 2021,
        "endChar": 21
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32ba22c6_3931c241",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2021,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-25T13:53:57Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "f9a046c9_c5f84921",
      "range": {
        "startLine": 2021,
        "startChar": 8,
        "endLine": 2021,
        "endChar": 21
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "46b3cb50_d49e8aeb",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2076,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "wmark \u003d\u003d WMARK_MIN looks like more straightforward.\nAnd why do we need cycle_after_kill?\nWant to understand your intention.",
      "range": {
        "startLine": 2076,
        "startChar": 28,
        "endLine": 2076,
        "endChar": 45
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3ab68de_02f0a798",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2076,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "This is basically (wmark \u003d\u003d WMARK_MIN) but since these are watermarks I want the conditions to use \u003e or \u003c so that if the value is more or less a certain watermark then we act on it.\n\ncycle_after_kill means \"we killed and reclaimed dead process\u0027s memory and the system is still under high memory pressure (in this case actually still below min watermark)\", so we keep killing in this situation.",
      "parentUuid": "46b3cb50_d49e8aeb",
      "range": {
        "startLine": 2076,
        "startChar": 28,
        "endLine": 2076,
        "endChar": 45
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bef1180e_ae505fcb",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2076,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-25T13:53:57Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "c3ab68de_02f0a798",
      "range": {
        "startLine": 2076,
        "startChar": 28,
        "endLine": 2076,
        "endChar": 45
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aa49adbe_60c51457",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2079,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "Just out of curiosity: Why does it mean ANR?",
      "range": {
        "startLine": 2079,
        "startChar": 15,
        "endLine": 2079,
        "endChar": 61
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12093853_d963984d",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2079,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "70% of time in complete stall is pretty much a non-responding system. In the few cases when this event got triggered during testing I\u0027ve seen ANRs (Application not responding) recorded in the logcat.",
      "parentUuid": "aa49adbe_60c51457",
      "range": {
        "startLine": 2079,
        "startChar": 15,
        "endLine": 2079,
        "endChar": 61
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c143ba27_7fa327ef",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2079,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-25T13:53:57Z",
      "side": 1,
      "message": "If I understand PSI correctly, that means we will kill app if *kswapd* runs 700ms in 1sec?\nIt looks too aggressive because it\u0027s natural that kswapd runs in *background* for a long time if reclaim speed and allocation speed is similar. IOW, kswapd runs on CPU 1 and reclaim 10M/sec while app runs on CPU 2 and consumes memory 10M/sec. It\u0027s well balanced situation, not critical status.",
      "parentUuid": "12093853_d963984d",
      "range": {
        "startLine": 2079,
        "startChar": 15,
        "endLine": 2079,
        "endChar": 61
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "acfe0c76_0fafd86c",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2079,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-25T17:31:37Z",
      "side": 1,
      "message": "70% *complete* stall does not mean kswapd runs for 700ms in 1sec. It means no task (except for kswapd or a task directly reclaiming memory) can run for 700ms in the last 1sec because of memory congestion. IOW no task did any useful progress because all of them were doing some kind of memory cleanup or were blocked waiting for a page to be paged in. In your example because another task is running on CPU 2 this would not be recorded as a complete (full) stall, just partial (some) stall.",
      "parentUuid": "c143ba27_7fa327ef",
      "range": {
        "startLine": 2079,
        "startChar": 15,
        "endLine": 2079,
        "endChar": 61
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "413a856f_186913a4",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2088,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "Why do you want to decay thrashing_limit?\nOnce we understand the goal, I want to make them automatic tune without user intervention.",
      "range": {
        "startLine": 2088,
        "startChar": 37,
        "endLine": 2088,
        "endChar": 64
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90f1e6d7_51018be4",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2088,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "We decay thrashing_limit because if the system is thrashing even after we killed we don\u0027t want to wait for the same amount of thrashing to happen again before the next kill. This is similar to Integral term in the PID loop - when you made a correction and it did not have the desired effect you try harder (in our case we kill sooner).",
      "parentUuid": "413a856f_186913a4",
      "range": {
        "startLine": 2088,
        "startChar": 37,
        "endLine": 2088,
        "endChar": 64
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31117850_565c92f4",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2088,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-25T13:53:57Z",
      "side": 1,
      "message": "Then, can\u0027t we make thrashing_limit_decay_pct automatically without exposing user knob?\nFor example, first time is 10% and 2nd iteration 20%, 3rd: 40, 4th 80, finally 100%\nIt seems we start to expose too many knobs to user.",
      "parentUuid": "90f1e6d7_51018be4",
      "range": {
        "startLine": 2088,
        "startChar": 37,
        "endLine": 2088,
        "endChar": 64
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5fbb0fdb_781a44c5",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2088,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-25T17:31:37Z",
      "side": 1,
      "message": "Again, this is a decision of how much thrashing we are willing to tolerate on a particular device and for how long. Decaying the threshold allows us to limit the time that we will be tolerating thrashing (each next kill will happen sooner than the previous one). That\u0027s why the decay amount differs for low-ram devices vs high-performance devices but ultimately this is something that should be tunable for individual device.",
      "parentUuid": "31117850_565c92f4",
      "range": {
        "startLine": 2088,
        "startChar": 37,
        "endLine": 2088,
        "endChar": 64
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3d9a072a_551a48c5",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2101,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "Too specific rules: Could you order strongest option first? and then enumerate next rules step by step with justification. It would make review simple and code maintainable.",
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15626b92_f1efbaab",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2101,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "I did order them in the order of the strongest opinion first.\n#1 - we killed and the system is still very low on memory - close to OOM condition\n#2 - system is in complete stall and not responding\n#3, #4 - swap area is low and thrashing or low on memory\n#5, #6 - system is thrashing and memory is low or in direct reclaim\n\nThe first 4 can cause OOM kills while the last 2 are affecting performance of the device.",
      "parentUuid": "3d9a072a_551a48c5",
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d135b14_c550029f",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2101,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-25T13:53:57Z",
      "side": 1,
      "message": "#1: you check only watermark but doesn\u0027t check how many available pages we have.\nIOW, even though watermark is min at that time but we have many file-backed pages, system never goes OOM.\n\n#2: As I wrote above, 700ms PSI from kswapd seems to be not ANR state.\n\nLet\u0027s review other state in updated CL.",
      "parentUuid": "15626b92_f1efbaab",
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b5dc868_bb98fd4c",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2101,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-25T17:31:37Z",
      "side": 1,
      "message": "#1 means we are still in reclaim and the memory is under min threshold even after we killed the process and reclaimed its memory. If there were many filebacked pages freed as a result of the previous kill we should not be low on memory because we gave the system time to reclaim them (note that we wait for the process to die).\n\n#2 700ms of *complete* stall \u003d\u003d no task except for kswapd/direct reclaim was running because of memory congestion.",
      "parentUuid": "2d135b14_c550029f",
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aedf0e7f_be25e98b",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2105,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2019-09-23T16:42:58Z",
      "side": 1,
      "message": "How about moving killing into find_and_kill_process inside? and set it only if we send kill signal successfully.",
      "range": {
        "startLine": 2105,
        "startChar": 8,
        "endLine": 2105,
        "endChar": 23
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0499928_5c888808",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 26
      },
      "lineNbr": 2105,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-09-24T16:46:46Z",
      "side": 1,
      "message": "Good point. I\u0027ll check the return value of the find_and_kill_process() before setting the killing flag. This way we limit the scope of the killing variable and also handle the possible failure of kill_one_process().",
      "parentUuid": "aedf0e7f_be25e98b",
      "range": {
        "startLine": 2105,
        "startChar": 8,
        "endLine": 2105,
        "endChar": 23
      },
      "revId": "6a07dcf1405b7516489b3089ab1acd1c867d01a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}