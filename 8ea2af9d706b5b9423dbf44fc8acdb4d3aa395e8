{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6ab90138_e627a9be",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2023-06-21T14:48:07Z",
      "side": 1,
      "message": "They\u0027re generated by the kernel, not libdm.\n\nIf apexd is pre-creating empty devices to front-load the DM_DEV_CREATE time, that\u0027s fine. If it\u0027s doing it to pre-populate the uevent (which is asynchronous and can add a lot of delay), then it should call CreatePlaceholderDevice instead, which does generate a uevent.",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12a8a60f_68ef098c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-21T15:44:24Z",
      "side": 1,
      "message": "Yeah, I know that. libdm just checks if kernel reported that uevent was triggered upon the dm-remove call.\n\nAnd yes, apexd pre-populates bunch of empty dm devices but doesn\u0027t want to create uevent for all of them. So, I don\u0027t think CreatePlaceholderDevice is not what it would want.",
      "parentUuid": "6ab90138_e627a9be",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9954802_3ce84be1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1432579
      },
      "writtenOn": "2023-06-21T15:47:26Z",
      "side": 1,
      "message": "I think we want uevent to be created. The whole reason for pre-populating empty dm devices is to have ueventd asynchronously create the /dev nodes",
      "parentUuid": "12a8a60f_68ef098c",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2dfdf50b_89d0c5f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1432579
      },
      "writtenOn": "2023-06-21T10:17:23Z",
      "side": 1,
      "message": "Thanks!",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f84781e1_49bbe155",
        "filename": "fs_mgr/libdm/dm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 119,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2023-06-21T14:48:07Z",
      "side": 1,
      "message": "Should access() be moved before the ioctl, to avoid a race with ueventd?\n\nEven with that, I think this is still a tiny bit racy, but only under much more obscure circumstances.",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea24d1f4_71f6680f",
        "filename": "fs_mgr/libdm/dm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 119,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-21T15:44:24Z",
      "side": 1,
      "message": "Good catch. Moved it to right after the path is determined.",
      "parentUuid": "f84781e1_49bbe155",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}