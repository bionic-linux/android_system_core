{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6ab90138_e627a9be",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2023-06-21T14:48:07Z",
      "side": 1,
      "message": "They\u0027re generated by the kernel, not libdm.\n\nIf apexd is pre-creating empty devices to front-load the DM_DEV_CREATE time, that\u0027s fine. If it\u0027s doing it to pre-populate the uevent (which is asynchronous and can add a lot of delay), then it should call CreatePlaceholderDevice instead, which does generate a uevent.",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12a8a60f_68ef098c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-21T15:44:24Z",
      "side": 1,
      "message": "Yeah, I know that. libdm just checks if kernel reported that uevent was triggered upon the dm-remove call.\n\nAnd yes, apexd pre-populates bunch of empty dm devices but doesn\u0027t want to create uevent for all of them. So, I don\u0027t think CreatePlaceholderDevice is not what it would want.",
      "parentUuid": "6ab90138_e627a9be",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9954802_3ce84be1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1432579
      },
      "writtenOn": "2023-06-21T15:47:26Z",
      "side": 1,
      "message": "I think we want uevent to be created. The whole reason for pre-populating empty dm devices is to have ueventd asynchronously create the /dev nodes",
      "parentUuid": "12a8a60f_68ef098c",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5e92698_aecaec76",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2023-06-21T16:10:44Z",
      "side": 1,
      "message": "The only reason I bring it up is that the kernel behavior can and does change, and 5.15\u0027s uevent timing broke some stuff in AOSP. vold for example pre-creates an empty device for startup performance, and that optimization stopped working on 5.15. CreatePlaceholderDevice was added to hide the kernel-version-specific logic.",
      "parentUuid": "b9954802_3ce84be1",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcfe7687_06524f61",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-21T16:16:25Z",
      "side": 1,
      "message": "Hmm, I may be reading the code wrong, but it looks like `CreatePlaceholderDevice` does not generate uevent either. Calls to `dm_kobject_uevent` in `dm-ioctl.c` are only when (1) device is resumed, (2) device is removed, and (3) device is renamed. I am looking at kernel 6.1.\n\nAnd `CreatePlaceholderDevice` does NOT resume the device.",
      "parentUuid": "b9954802_3ce84be1",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2dfdf50b_89d0c5f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1432579
      },
      "writtenOn": "2023-06-21T10:17:23Z",
      "side": 1,
      "message": "Thanks!",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f84781e1_49bbe155",
        "filename": "fs_mgr/libdm/dm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 119,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2023-06-21T14:48:07Z",
      "side": 1,
      "message": "Should access() be moved before the ioctl, to avoid a race with ueventd?\n\nEven with that, I think this is still a tiny bit racy, but only under much more obscure circumstances.",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea24d1f4_71f6680f",
        "filename": "fs_mgr/libdm/dm.cpp",
        "patchSetId": 1
      },
      "lineNbr": 119,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-21T15:44:24Z",
      "side": 1,
      "message": "Good catch. Moved it to right after the path is determined.",
      "parentUuid": "f84781e1_49bbe155",
      "revId": "8ea2af9d706b5b9423dbf44fc8acdb4d3aa395e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}