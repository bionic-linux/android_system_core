{
  "comments": [
    {
      "key": {
        "uuid": "95250dc3_4c350f9e",
        "filename": "init/service.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1022,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T00:54:35Z",
      "side": 1,
      "message": "We can\u0027t start creating per-application memcgs just because memory cgroup is mounted. That\u0027s why ro.config.per_app_memcg was introduced so that we can have root-only memcg configuration. isMemoryCgroupSupported() condition here is not enough, you need to check if ro.config.per_app_memcg allows you to use per-application memcgs (which have their own reclaim performance issues).",
      "range": {
        "startLine": 1022,
        "startChar": 32,
        "endLine": 1022,
        "endChar": 39
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2095ba95_ec5d7eb6",
        "filename": "init/service.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1022,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:27:21Z",
      "side": 1,
      "message": "In practice we will only create two additional memory cgroups after this change and the upcoming frameworks/av change have landed: one for audioserver and another for mediaextractor. These correspond to the two processes which are currently calling limitProcessMemory. For all other processes we will continue to use cpuacct cgroups. It wouldn\u0027t work to make it conditional on per_app_memcg because this would mean that these two processes would only receive the security mitigation currently implemented by limitProcessMemory (and eventually implemented by memory cgroups for the reasons described in the bug) if per_app_memcg is set.",
      "parentUuid": "95250dc3_4c350f9e",
      "range": {
        "startLine": 1022,
        "startChar": 32,
        "endLine": 1022,
        "endChar": 39
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d5eaf47_0821c7d9",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T00:54:35Z",
      "side": 1,
      "message": "Cgroup implementation details like these should be hidden and localized as much as possible. This change exposes them even more. Why?",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ab7065b_c460cadf",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:27:21Z",
      "side": 1,
      "message": "The client of this library needs to control which kind of cgroup is being created so that it knows which kind of cgroup features it can use (i.e. cpuacct or memory). Also if, as you allude to elsewhere, memory cgroups create a performance issue then we presumably want to use them only where they are needed. That again means that the client needs to control the kind of cgroup.",
      "parentUuid": "9d5eaf47_0821c7d9",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e56f155_512ff638",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2018-10-31T01:30:25Z",
      "side": 1,
      "message": "i think he meant \"why isn\u0027t this something abstract like an enum?\"...",
      "parentUuid": "1ab7065b_c460cadf",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c2a3651_d8535d31",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:35:03Z",
      "side": 1,
      "message": "Okay, I\u0027d be fine with changing this to an enum.",
      "parentUuid": "9e56f155_512ff638",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad22c9b6_d14275b4",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 66,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T00:54:35Z",
      "side": 1,
      "message": "AFAIKT SetProcessGroupValue() will change its behavior in case when memcg is mounted but ro.config.per_app_memcg is false (the configuration we use on the latest Pixel devices).",
      "range": {
        "startLine": 66,
        "startChar": 11,
        "endLine": 66,
        "endChar": 26
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2145926_1bcd4552",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 66,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:27:21Z",
      "side": 1,
      "message": "Do we have any services that set any of the memcg.* options? If not, there is no functionality change on Pixel devices because of the condition at service.cpp:1017 which checks that any of the memcg.* variables are set before using memory cgroups. I did a code search in our internal tree for memcg.limit_in_bytes, memcg.soft_limit_in_bytes and memcg.swappiness and found no results outside of the init implementation, which would seem to indicate that these options are currently unused on Pixel devices.",
      "parentUuid": "ad22c9b6_d14275b4",
      "range": {
        "startLine": 66,
        "startChar": 11,
        "endLine": 66,
        "endChar": 26
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}