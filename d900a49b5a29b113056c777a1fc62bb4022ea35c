{
  "comments": [
    {
      "key": {
        "uuid": "95250dc3_4c350f9e",
        "filename": "init/service.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1022,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T00:54:35Z",
      "side": 1,
      "message": "We can\u0027t start creating per-application memcgs just because memory cgroup is mounted. That\u0027s why ro.config.per_app_memcg was introduced so that we can have root-only memcg configuration. isMemoryCgroupSupported() condition here is not enough, you need to check if ro.config.per_app_memcg allows you to use per-application memcgs (which have their own reclaim performance issues).",
      "range": {
        "startLine": 1022,
        "startChar": 32,
        "endLine": 1022,
        "endChar": 39
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2095ba95_ec5d7eb6",
        "filename": "init/service.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1022,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:27:21Z",
      "side": 1,
      "message": "In practice we will only create two additional memory cgroups after this change and the upcoming frameworks/av change have landed: one for audioserver and another for mediaextractor. These correspond to the two processes which are currently calling limitProcessMemory. For all other processes we will continue to use cpuacct cgroups. It wouldn\u0027t work to make it conditional on per_app_memcg because this would mean that these two processes would only receive the security mitigation currently implemented by limitProcessMemory (and eventually implemented by memory cgroups for the reasons described in the bug) if per_app_memcg is set.",
      "parentUuid": "95250dc3_4c350f9e",
      "range": {
        "startLine": 1022,
        "startChar": 32,
        "endLine": 1022,
        "endChar": 39
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ce064f6_c0e91f70",
        "filename": "init/service.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1022,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T02:39:37Z",
      "side": 1,
      "message": "Hmm, I think AndroidGo devices do not use any of these memcgs properties in their init and they need per-application memcgs (their ro.config.per_app_memcg is true). If so this CL will affect them by not creating per-app memcgs anymore.\n\nAside from that, with this implementation if more processes start using swappiness, soft_limits, etc they will generate separate per-application memcgs. The original implementation does not allow such \"on-request memcg creation\". Originally if ro.config.per_app_memcg is true then each application  gets a separate memcg and gains control over some memory aspects, if ro.config.per_app_memcg is false all applications will be using a root memcg. Not saying this is necessarily bad but we need to acknowledge this change in semantics and think about potential issues.",
      "parentUuid": "2095ba95_ec5d7eb6",
      "range": {
        "startLine": 1022,
        "startChar": 32,
        "endLine": 1022,
        "endChar": 39
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d5eaf47_0821c7d9",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T00:54:35Z",
      "side": 1,
      "message": "Cgroup implementation details like these should be hidden and localized as much as possible. This change exposes them even more. Why?",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ab7065b_c460cadf",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:27:21Z",
      "side": 1,
      "message": "The client of this library needs to control which kind of cgroup is being created so that it knows which kind of cgroup features it can use (i.e. cpuacct or memory). Also if, as you allude to elsewhere, memory cgroups create a performance issue then we presumably want to use them only where they are needed. That again means that the client needs to control the kind of cgroup.",
      "parentUuid": "9d5eaf47_0821c7d9",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e56f155_512ff638",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2018-10-31T01:30:25Z",
      "side": 1,
      "message": "i think he meant \"why isn\u0027t this something abstract like an enum?\"...",
      "parentUuid": "1ab7065b_c460cadf",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c2a3651_d8535d31",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:35:03Z",
      "side": 1,
      "message": "Okay, I\u0027d be fine with changing this to an enum.",
      "parentUuid": "9e56f155_512ff638",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0eed039_fcda0225",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T02:39:37Z",
      "side": 1,
      "message": "I actually meant that these details should be contained as much as possible and not exposed to the users. The issue with the APIs that expose things like path to where a cgroup is mounted, availability of one cgroup controller vs another and availability of specific attributes will hurt us down the road when we decide to migrate to cgroups v2 (which as an example does not have a swappiness attribute that setProcessGroupSwappiness() currently uses) or if we decide to move to another hierarchy.\n\nIt would have been easier to make such changes if API reflects an intent and not how that intent is achieved. Ultimately user should not care which cgroup is used as long as the request is satisfied (or failed because it can\u0027t be satisfied with available mechanisms).\n\nI\u0027m working on abstracting cgroups usage (see: go/android-cgroup-abstraction) but it\u0027s in the early stages, so I don\u0027t want to affect your project plans. However we should make sure additional usage does not make this problem worse.\n\nPlease don\u0027t take these comments as a critique of your particular CL. Cgroup-related APIs in Android overall are unfortunately very implementation specific.",
      "parentUuid": "8c2a3651_d8535d31",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 29,
        "endChar": 0
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad22c9b6_d14275b4",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 66,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T00:54:35Z",
      "side": 1,
      "message": "AFAIKT SetProcessGroupValue() will change its behavior in case when memcg is mounted but ro.config.per_app_memcg is false (the configuration we use on the latest Pixel devices).",
      "range": {
        "startLine": 66,
        "startChar": 11,
        "endLine": 66,
        "endChar": 26
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2145926_1bcd4552",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 66,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-10-31T01:27:21Z",
      "side": 1,
      "message": "Do we have any services that set any of the memcg.* options? If not, there is no functionality change on Pixel devices because of the condition at service.cpp:1017 which checks that any of the memcg.* variables are set before using memory cgroups. I did a code search in our internal tree for memcg.limit_in_bytes, memcg.soft_limit_in_bytes and memcg.swappiness and found no results outside of the init implementation, which would seem to indicate that these options are currently unused on Pixel devices.",
      "parentUuid": "ad22c9b6_d14275b4",
      "range": {
        "startLine": 66,
        "startChar": 11,
        "endLine": 66,
        "endChar": 26
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0e63105_be141543",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 66,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2018-10-31T02:39:37Z",
      "side": 1,
      "message": "Ack, but please see my comment in service.cpp about breaking AndroidGo devices.\n\n\nA side note: if memcg.limit_in_bytes, memcg.soft_limit_in_bytes and memcg.swappiness are not yet used I would love to remove them as they imply all these memcg attributes will be always available (which is false for cgroups v2).",
      "parentUuid": "f2145926_1bcd4552",
      "range": {
        "startLine": 66,
        "startChar": 11,
        "endLine": 66,
        "endChar": 26
      },
      "revId": "d900a49b5a29b113056c777a1fc62bb4022ea35c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}