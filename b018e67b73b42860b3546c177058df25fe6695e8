{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "73269c35_cb2b917c",
        "filename": "toolbox/modprobe.cpp",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1557540
      },
      "writtenOn": "2024-11-04T20:48:38Z",
      "side": 1,
      "message": "I don\u0027t think this covers the case where you have 4k page size modules directly under `/lib/modules` and 16k page size modules under `/lib/modules/major.minor-16k`. For that case `n \u003e 0` and therefore you wouldn\u0027t call `mod_dirs.emplace_back(path_entry)`.",
      "range": {
        "startLine": 254,
        "startChar": 0,
        "endLine": 259,
        "endChar": 0
      },
      "revId": "b018e67b73b42860b3546c177058df25fe6695e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36ed2103_c5bad740",
        "filename": "toolbox/modprobe.cpp",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 2055842
      },
      "writtenOn": "2024-11-05T12:20:31Z",
      "side": 1,
      "message": "To my understanding, as for the second case:\n- /lib/modules/major.minor-16k - this case would fall into the first path of the if clause, i.e. `n \u003e 0` which is preserved from the original solution. In case the path matches the `KernelVersionNameFilter` it would be added.\n\n- as for the second case - modules directly stored under `/lib/modules` - if this directory exists it would be added to the path anyway - please note that in this case, the scandir function returns `0` - directory exists but no matching entries were found. To summarize, if the `/lib/modules` directory exists it would be added anyway, no matter the page size. I guess that there would be no point in adding the path if it doesn\u0027t exist, even when the page size equals 4096.\n\nI might be missing something in my understanding though. Could you please look at this again?\nThanks!",
      "parentUuid": "73269c35_cb2b917c",
      "range": {
        "startLine": 254,
        "startChar": 0,
        "endLine": 259,
        "endChar": 0
      },
      "revId": "b018e67b73b42860b3546c177058df25fe6695e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "83bd76c0_9388b1d2",
        "filename": "toolbox/modprobe.cpp",
        "patchSetId": 6
      },
      "lineNbr": 259,
      "author": {
        "id": 1557540
      },
      "writtenOn": "2024-11-05T23:41:37Z",
      "side": 1,
      "message": "Right, but you don\u0027t handle the case where a device has both. When the for-loop iterates over `/lib/modules`, `scandir()` will return 1 for the directory `major.minor-16k` and we will add `/lib/modules/major.minor-16k` to `mod_dirs` and then continue to the next set of `module_paths`. That means the directory `/lib/modules` won\u0027t be added to `mod_dirs` and we will fail to boot when the page size is 4k.\n\nWe handled this before with the check where `mod_dirs` contains only the 16k page directory and not `/lib/modules` itself:\n```\nif (mod_dirs.empty() || getpagesize() \u003d\u003d 4096) {\n  mod_dirs.emplace_back(LIB_MODULES_PREFIX);\n}\n```",
      "parentUuid": "36ed2103_c5bad740",
      "range": {
        "startLine": 254,
        "startChar": 0,
        "endLine": 259,
        "endChar": 0
      },
      "revId": "b018e67b73b42860b3546c177058df25fe6695e8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}