{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3e631bf9_38635ee3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-09-29T21:12:01Z",
      "side": 1,
      "message": "+pirama in case he knows any more background here...",
      "revId": "8d3b31fe68140ef45fc3c7786a352d0daa0785ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "90ee52d2_6dadb67a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1058860
      },
      "writtenOn": "2021-09-29T21:44:53Z",
      "side": 1,
      "message": "FWIW, for the code-coverage flush signal (37), we look at SigCgt for a pid to check if a handler is installed before sending that signal.  Maybe traced and heapprofd (https://cs.android.com/android/platform/superproject/+/master:bionic/libc/platform/bionic/reserved_signals.h;l\u003d42?q\u003dbionic%2Flibc%2Fplatform%2Fbionic%2Freserved_signals.h\u0026ss\u003dandroid) should do the same as well?\n\nWe could also consider changing the default action for these to ignore rather than kill.  We didn\u0027t do this for code coverage since we\u0027re moving away from using signals there.\n\nBoth suggestions won\u0027t help older releases though.  If snapuserd is a mainline module, this change would help older releases and it seems like a better solution.",
      "parentUuid": "3e631bf9_38635ee3",
      "revId": "8d3b31fe68140ef45fc3c7786a352d0daa0785ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e718b07_66f8a554",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-09-29T21:57:02Z",
      "side": 1,
      "message": "+primiano for \"Maybe traced and heapprofd...\"\n\n\u003e We could also consider changing the default action for these to ignore rather than kill.\n\nwe can\u0027t change the kernel, but maybe the static libc startup code should do that to be more like (or at least \"less unlike\") the dynamic libc startup code. i\u0027m a bit confused by dvander\u0027s \"since we\u0027re statically linked, we were not getting these builtin signal handlers\" though --- i thought static and dynamic were the same these days? ah, crap, looks like that\u0027s something we did for debuggerd (where we actually have functional parity) but the new BIONIC_SIGNAL_PROFILER stuff is indeed only for dynamic binaries.\n\nthat just seems like a bionic bug? shouldn\u0027t we revert this change and just `signal(BIONIC_SIGNAL_ART_PROFILER, SIG_IGN);` in bionic\u0027s static libc startup code? otherwise everyone [with a static binary] has to deal with this. (and hard-code magic like `SIGRT_MIN+4` and so on.) that seems pretty terrible?\n\n(that would also mean nothing for primiano\u0027s folks to do, i think.)",
      "parentUuid": "90ee52d2_6dadb67a",
      "revId": "8d3b31fe68140ef45fc3c7786a352d0daa0785ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea6a38f7_4f866762",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2021-09-29T22:27:24Z",
      "side": 1,
      "message": "If it\u0027s possible to fix this in bionic that\u0027d be great - we\u0027re not the only static executable.",
      "parentUuid": "4e718b07_66f8a554",
      "revId": "8d3b31fe68140ef45fc3c7786a352d0daa0785ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96ea915b_089908ad",
        "filename": "fs_mgr/libsnapshot/snapuserd/snapuserd_daemon.cpp",
        "patchSetId": 1
      },
      "lineNbr": 83,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-09-29T21:12:01Z",
      "side": 1,
      "message": "not the best name any more :-)",
      "range": {
        "startLine": 83,
        "startChar": 13,
        "endLine": 83,
        "endChar": 43
      },
      "revId": "8d3b31fe68140ef45fc3c7786a352d0daa0785ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa760abd_aa9215f2",
        "filename": "fs_mgr/libsnapshot/snapuserd/snapuserd_daemon.cpp",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-09-29T21:12:01Z",
      "side": 1,
      "message": "this is weird... something\u0027s not right here. this should automatically be done for you (and this call should be a no-op). see filter_reserved_signals() in bionic.",
      "revId": "8d3b31fe68140ef45fc3c7786a352d0daa0785ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "46c8bea7_9d4ee0e3",
        "filename": "fs_mgr/libsnapshot/snapuserd/snapuserd_daemon.cpp",
        "patchSetId": 1
      },
      "lineNbr": 90,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2021-09-29T21:19:04Z",
      "side": 1,
      "message": "The bug we hit was that, since we\u0027re statically linked, we were not getting these builtin signal handlers. The choice to statically link was to limit the number of things that get entrained with snapuserd, since the binary gets execveat()\u0027d off the ramdisk while /system is mounted (and during that time we cannot read from /system).\n\nSince snapuserd dying will cause a failed OTA, we thought blocking the signals would be a good defense measure.",
      "parentUuid": "fa760abd_aa9215f2",
      "revId": "8d3b31fe68140ef45fc3c7786a352d0daa0785ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}