{
  "comments": [
    {
      "key": {
        "uuid": "9ca06ac4_5277e46a",
        "filename": "fastboot/device/variables.cpp",
        "patchSetId": 1
      },
      "lineNbr": 427,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-10-30T18:23:49Z",
      "side": 1,
      "message": "really a question for Tom:\n\nstd::move() more efficient, or does the compiler already know?",
      "range": {
        "startLine": 427,
        "startChar": 15,
        "endLine": 427,
        "endChar": 60
      },
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f77209d5_d4e24395",
        "filename": "fastboot/device/variables.cpp",
        "patchSetId": 1
      },
      "lineNbr": 427,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-10-30T18:28:51Z",
      "side": 1,
      "message": "It\u0027s an rvalue here, it\u0027ll move already.",
      "parentUuid": "9ca06ac4_5277e46a",
      "range": {
        "startLine": 427,
        "startChar": 15,
        "endLine": 427,
        "endChar": 60
      },
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "065c1ffd_3555ad35",
        "filename": "fastboot/fastboot.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-10-30T18:00:32Z",
      "side": 1,
      "message": "This only changes UpdateSuperPartition()\u0027s functionality, since the rest of the partitions are fully specified with their suffix, right?  \n\nDoes this always do what we want it to?  Specifically does it flash both slots (and both super partitions) when slot_override \u003d\u003d \"all\"?  From my reading of the code, it doesn\u0027t look like it will.",
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1db0b5cd_ab0d221e",
        "filename": "fastboot/fastboot.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-10-30T20:45:27Z",
      "side": 1,
      "message": "Indeed it won\u0027t do that. I just realized an additional problem which is that this code should run before DetermineSecondarySlot(), which in turn needs to handle \"all\" as a special case (it currently works accidentally because \"all\" starts with an \u0027a\u0027).\n\nThe easiest fix would be to create two instances of FlashAllTool, one for the A slot and one for the B slot. Flashing would take exactly twice as long. Another option would be to explicitly update both super partitions, then to set_active before each flash operation (so that it picked the right set of super partitions). Then we wouldn\u0027t have to resparse everything twice.\n\nPreference?",
      "parentUuid": "065c1ffd_3555ad35",
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14d7bbf9_1fdbfc28",
        "filename": "fastboot/fastboot.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-10-30T22:48:44Z",
      "side": 1,
      "message": "I don\u0027t think we need two instances, especially since then we\u0027ll get DumpInfo() and CheckRequirements() called twice.  The code should handle almost all of this, except that UpdateSuperPartition() needs to be done for both the primary and secondary slot in some cases, right?  I think refactoring UpdateSuperPartition() such that it can be called for both of those cases is going to be the best way forward here.  Using get_other_slot(), etc can make this work.",
      "parentUuid": "1db0b5cd_ab0d221e",
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7e6bcbd_e9b21699",
        "filename": "fastboot/fastboot.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-10-30T22:51:46Z",
      "side": 1,
      "message": "The catch is that, when there are two super partitions, we need to toggle between them before flashing partitions of different slots. It\u0027s a bit gross but I don\u0027t think it would cause any problems.",
      "parentUuid": "14d7bbf9_1fdbfc28",
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "44f8e1ef_03f2eadd",
        "filename": "fastboot/fastboot.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-10-30T22:58:44Z",
      "side": 1,
      "message": "What do you mean toggle between them?  We should be able to just add a 2nd UpdateSuperPartition() call that takes a parameter indicating that it is meant to update the secondary super partition.  Both resizing to 0 and the subsequent flashes should work correctly after that since os_images_ is going to contain all of the images from both slots. \n\nOr otherwise, have UpdateSuperPartition() handle both slots itself if slot_override_ \u003d\u003d all.  do_for_partitions() should be able to handle this for us.",
      "parentUuid": "d7e6bcbd_e9b21699",
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b08ec264_503fd355",
        "filename": "fastboot/fastboot.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-10-30T23:03:15Z",
      "side": 1,
      "message": "Because when opening a partition, we create it based on the currently active slot\u0027s metadata. On an A/B device, partition_[a|b] will exist in both copies of the metadata, so it just works. On a retrofit device, partition_a will be in super_a and partition_b will be in super_b. If the active slot is A, we can\u0027t flash partition_b.\n\nI guess we could handle this within fastbootd (by inferring a retrofit and reading out the partition\u0027s suffix), if we don\u0027t want to set_active from the host tool.",
      "parentUuid": "44f8e1ef_03f2eadd",
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72703e4a_fe8004bf",
        "filename": "fastboot/fastboot.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-10-30T23:08:28Z",
      "side": 1,
      "message": "Might be worth handling that in fastbootd.  \n\nWhat happens if I\u0027m on slot A and I do simply `fastboot flash system_b ...` ?  Or worse, what about secondary images (system_other.img).  We\u0027d need to switch active partitions twice even in a normal flashing scenario to flash system_other.img on a retrofit device.",
      "parentUuid": "b08ec264_503fd355",
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a07fd9e_f1ff021e",
        "filename": "fs_mgr/liblp/utility.cpp",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-10-30T18:23:49Z",
      "side": 1,
      "message": "Is this single character check legitimate?\n\nvbmeta, is it vbmet slot a ...",
      "range": {
        "startLine": 102,
        "startChar": 43,
        "endLine": 102,
        "endChar": 46
      },
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52ff3a3c_0c33e503",
        "filename": "fs_mgr/liblp/utility.cpp",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-10-30T20:45:27Z",
      "side": 1,
      "message": "No, I agree it\u0027s better to just disallow this, and make sure the boot control HAL is prefixing with an underscore.",
      "parentUuid": "4a07fd9e_f1ff021e",
      "range": {
        "startLine": 102,
        "startChar": 43,
        "endLine": 102,
        "endChar": 46
      },
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31697228_549b1478",
        "filename": "fs_mgr/liblp/utility.cpp",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-10-30T22:48:44Z",
      "side": 1,
      "message": "We\u0027ll need to be backwards compatible with other bootloaders too though.  We\u0027ll probably need to allow the _ as well.",
      "parentUuid": "52ff3a3c_0c33e503",
      "range": {
        "startLine": 102,
        "startChar": 43,
        "endLine": 102,
        "endChar": 46
      },
      "revId": "a57aea27254d229f5ec72a05436c943e2cdfcba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}