{
  "comments": [
    {
      "key": {
        "uuid": "f5a9361e_17cfcb6d",
        "filename": "libunwindstack/Symbols.cpp",
        "patchSetId": 8
      },
      "lineNbr": 108,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-04-16T19:47:13Z",
      "side": 1,
      "message": "Would it be worth checking if the structure is already aligned and not copying in that case? I don\u0027t know if this would be worth it though.",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 108,
        "endChar": 83
      },
      "revId": "af41960acb56efd5fb7d1fb1b18dae21b4d6b122",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21a8d3ec_605481bc",
        "filename": "libunwindstack/Symbols.cpp",
        "patchSetId": 8
      },
      "lineNbr": 108,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2020-04-17T14:24:52Z",
      "side": 1,
      "message": "It is not worth it, since the compiler completely eliminates the copy if it knows the CPU can handle unaligned loads (which is true for any modern CPU).\n\nvmarko points out that there are some specific ARM instructions which must be aligned (e.g. ldp - load register pair). In which case, this code restricts the compiler from doing some load optimizations (e.g. using ldp instead of two ldr).",
      "parentUuid": "f5a9361e_17cfcb6d",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 108,
        "endChar": 83
      },
      "revId": "af41960acb56efd5fb7d1fb1b18dae21b4d6b122",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3846f229_37a0d4b1",
        "filename": "libunwindstack/Symbols.cpp",
        "patchSetId": 8
      },
      "lineNbr": 108,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2020-04-17T21:09:13Z",
      "side": 1,
      "message": "There might be some compiler-specific attributes, but I am not aware of one.  The one Florian mentioned above can be used to enforce larger alignment, but not reduce it.\n\nMemcpy is often the only way to ensure portable spec-compliant reinterpretations (same goes e.g. for bitcasts between float and int).  The bright side is that consequently compilers specifically optimize for this.\n\nSpecifically, I checked the disassembly to make sure there no actual memcpy call.  So there are likely other approaches as well, but they would not be any more efficient.  It is just syntax preference.",
      "parentUuid": "21a8d3ec_605481bc",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 108,
        "endChar": 83
      },
      "revId": "af41960acb56efd5fb7d1fb1b18dae21b4d6b122",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c530cb38_eb1e6cef",
        "filename": "libunwindstack/Symbols.cpp",
        "patchSetId": 8
      },
      "lineNbr": 108,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2020-04-17T21:31:51Z",
      "side": 1,
      "message": "Sounds good to me, feel free to submit whenever you are ready.",
      "parentUuid": "3846f229_37a0d4b1",
      "range": {
        "startLine": 107,
        "startChar": 0,
        "endLine": 108,
        "endChar": 83
      },
      "revId": "af41960acb56efd5fb7d1fb1b18dae21b4d6b122",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}