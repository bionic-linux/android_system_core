{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "62006da5_0f95f69c",
        "filename": "libutils/Looper.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-03-31T18:02:33Z",
      "side": 1,
      "message": "handled in latest PS",
      "range": {
        "startLine": 110,
        "startChar": 11,
        "endLine": 110,
        "endChar": 60
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a5f26da_8f473df7",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-03-31T16:10:28Z",
      "side": 1,
      "message": "idk why I didn\u0027t do something like this years ago.\n\nOne alternative would be to call this ANDROID_UTILS_SP_DISABLE_IMPLICIT_*CONSTRUCTION* and to remove this and L52-52 constructor. In that case, we would need to provide `sp\u003cT\u003e sp\u003cT\u003e::selfRef()`. Actually - let try that. No reason to have this partial solution.",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af9b799d_f2d7c125",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-03-31T17:08:59Z",
      "side": 1,
      "message": "I\u0027m not sure I fully understand yet what you have in mind. What about Line 64?\n\nOtherwise I like the approach. There is the usual concern that repeated and nested includes don\u0027t really work as desired. We probably need a strong recommendation to only define ANDROID_UTILS_SP_DISABLE_IMPLICIT_* at the beginning of .cpp files or with compiler flags. And you may have to clean up a bunch of seemingly unrelated .h files to do that. But it still looks feasible.",
      "parentUuid": "1a5f26da_8f473df7",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6138b6b_0ff98864",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-03-31T18:02:33Z",
      "side": 1,
      "message": "PS3 now has the strongest ownership semantics I can think of. Though, I could revert to PS2 if you think it\u0027s too much.\n\nI might also want to convert another big library to use the correct semantics before merging this.\n\nre re usual concerns - it comes with the trade - any specific place we could document it? For souls unfortunate enough to skip over how the C preprocessor works, I am not sure the most effective way to share this information. For the mentioned libbase flag, people always add it in cflags seemingly without prompt.",
      "parentUuid": "af9b799d_f2d7c125",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c9f7a88_75ed60c6",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-03-31T18:05:22Z",
      "side": 1,
      "message": "if there was a possibility that a weaker variant would let us make this opt-out rather than opt-in, that might be interesting. otherwise, if we\u0027re going to be opt-in anyway, we may as well go for the safest variant?",
      "parentUuid": "f6138b6b_0ff98864",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "776ad030_4f5dc598",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-03-31T18:07:52Z",
      "side": 1,
      "message": "Exactly - we are so far beyond opt-out here - for either approach.",
      "parentUuid": "5c9f7a88_75ed60c6",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "121a31de_e03dd971",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-02T02:15:37Z",
      "side": 1,
      "message": "resolve",
      "parentUuid": "776ad030_4f5dc598",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e032cadc_59eaeaa9",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-04-02T22:23:47Z",
      "side": 1,
      "message": "I basically like it, but I\u0027m slightly worried whether this might be too viral in nature. Any factory function that now returns a C pointer would now have to return an sp instead, even if the function is defined elsewhere. So the conversion now becomes a bit non-local. Probably that\u0027s still worth it, but I don\u0027t have great intuition about this and wanted to raise the issue.\n\nI\u0027d be tempted to just add a comment at the top of this file explaining what ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION does, and discouraging definitions in code. That could be near the comment block added by aosp/1663182.",
      "parentUuid": "121a31de_e03dd971",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e5fb196_f0bf990c",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-02T22:36:40Z",
      "side": 1,
      "message": "\u003e Any factory function that now returns a C pointer would now have to return an sp instead\n\nThis is intentional. I want the APIs to include the proper lifetime information. You can see an example of what you\u0027re talking about here (where I started to convert libbinder to use this - still WIP - I wanted a smaller initial project):\nhttps://android-review.googlesource.com/c/platform/frameworks/native/+/1663086/1/libs/binder/include/binder/BpBinder.h#43\n\nIn this case, I am able to fix the API to correctly reflect the type since it has too few clients. In cases where there are many clients - well first of all, shame on that API! but a gradual conversion is always possible like such (yes - slightly more annoying than an atomic conversion b/c of inability to overload based on return types in C++):\n\n    Foo* errorProneFactoryFunction();\n    +sp\u003cFoo\u003e greatFactoryFunction() {\n    +    return sp\u003cFoo\u003e::fromExisting(errorProneFactoryFunction());\n    +}\n\n\u003e tempted to just add a comment at the top of this file explaining what ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION\n\nWill do.",
      "parentUuid": "e032cadc_59eaeaa9",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d287c1c_bf35146d",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-02T22:52:20Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "3e5fb196_f0bf990c",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78383d15_f7a93427",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-04-02T22:54:50Z",
      "side": 1,
      "message": "This only works if errProneFactoryFunction() returns a pointer that already has a strong reference elsewhere, right? I have no idea whether we have a lot of factory functions that return raw pointers to objects without other references.",
      "parentUuid": "3e5fb196_f0bf990c",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad7bb6e0_fd0d7592",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-02T23:12:20Z",
      "side": 1,
      "message": "There are three cases - either the object returned from this factory is intended to be used with RefBase or not or the API expects both are possible:\n- if it is, then the correct thing to do would be to update the factory function to reflect this (I accept this may be a viral change, but otherwise I cannot imagine how to disambiguate the hapless T*).\n- if it is not, then \u0027fromExisting\u0027 would correctly assert in clients when they make the not-quite-fatal mistake of double-ownership\n- if the API expects both usages are possible (and I have never seen someone do this), I would say we should change the API to use RefBase ownership which would add negligible overhead given that we are already allocating this data, but it could be split into two factory functions (one which returns an explicitly owned object and one which returns an explicitly unowned object).\n\n\u003e whether we have a lot of factory functions that return raw pointers to objects without other references.\n\nIf we do, one option available to us would be to add an escape hatch. Someone might be able to twist my arm enough to not -2 \u0027sp::unsafeTakeOwnership(T*)\u0027. The less user friendly alternative would be to undef the flag in a specific file, but in certain cases it could cause linking errors that would be difficult to fix.\n\nAlso, yes, I know I\u0027m disagreeing with the C++ standard library (not the first time). Maybe you know why we have `shared_ptr( Y* ptr, Deleter d );` \u0026 friends, yet we don\u0027t have something similar for std::vector? Is it historical? I am - now for over a year - mentally preparing myself to fork libc++ in Android to fix the very annoying bug b/131868573.",
      "parentUuid": "78383d15_f7a93427",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c0f2468_8e75b6cd",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-04-05T18:07:10Z",
      "side": 1,
      "message": "I\u0027m OK with that as is, even if it might on occasion force a larger follow-up CL. It clearly doesn\u0027t make sense to preemptively add ugly workarounds for possible problems.\n\nI wasn\u0027t in on the discussions about explicit deleters. I think they largely predate my presence on the committee. I assume the difference is that shared_ptr requires a raw pointer, and thus there is no way to wrap it in a class with a different destructor. I believe the C++ committee only really started thinking about the \"exceptions disabled\" case fairly recently. That seems to be common practice elsewhere, too. But the arguments for turning off exceptions seem to be hazy enough and diverge enough to make it harder to push for changes to support this mode.",
      "parentUuid": "ad7bb6e0_fd0d7592",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 42,
        "endChar": 26
      },
      "revId": "10aa7f24d92af473876f2f093f56c1cf76b586e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}