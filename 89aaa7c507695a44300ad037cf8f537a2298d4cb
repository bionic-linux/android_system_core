{
  "comments": [
    {
      "key": {
        "uuid": "cb38ebf5_7e3fdee6",
        "filename": "libbacktrace/backtrace_benchmarks.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-08-19T16:36:32Z",
      "side": 1,
      "message": "|O_CLOEXEC\n\nsince this is a benchmark, why not just ReadFileToString + Split + size?\n\nand why bother with the `if` here? the general case works for pid \u003d\u003d getpid() too.",
      "range": {
        "startLine": 46,
        "startChar": 33,
        "endLine": 46,
        "endChar": 41
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9aece197_0c0b1827",
        "filename": "libbacktrace/backtrace_benchmarks.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T18:07:42Z",
      "side": 1,
      "message": "I didn\u0027t want to use the ReadFileToString and split because it winds up allocating a bunch of memory so that you get some new maps created.\n\nI don\u0027t know that it\u0027s strictly necessary to have the same number of maps, but I wanted to make it possible to compare the numbers from the new and old as much as possible.",
      "parentUuid": "cb38ebf5_7e3fdee6",
      "range": {
        "startLine": 46,
        "startChar": 33,
        "endLine": 46,
        "endChar": 41
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f3a3c4cd_02b6f9d7",
        "filename": "libbacktrace/backtrace_benchmarks.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-08-23T21:27:53Z",
      "side": 1,
      "message": "definitely needs a comment explaining why, or the next person through will turn this into the otherwise equivalent one-liner.",
      "parentUuid": "9aece197_0c0b1827",
      "range": {
        "startLine": 46,
        "startChar": 33,
        "endLine": 46,
        "endChar": 41
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "27b0b230_b73573a8",
        "filename": "libbacktrace/backtrace_benchmarks.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T22:52:18Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "f3a3c4cd_02b6f9d7",
      "range": {
        "startLine": 46,
        "startChar": 33,
        "endLine": 46,
        "endChar": 41
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f9e46fbe_c387d4f5",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2017-08-19T03:00:36Z",
      "side": 1,
      "message": "what kind of input can result in error? how to reproduce that?",
      "range": {
        "startLine": 60,
        "startChar": 32,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f2ddcac_d2f7c138",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T18:07:42Z",
      "side": 1,
      "message": "In the test code, I added an explicit line that should not have parsed correctly, but passes.\n\nSee the last test in the verify_parse_line test.",
      "parentUuid": "f9e46fbe_c387d4f5",
      "range": {
        "startLine": 60,
        "startChar": 32,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b1811d32_5b39fbd8",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-08-23T21:27:53Z",
      "side": 1,
      "message": "ah, right. this is WAI, so you should probably fix the comment. (or tell the truth, which is that the performance is the real reason you\u0027re rewriting this, no?)\n\n       Â·      A sequence of white-space characters (space, tab, newline, etc.;\n              see isspace(3)).  This directive matches  any  amount  of  white\n              space, including none, in the input.\n\n(i think the trick if you want to use scanf for this is to use a character class %[.)",
      "parentUuid": "1f2ddcac_d2f7c138",
      "range": {
        "startLine": 60,
        "startChar": 32,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d30870f_1f02f4d4",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2017-08-23T21:35:36Z",
      "side": 1,
      "message": "I see, how scanf handles whitespace character surprises me. Can you add more details in the comment?",
      "parentUuid": "1f2ddcac_d2f7c138",
      "range": {
        "startLine": 60,
        "startChar": 32,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "185edf55_a4f94447",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T22:52:18Z",
      "side": 1,
      "message": "I removed this particular comment because it\u0027s not entirely true.\n\nI found a bug in the sscanf in glibc which caused a crash, but ours didn\u0027t crash. The problem is that sscanf doesn\u0027t handle ignored parameters in a way I would like. For example, if you have any ignored parameters, and the line data doesn\u0027t include that, you don\u0027t get any indication of the failure. I wrote a version of this that properly detected bad parsing (no ignore parameters), but then I found that the whole approach was running really slow.\n\nI mentioned in the CL description that this was done for performance reasons, and I added a small comment here so someone doesn\u0027t try and move this to sscanf in the future.",
      "parentUuid": "4d30870f_1f02f4d4",
      "range": {
        "startLine": 60,
        "startChar": 32,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97e0db04_2120635b",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 165,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-08-19T16:36:32Z",
      "side": 1,
      "message": "unique_fd?",
      "range": {
        "startLine": 165,
        "startChar": 2,
        "endLine": 165,
        "endChar": 5
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f04cc370_2503fa7b",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 165,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T18:07:42Z",
      "side": 1,
      "message": "I\u0027m trying to keep this code from using anything Android specific as much as possible. At some point, I want to remove the dependency on libbase completely.",
      "parentUuid": "97e0db04_2120635b",
      "range": {
        "startLine": 165,
        "startChar": 2,
        "endLine": 165,
        "endChar": 5
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "755dd093_f710696a",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-08-19T16:36:32Z",
      "side": 1,
      "message": "is this actually necessary? shouldn\u0027t you be getting the libc++ \u003cstring.h\u003e with the const-correct overloads?",
      "range": {
        "startLine": 185,
        "startChar": 22,
        "endLine": 185,
        "endChar": 45
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ea0fdb4_17137668",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T18:07:42Z",
      "side": 1,
      "message": "It doesn\u0027t compile without it since this is a cast from char* to void*.",
      "parentUuid": "755dd093_f710696a",
      "range": {
        "startLine": 185,
        "startChar": 22,
        "endLine": 185,
        "endChar": 45
      },
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e2ce5869_44ef939e",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 193,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-08-19T16:36:32Z",
      "side": 1,
      "message": "can you benchmark the two halves of this change separately? i can more easily believe that a hand-rolled sscanf is cheaper, but i\u0027m both surprised and concerned that getline is measurably slower than roughly the same code...",
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f00272f_3f47d965",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 193,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T18:07:42Z",
      "side": 1,
      "message": "I spent some time benchmarking the code, and on a sailfish locked to max, and running on a single cpu at high priority, just the change from getline to this code saves roughly 800ns when parsing a 3000 line maps file.\n\nI suspect that most of my speed up is the fact that I have almost no overhead because I never realloc the internal buffer since I don\u0027t need to carry around the previous data. I can throw it away and keep going.\n\nAs to why I\u0027m optimizing this, my new unwinder depends heavily on this, and I\u0027ll probably have to try and find ways to optimize this even further and/or come up with some other method to go from address to elf data.",
      "parentUuid": "e2ce5869_44ef939e",
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ffe449aa_ef20756e",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 193,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-08-23T21:27:53Z",
      "side": 1,
      "message": "getline shouldn\u0027t realloc either, unless the new line is actually larger than the currently allocated space.\n\nexperimenting with the benchmarks, it does look like (for 4Ki lines) the overhead of copying the bytes is where the rest of the time goes, so that might be as good as stdio can get.",
      "parentUuid": "9f00272f_3f47d965",
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c0f64880_86615fde",
        "filename": "libunwindstack/Maps.cpp",
        "patchSetId": 3
      },
      "lineNbr": 193,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2017-08-23T22:52:18Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "ffe449aa_ef20756e",
      "revId": "89aaa7c507695a44300ad037cf8f537a2298d4cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}