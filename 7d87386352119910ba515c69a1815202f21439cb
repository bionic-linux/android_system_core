{
  "comments": [
    {
      "key": {
        "uuid": "cb26962d_433a492f",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 3
      },
      "lineNbr": 316,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-07-26T16:04:57Z",
      "side": 1,
      "message": "KISS? (recursion, untested)\n\nstatic char* unsigned_to_str(unsigned val, char *str, char *end) {\n    int div_val \u003d val / 10;\n    if (div_val) str \u003d unsigned_to_str(div_val, str, end);\n    if (str \u003d\u003d end) return str;\n    *str++ \u003d \u00270\u0027 + (val % 10);\n    return str;\n}\n\nstatic char* int_to_str(int val, char *str, char *end) {\n    if (val \u003c 0) {\n        if (str \u003d\u003d end) return str;\n        *str++ \u003d \u0027-\u0027;\n        val \u003d -val;\n    }\n    return unsigned_to_str(val, str, end);\n}\n\nstatic char* itona_suffix(int val, char* str, char* end, char suffix) {\n    str \u003d int_to_str(val, str, end)\n    if (str \u003d\u003d end) return str;\n    if (suffix) { /* all callers have a suffix, so drop check? but offers flexibility for more general purpose use as-is */\n        *str++ \u003d suffix;\n        if (str \u003d\u003d end) return str;\n    }\n    *str \u003d \u0027\\0\u0027;\n    return str;\n}\n. . .\n                pstr \u003d itona(target.oom_adj_score, pstr, \u0026minfree_str[PROPERTY_VALUE_MAX], \u0027:\u0027);\n                if (pstr \u003d\u003d \u0026minfree_str[PROPERTY_VALUE_MAX]) break;",
      "range": {
        "startLine": 277,
        "startChar": 1,
        "endLine": 316,
        "endChar": 1
      },
      "revId": "7d87386352119910ba515c69a1815202f21439cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b57e34bb_e440d9dc",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 3
      },
      "lineNbr": 319,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2018-07-26T16:09:04Z",
      "side": 1,
      "message": "you\u0027re already dragging in printf\u0027s internals for your error logging. why not reuse it?",
      "revId": "7d87386352119910ba515c69a1815202f21439cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c500b8b_93879e9c",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 3
      },
      "lineNbr": 319,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-07-26T16:26:45Z",
      "side": 1,
      "message": "+1 (_except_ for hot paths in lmkd as previously discussed. serenb@ already noted that _these_ paths are not a _hot_, so) snprintf will do wrapped in this function. Thanks for centering us back on the point. snprintf is measured to take multiples of micro-seconds (exceeds a system call overhead) to do its job.\n\nThe itona function merely may be used _simplify_ code maintenance as the fragment using it is repeated three times in the following and introduced moderately complex mechanics surrounding suffix characters and overflow that could easily be encapsulated. Thus (based on above proposal, untested):\n\nstatic char* itona_suffix(int val, char* str, size_t len, char suffix) {\n    size_t size \u003d snprintf(str, len, \"%d%c\", val, suffix);\n    if (size \u003e len) return str + len;\n    return str + size - 1;\n}",
      "parentUuid": "b57e34bb_e440d9dc",
      "revId": "7d87386352119910ba515c69a1815202f21439cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19dffa36_5294e432",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 3
      },
      "lineNbr": 319,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2018-07-26T16:33:06Z",
      "side": 1,
      "message": "the benchmarks dispute that claim:\n\nBM_stdio_printf_d              244 ns        243 ns    2891976\nBM_time_clock_gettime_syscall        393 ns        391 ns    1788488",
      "parentUuid": "7c500b8b_93879e9c",
      "revId": "7d87386352119910ba515c69a1815202f21439cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "256b7462_f0b0fa6e",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 3
      },
      "lineNbr": 319,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-07-26T17:55:16Z",
      "side": 1,
      "message": "The point is moot since this is not a hot path.\n\nSo, I should have prefaced my comment with \u0027on some architectures it can, + or -\u0027 ;-}\n\nThose values you report are in the same \u0027range\u0027, as in +/- 30%, and are both significantly larger than some hand-rolled bin-\u003estring code that can resolve in tens of ns, and I have seen the benchmarks for system calls and sprintf \u0027reverse\u0027 to your figures on some architectures. For instance, on the N9 (64-bit) and N5 (32-bit) sprintf (circa 2014 admittedly) turned into a significant portion of the logging overhead as compared to the combination of collecting the time and pushing a write to the unix domain socket.",
      "parentUuid": "19dffa36_5294e432",
      "revId": "7d87386352119910ba515c69a1815202f21439cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6080e711_1901ab9c",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 3
      },
      "lineNbr": 680,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-07-26T16:04:57Z",
      "side": 1,
      "message": "This is a repeating fragment in all use cases (so adjusted code suggestion above to handle),",
      "range": {
        "startLine": 676,
        "startChar": 0,
        "endLine": 680,
        "endChar": 29
      },
      "revId": "7d87386352119910ba515c69a1815202f21439cb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}