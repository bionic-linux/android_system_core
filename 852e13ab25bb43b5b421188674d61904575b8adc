{
  "comments": [
    {
      "key": {
        "uuid": "6049bff7_be65ec61",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 79,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "This (and above) init paths should \u0027upgrade\u0027 force_only option to autosuspend_and_force option.",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 79,
        "endChar": 29
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0f27432_960150d0",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 79,
      "author": {
        "id": 1061103
      },
      "writtenOn": "2018-01-08T00:51:56Z",
      "side": 1,
      "message": "I\u0027m not sure I want to do two separate init() functions....\nIf PowerManager doesn\u0027t use forceSuspend, it doesn\u0027t need to worry about the extra interface.  If I\u0027ve already coded up \u0027autosuspend_and_force\u0027, then there\u0027s no need to make a \u0027force_only\u0027.\n\nAlso, I suspect force really does want to go through the autosuspend path.  The more I look at power manager, that wakeup_count dance is the right sequence of stuff to do.",
      "parentUuid": "6049bff7_be65ec61",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 79,
        "endChar": 29
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68c937f4_4528983e",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "A different init path, if not already inited, then chose the force_only option.",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 29
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6bb03455_85a66325",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "note: AFAIK this will never be NULL so remains OK.",
      "range": {
        "startLine": 109,
        "startChar": 27,
        "endLine": 109,
        "endChar": 40
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03cd33ff_a4d51aa6",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "return autosuspend_ops-\u003eforce_suspend(timeout_ms);",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 110,
        "endChar": 15
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "340aecc7_59f81456",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 219,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "This is functionally the relaxed force suspend. It is an admirable feature to be made available for future capabilities in the Power Manager, it may be out of scope for an independent process to trigger an immediate force suspend that is being required today.",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 219,
        "endChar": 1
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "23bff981_8e4b6108",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 219,
      "author": {
        "id": 1061103
      },
      "writtenOn": "2018-01-05T05:51:19Z",
      "side": 1,
      "message": "Yeah... that\u0027s the problem.\n\nAIUI, in our system, we have two independent processes:\n\n1)  Android PowerManager - it only uses autosuspend\n2)  CarService - it only uses forcesuspend\n\nLife would be so much easier if I could plumb forceSuspend through Android PM.  It doesn\u0027t look that hard; it would be a SMOP to insert it a forcesuspend() call into the binder interface for powermanagerservice and the related java files.\n\nAny idea if that would be a remote possibility if the code was already written?  :)",
      "parentUuid": "340aecc7_59f81456",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 219,
        "endChar": 1
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd989b21_d5f7ed37",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 219,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-05T16:04:35Z",
      "side": 1,
      "message": "The jni needs to be written anyways. But inserting it into Android PowerManager is beyond our control for the moment. After implementation and tested here at this level, if it is adding a new exported method in the power manager to propagate, you might find less resistance.\n\nAs noted, the force suspend with timeout_ms \u003d 0 (or the force suspend performed at timeout) only needs to take a wakelock to disable the autosuspend mechanics. And that works across processes.",
      "parentUuid": "23bff981_8e4b6108",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 219,
        "endChar": 1
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce57f353_770ffda9",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "I have declared \u0027this is yucky\u0027(tm)\n\nIf force_suspend is only called with timeout_ms \u003d 0 (which is the API case for an independent process ala Automotive Power Manager), there is no need for any of this initialization. How to reconcile that is \u0027interesting\u0027 because one can not access force_suspend until after the autosuspend_wakeup_count_ops are exported; and they can not happen.\n\nIf we are to allow force_suspend with a timeout_ms value (for the relaxed case best utilized when this request is in-process), then we need integration into autosuspend as you have added here. There are several issues to be addressed.\n\nSuggestion:\n\n- Create _two_ autosuspend_ops, each serviced with an associated init() function.\n- One supplied integrated force_suspend with autosuspend; the other provides force_suspend without autosuspend features.\n- In both cases, so that you do not have to implement all this complicated locking or communications, ignore the timeout value (or error out if timeout is set) and act like timeout is zero. One can attack the integration issue later.\n- Caller selects which behavior it wants (integrated, or forced only).",
      "range": {
        "startLine": 237,
        "startChar": 1,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c20e8560_ebdd42b0",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1061103
      },
      "writtenOn": "2018-01-05T05:51:19Z",
      "side": 1,
      "message": "IMO, the timeout is necessary because reading the wakeup_count can block.\n\nI\u0027m thinking suspend should follow the same process as suspend_thread_func.  In psuedo code, a forcesuspend(int timeout) might look like this:\n\nint forcesuspend(int timeout) {\n  // disable wakelocks\n\n  // do the following block of code in a separate thread to guard against blocking read:\n  {\n    ReadFdToString(wakeup_count_fd, \u0026wakeup_count);\n    WriteStringToFd(wakeup_count, wakeup_count_fd);\n    sem_post(forcesuspend_continue);\n  }\n\n  // Wait until write succeeds or timeout expires\n  sem_wait_timeout(forcesuspend_continue, timout);\n\n  // go to suspend (either safely because write succeeded, or just force it)\n  Write mem --\u003e sys/power/state to suspend\n\n  // now we\u0027ve woken up again\n  // enable wakelocks\n}\n\n\nThe complexity with the multiple semaphores and mutex is to share the read/write of wakeup_count logic with forcesuspend.  After analyzing the function a little more today, I think I have a cleaner way to integrate forcesuspend with autosuspend.\n\nThe complexity I have now is the inter-process aspect of the system.  I really want to be able to call into libsuspend from CarPowerManagerService.  The idea of having two instances of libsuspend running seems very unclean.\n\nI looked at the Android PowerManagerService, and it looks like autosuspend is enabled all the time.  Hence, there\u0027s no easy way to disable it without hacking at PowerManagerService.",
      "parentUuid": "ce57f353_770ffda9",
      "range": {
        "startLine": 237,
        "startChar": 1,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40db62d9_bed0f553",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-05T16:04:35Z",
      "side": 1,
      "message": ":-( regarding power manager complexity. A wakelock is the only/best way of stopping the autosuspend.\n\nYour path for forcesuspend where timeout\u003d0 does not require any accesses to wakeup_count_fd and _only_ has the write to /sys/power/state.",
      "parentUuid": "c20e8560_ebdd42b0",
      "range": {
        "startLine": 237,
        "startChar": 1,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd37033b_b7fdc2d0",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1061103
      },
      "writtenOn": "2018-01-08T00:51:56Z",
      "side": 1,
      "message": "I thought using wakeup_count_fd is a way to sequence the suspend in a \u0027safe\u0027 manner.  Otherwise, as soon as I write mem-\u003epower/state, the system will either:\n\na)  Not suspend entirely\nb)  Wakeup immediately due to pending wakeevent\n\nAIUI, the wakeup_count dance is used to make sure the system is in a suitable state to perform suspend for any reasonable length of time.  Forcing mem-\u003epower/state is sort of a last resort that is not likely to work, but does force an attempt to suspend.\n\nTo avoid replicating the logic in two places, I think we still need some synchronization.  Maybe we do something like this:\n\nforce_suspend() {\n  // take a wakelock to prevent libsuspend from activating\n  // disable all other wakelocks\n  // sem_post() (in case libsuspend is NOT active)\n  // release the wakelock to allow libsuspend to sleep.\n\n\u003cfollowing happens in thread once the wakelock is released\u003e\n  // call HAL specific interface \n  // mem -\u003e power/state\n  // \u003con wakeup\u003e call HAL specific interface to wakeup\n\n\u003creturn control to force_suspend via separate semaphore\u003e\n  // re-enable wakelocks\n}\n\nI\u0027m trying to write this logic now to post as an example.",
      "parentUuid": "40db62d9_bed0f553",
      "range": {
        "startLine": 237,
        "startChar": 1,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}