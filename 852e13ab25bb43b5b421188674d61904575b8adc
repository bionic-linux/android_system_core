{
  "comments": [
    {
      "key": {
        "uuid": "6049bff7_be65ec61",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 79,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "This (and above) init paths should \u0027upgrade\u0027 force_only option to autosuspend_and_force option.",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 79,
        "endChar": 29
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68c937f4_4528983e",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "A different init path, if not already inited, then chose the force_only option.",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 29
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6bb03455_85a66325",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "note: AFAIK this will never be NULL so remains OK.",
      "range": {
        "startLine": 109,
        "startChar": 27,
        "endLine": 109,
        "endChar": 40
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03cd33ff_a4d51aa6",
        "filename": "libsuspend/autosuspend.c",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "return autosuspend_ops-\u003eforce_suspend(timeout_ms);",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 110,
        "endChar": 15
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "340aecc7_59f81456",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 219,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "This is functionally the relaxed force suspend. It is an admirable feature to be made available for future capabilities in the Power Manager, it may be out of scope for an independent process to trigger an immediate force suspend that is being required today.",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 219,
        "endChar": 1
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "23bff981_8e4b6108",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 219,
      "author": {
        "id": 1061103
      },
      "writtenOn": "2018-01-05T05:51:19Z",
      "side": 1,
      "message": "Yeah... that\u0027s the problem.\n\nAIUI, in our system, we have two independent processes:\n\n1)  Android PowerManager - it only uses autosuspend\n2)  CarService - it only uses forcesuspend\n\nLife would be so much easier if I could plumb forceSuspend through Android PM.  It doesn\u0027t look that hard; it would be a SMOP to insert it a forcesuspend() call into the binder interface for powermanagerservice and the related java files.\n\nAny idea if that would be a remote possibility if the code was already written?  :)",
      "parentUuid": "340aecc7_59f81456",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 219,
        "endChar": 1
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd989b21_d5f7ed37",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 219,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-05T16:04:35Z",
      "side": 1,
      "message": "The jni needs to be written anyways. But inserting it into Android PowerManager is beyond our control for the moment. After implementation and tested here at this level, if it is adding a new exported method in the power manager to propagate, you might find less resistance.\n\nAs noted, the force suspend with timeout_ms \u003d 0 (or the force suspend performed at timeout) only needs to take a wakelock to disable the autosuspend mechanics. And that works across processes.",
      "parentUuid": "23bff981_8e4b6108",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 219,
        "endChar": 1
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce57f353_770ffda9",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-04T23:54:24Z",
      "side": 1,
      "message": "I have declared \u0027this is yucky\u0027(tm)\n\nIf force_suspend is only called with timeout_ms \u003d 0 (which is the API case for an independent process ala Automotive Power Manager), there is no need for any of this initialization. How to reconcile that is \u0027interesting\u0027 because one can not access force_suspend until after the autosuspend_wakeup_count_ops are exported; and they can not happen.\n\nIf we are to allow force_suspend with a timeout_ms value (for the relaxed case best utilized when this request is in-process), then we need integration into autosuspend as you have added here. There are several issues to be addressed.\n\nSuggestion:\n\n- Create _two_ autosuspend_ops, each serviced with an associated init() function.\n- One supplied integrated force_suspend with autosuspend; the other provides force_suspend without autosuspend features.\n- In both cases, so that you do not have to implement all this complicated locking or communications, ignore the timeout value (or error out if timeout is set) and act like timeout is zero. One can attack the integration issue later.\n- Caller selects which behavior it wants (integrated, or forced only).",
      "range": {
        "startLine": 237,
        "startChar": 1,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c20e8560_ebdd42b0",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1061103
      },
      "writtenOn": "2018-01-05T05:51:19Z",
      "side": 1,
      "message": "IMO, the timeout is necessary because reading the wakeup_count can block.\n\nI\u0027m thinking suspend should follow the same process as suspend_thread_func.  In psuedo code, a forcesuspend(int timeout) might look like this:\n\nint forcesuspend(int timeout) {\n  // disable wakelocks\n\n  // do the following block of code in a separate thread to guard against blocking read:\n  {\n    ReadFdToString(wakeup_count_fd, \u0026wakeup_count);\n    WriteStringToFd(wakeup_count, wakeup_count_fd);\n    sem_post(forcesuspend_continue);\n  }\n\n  // Wait until write succeeds or timeout expires\n  sem_wait_timeout(forcesuspend_continue, timout);\n\n  // go to suspend (either safely because write succeeded, or just force it)\n  Write mem --\u003e sys/power/state to suspend\n\n  // now we\u0027ve woken up again\n  // enable wakelocks\n}\n\n\nThe complexity with the multiple semaphores and mutex is to share the read/write of wakeup_count logic with forcesuspend.  After analyzing the function a little more today, I think I have a cleaner way to integrate forcesuspend with autosuspend.\n\nThe complexity I have now is the inter-process aspect of the system.  I really want to be able to call into libsuspend from CarPowerManagerService.  The idea of having two instances of libsuspend running seems very unclean.\n\nI looked at the Android PowerManagerService, and it looks like autosuspend is enabled all the time.  Hence, there\u0027s no easy way to disable it without hacking at PowerManagerService.",
      "parentUuid": "ce57f353_770ffda9",
      "range": {
        "startLine": 237,
        "startChar": 1,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40db62d9_bed0f553",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 1
      },
      "lineNbr": 269,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-05T16:04:35Z",
      "side": 1,
      "message": ":-( regarding power manager complexity. A wakelock is the only/best way of stopping the autosuspend.\n\nYour path for forcesuspend where timeout\u003d0 does not require any accesses to wakeup_count_fd and _only_ has the write to /sys/power/state.",
      "parentUuid": "c20e8560_ebdd42b0",
      "range": {
        "startLine": 237,
        "startChar": 1,
        "endLine": 269,
        "endChar": 41
      },
      "revId": "852e13ab25bb43b5b421188674d61904575b8adc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}