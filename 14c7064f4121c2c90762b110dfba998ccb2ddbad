{
  "comments": [
    {
      "key": {
        "uuid": "02084f95_b9b04556",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 40,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T23:39:12Z",
      "side": 1,
      "message": "Do we need -a if it\u0027s the default if no partitions are specified?  What happens if -a is specified plus a list of partitions?",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "915056e9_4d3a4e88",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 40,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-05T19:42:17Z",
      "side": 1,
      "message": "Simple answers: no and \u0027both, but an error will likely be reported if they do not overlap or make sense\u0027. It would take three lines added to make them functionally orthogonal with no changes in the code as it stands, I opted to let the code as it stands report back if it was an error when it was nonsensical.\n\n[-a|[partition]...] _confuses_ people more, but does signal orthogonal use. Does not matter what the implementation detail is, it is simpler to report \"[-a] [partition]...\" and trust that people are smart enough to realize it and not try to \u0027game\u0027 remount.\n\nBeing actually functionally orthogonal or not, is a separate discussion as part of other comments below.",
      "parentUuid": "02084f95_b9b04556",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f46b7ef5_467e47b9",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 40,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-05T21:04:02Z",
      "side": 1,
      "message": "But why not just drop -a all together?  The second line can just be \"remounts all partitions if none specified\" and it\u0027ll be easy enough to understand with no possibility to provide contradictory inputs.  \n\nIt\u0027s not uncommon to have something similar as a default for shell utilities; think about `getprop` or even `ls`, `mount`, etc.",
      "parentUuid": "915056e9_4d3a4e88",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "db73e487_a57145ed",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 54,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T23:39:12Z",
      "side": 1,
      "message": "slot_select_other isn\u0027t remountable?",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b10e8134_268ed2fa",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 54,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-05T19:42:17Z",
      "side": 1,
      "message": "b/c of how overlayfs works, alternate slot partitions are _stolen_ _wiped_ and _repurposed_ as overlay backing storage. We just can not allow them to be candidates for remount r/w even if they are in the fstab.\n\nadb remount does not do it either.",
      "parentUuid": "db73e487_a57145ed",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a561bcf_c6c8d065",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 54,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-05T21:04:02Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b10e8134_268ed2fa",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c97d893_e8d77b11",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 136,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T23:39:12Z",
      "side": 1,
      "message": "\u0026partition and \u0026mount_point below.",
      "range": {
        "startLine": 136,
        "startChar": 66,
        "endLine": 136,
        "endChar": 75
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2e515da_74557871",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 136,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-05T19:42:17Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3c97d893_e8d77b11",
      "range": {
        "startLine": 136,
        "startChar": 66,
        "endLine": 136,
        "endChar": 75
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c04b8646_6bc1b011",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 157,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T23:39:12Z",
      "side": 1,
      "message": "I think this all gets easier if we drop the \u0027all\u0027 and assume that no partitions provided means all.  You could check optind vs argc and either do the above loop, or do this below loop, but skipping the find_if() lines.\n\nBoth of those loops are likely better if they\u0027re broken out into separate functions too, then we just have\n\nstd::vector\u003candroid::fs_mgr::FstabEntry\u003e partitions;\nif (argc \u003d\u003d optind) {\n  GetAllPartitions(\u0026partitions);\n} else {\n  GetSpecificPartitions(argc, argv, optind, \u0026partitions);\n}",
      "range": {
        "startLine": 157,
        "startChar": 16,
        "endLine": 157,
        "endChar": 34
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fefa273_69518043",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 157,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-05T19:42:17Z",
      "side": 1,
      "message": "Oooops, the find_if is still required in both cases, because the (overlayfs) rule is that the automatic partitions must be the highest path (StartsWith). However, we are not doing so in this simpler implementation, which concerns me. Your suggestion does not fix that, it makes it worse.\n\neg: this is borken if one lists the partitions \"/ /system /vendor /vendor/firmware\". For overlayfs that should translate to /system and /vendor only, skipping the other two as not errors. For non-overlayfs it could translate to / /vendor /vendor/firmware, succeeding for the first two, and failing for the third one. Depending on configuration.\n\nI wrote it to deal \"quickly\" with the common DAP / overlayfs scenario moving forward associated with the bug\u0027s requirements and not initially for Q as a _replacement_ or fully hardened component (because that would delay this to R and not solve the immediate problem) for \u0027adb remount\u0027 being inaccessible to the remote framework. Hardening it in \u0027R\u0027 as needed later to deal with such subtleties was the hope.\n\nBut it does not deal well with the non-DAP or mixed scenarios. Do we _want_ or _need_ to support odd non DAP or legacy scenarios? Yes, (eventually) we need to do a better job of determining all list with an eye on overlayfs _before_ parsing the explicit list. Doing so may help, we could add such to the --help report so they know what --all (or empty, no matter) will do.\n\nNeed to collect the entire \u0027all\u0027 list, then dedupe them and apply the overlayfs rules as necessary. Also will want to look into how we deal with normally non-candidate partitions (like /vendor/firmware) and if we want to support them?\n\neg:\n\nw/ overlayfs\n\n/vendor\n/vendor/firmware (dropped)\n\nw/o overlayfs\n\n/vendor\n/vendor/firmware (kept, but can we remount it? should we report an error?)\n\nIf we collect the \u0027all\u0027 list first, we may be able to improve --help, that will be worth it!",
      "parentUuid": "c04b8646_6bc1b011",
      "range": {
        "startLine": 157,
        "startChar": 16,
        "endLine": 157,
        "endChar": 34
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5630c72_7c2f26f6",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 157,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-05T21:04:02Z",
      "side": 1,
      "message": "Good point about the overlayfs rule.  I still think it\u0027d be better if we broke this into different functions just for readability.\n\nThat does bring up a different issue with overlayfs though.  What if someone does:\n\n`remount /vendor/firmware/`\nthen\n`remount /vendor`\n?\n\nDoes the second remount then fail since it would nest the previous one?  Or does it shadow the first one?  A bit of an edge case, but if we\u0027re going to give people a utility that allows it, we should have a plan for handling it.\n\nIn any case, this is probably fine if we need something for test infrastructure now though.  We\u0027ll want to think through it better for the future and I think it\u0027s a good goal to have this as the backing functionality for `adb remount` to merge the two remount paths.",
      "parentUuid": "8fefa273_69518043",
      "range": {
        "startLine": 157,
        "startChar": 16,
        "endLine": 157,
        "endChar": 34
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b85c10b_27163e10",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 157,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-06T15:12:31Z",
      "side": 1,
      "message": "Please check on the bug. I am not even 100% sure we _need_ this command, _want_ it yes, since the real solution is to fix the remote access framework that is limited in its ability to issue adb \u0027commands\u0027 and is focussed on the shell connection. No one appears to own the remote framework ...\n\nIt is a _helpful_ command nonetheless and given the daunting task to script out a remount on-device (rather than via \u0027adb remount\u0027), I can see some uses to facilitate testing and that it could eventually become the executable called by \u0027adb remount\u0027.\n\nRemount has too many edge cases, we need to cap the effort, we need to limit what it can do. The goal was to replace \u0027mount -o rw,remount\u0027 for the overlayfs cookbook which is far too complicated to script. Only with a possibility afterwards to be considered the \u0027worker executable\u0027 for the similarly limited functionality in adb remount which also does not respect the edge cases.\n\nFor your specific example, if it was managed by overlayfs, I would expect/want remount to perform the operation on /vendor, and not touch /vendor/firmware. If not overlayfs, remount /vendor/firmware.\n\nHowever, for \u0027Q\u0027 I would accept it to fail for /vendor/firmware if it was too complicated to support, because in \u0027P\u0027 you were not allowed to remount it anyways via adb remount ... I would only handle this edge case if it was part of a generalized loop (or series of loops) but certainly not if it had a complicated decision tree.",
      "parentUuid": "a5630c72_7c2f26f6",
      "range": {
        "startLine": 157,
        "startChar": 16,
        "endLine": 157,
        "endChar": 34
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22a6b798_d5f64807",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 157,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-06T17:42:56Z",
      "side": 1,
      "message": "\u003e Remount has too many edge cases, we need to cap the effort, we need to limit what it can do. T\n\nI agree 100%, which is why we need to make sure the inputs to this tool don\u0027t allow us to get into these situations.  Since you said, we don\u0027t need this tool, then we certainly don\u0027t need to make it take inputs that we know would cause issues.\n\nWhy don\u0027t we go back a step and make this even more basic: just remount the hard coded list of partitions that `adb remount` does for P.  That shouldn\u0027t add any more edge cases than we currently have and would be trivial to make `adb remount` use, which I do think is an important goal, since we really do not want two divergent code paths for remounting.  Would that be enough for the automation team?",
      "parentUuid": "5b85c10b_27163e10",
      "range": {
        "startLine": 157,
        "startChar": 16,
        "endLine": 157,
        "endChar": 34
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36447f64_b65cf063",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 169,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T23:39:12Z",
      "side": 1,
      "message": "Maybe better to just have the contents of fs_mgr_overlayfs_verity_enabled_list() leaked outside of the for loop too?  \n\nBetter, this whole loop can be moved into a different function too, in which case there is no penalty for having the auto verity \u003d fs_mgr_overlayfs_verity_enabled_list() at top.",
      "range": {
        "startLine": 169,
        "startChar": 9,
        "endLine": 169,
        "endChar": 13
      },
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ab5d6df_d4a8c416",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 222,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T23:39:12Z",
      "side": 1,
      "message": "Probably better to use rbegin() and rend() and iterate through this from rbegin() to rend() instead of decrementing the end() iterator.\n\nMaybe break this into a different function too?  Or do something like find_mount() in remount_service.cpp ?",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fd35054_e9cffe35",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 8
      },
      "lineNbr": 222,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-05T19:42:17Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "0ab5d6df_d4a8c416",
      "revId": "14c7064f4121c2c90762b110dfba998ccb2ddbad",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}