{
  "comments": [
    {
      "key": {
        "uuid": "55ca265d_71d9a75a",
        "filename": "common_apex/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2019-07-23T15:13:26Z",
      "side": 1,
      "message": "neither of these is appropriate for this.\n\ndid you get the real numbers from static linking yet?",
      "range": {
        "startLine": 31,
        "startChar": 4,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "094f62ecc53efb39927d141c0594dd5f3e2536ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e31f175_f304f8cf",
        "filename": "common_apex/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-07-23T16:31:35Z",
      "side": 1,
      "message": "\u003e neither of these is appropriate for this.\n\nI don\u0027t understand why. Could you elaborate? We all know that these libs don\u0027t have stable ABIs, but this APEX will be updated along with other APEXes that use this. So ABI instability is not a problem.\n\n\u003e did you get the real numbers from static linking yet?\n\nJooyung might have a number, but I can expect that the saving with this APEX will increase as the number of APEXes increases. I just don\u0027t want to decide go/no-go based on the current set of APEXes.",
      "parentUuid": "55ca265d_71d9a75a",
      "range": {
        "startLine": 31,
        "startChar": 4,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "094f62ecc53efb39927d141c0594dd5f3e2536ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "898abfbb_0c01c6b5",
        "filename": "common_apex/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2019-07-23T22:19:25Z",
      "side": 1,
      "message": "\u003e this APEX will be updated along with other APEXes that use this. So ABI instability is not a problem.\n\nHow does that actually work? The whole system image is updated at the same time, but since there are prebuilts involved it\u0027s extremely difficult (nearly impossible) to make ABI changes that affect the prebuilts.\n\nAre all of the dependent APEXs building against a snapshot of the common APEX? Is the common APEX a snapshot of the platform libraries? Or are these all built simultaneously. If they\u0027re not snapshots, that means we can\u0027t submit any change until all the downstream fixes are available. This takes the burden off the APEX owners and gives them basically no incentive to actually adapt to ABI changes, which effectively means there will be no changes.\n\nIf they do build a snapshot, how do we ensure that changes to the common APEX won\u0027t end up breaking the downstream projects in unintended ways? And when they break in an expected way (have to adapt to some ABI change), what happens if they don\u0027t? Do we have to roll back the change to the common APEX?\n\nIs this the same libc++ as the platform\u0027s, or is this another build variant? i.e. if I want to make ABI changes to /system/lib64/libc++.so, what are the constraints? If the APEX owners don\u0027t adapt to the ABI changes and the common APEX change has to be rolled back, does the platform also have to roll back the change?\n\nI\u0027m sure these things have been thought about, but they haven\u0027t been communicated to us so it\u0027s very unclear how any of this works, and we can\u0027t sign off on it if we don\u0027t understand it.",
      "parentUuid": "6e31f175_f304f8cf",
      "range": {
        "startLine": 31,
        "startChar": 4,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "094f62ecc53efb39927d141c0594dd5f3e2536ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79a316ff_90b8aa60",
        "filename": "common_apex/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-07-24T02:36:46Z",
      "side": 1,
      "message": "Yeah, the APEX prebuilts are all built from the same source tree (at least for now). If you make an ABI change to a lib in the common APEX, then it will be reflected to all APEX prebuilts at the same time when they are built for the next train.\n\nWe have a plan to make it \"versioned\" snapshots in order to unbundle the modules dev from the platform dev. Changing the ABI will bump the snapshot version. However, APEXes are protected from the ABI change because they can build against the old snapshot. The only requirement is that all APEXes in the same train should be built with the version of the snapshot that the common APEX in the train is providing.\n\n\u003e Is this the same libc++ as the platform\u0027s, or is this another build variant? \n\nInternally, a lib built for an APEX is mutated. So /system/lib/libc++.so and libc++.so inside the common APEX are built separately. But since no std objects are shared across the platform and APEXes, ABI mismatch across them is okay.\n\n\u003e If the APEX owners don\u0027t adapt to the ABI changes and the common APEX change has to be rolled back, does the platform also have to roll back the change?\n\nNo. Also note that rollback is a train-level event. So if the common APEX is rolled back, so do the other APEXes in the same train.",
      "parentUuid": "898abfbb_0c01c6b5",
      "range": {
        "startLine": 31,
        "startChar": 4,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "094f62ecc53efb39927d141c0594dd5f3e2536ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64ee1b46_f5f78bde",
        "filename": "common_apex/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2019-07-25T17:20:39Z",
      "side": 1,
      "message": "if this is true, i don\u0027t understand why we\u0027re not just shipping one big module? that would give us better + smaller code + more sharing, without any of the disadvantages.\n\ni\u0027m _really_ worried that today we\u0027re told \"yeah, lack of ABI stability is fine\" but then in 3 years when we can\u0027t update one module for some reason but still want to update the others, but we\u0027re already painted into a corner where we can\u0027t do that there\u0027s screaming and shouting about this. (and i\u0027m not even certain that everyone understands and has agreed to these constraints today.)\n\nif all these necessary constraints actually exist, why do we even have multiple modules?",
      "parentUuid": "79a316ff_90b8aa60",
      "range": {
        "startLine": 31,
        "startChar": 4,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "094f62ecc53efb39927d141c0594dd5f3e2536ea",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}