{
  "comments": [
    {
      "key": {
        "uuid": "f935c6bb_5808296b",
        "filename": "base/Android.mk",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "Instead of using these *_windows_* variables, I could instead just put the contents of the file under #ifdef _WIN32. I\u0027m open to ideas.",
      "range": {
        "startLine": 26,
        "startChar": 8,
        "endLine": 26,
        "endChar": 15
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16d269e7_75ed42ba",
        "filename": "base/file.cpp",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2015-10-22T23:08:23Z",
      "side": 1,
      "message": "So on Windows these functions will always do the conversion, right? What I\u0027ve read seems to indicate that the conversions are fairly expensive, do you think it\u0027s important to make this optional or add a check to these two functions to see if the conversion is necessary first? (Or maybe it\u0027s always necessary on Windows?)\n\nMy instinct is that it\u0027s probably fine as-is, I don\u0027t think anyone is going to be opening or deleting files in a tight enough loop to make performance matter, just wanted to mention it since I am pretty clueless about what else uses these functions besides adb.",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 41,
        "endChar": 17
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "968019c6_1c22dd43",
        "filename": "base/file.cpp",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-23T00:19:34Z",
      "side": 1,
      "message": "Yes, on Windows, these functions will always do the conversion. Have you seen this web site http://utf8everywhere.org/ ? It is a must-read for info on Unicode on Windows.\n\nIn particular, this suggests that the conversions are fairly cheap: http://utf8everywhere.org/#faq.cvt.perf . I\u0027ve never come across anything suggesting that these conversions can become a perf problem, do you have a reference? I think the biggest factors are that the input strings are small and that the conversion is a relatively simple transformation.\n\nSo I don\u0027t think perf would be a reason to make this optional. I don\u0027t think it would be better to make the code do `if (IsASCII(input)) { open(input); } else { _wopen(UTF8ToWide(input).c_str()); }\u0027 -- I think that would add a lot of complexity (and code-paths) for minimal gain.\n\nThe bigger question is what happens if someone passes a non-UTF8 ANSI code-page string to these APIs that expect UTF8. It might not work right, but I don\u0027t think there\u0027s any callers doing this and the fix would be to pass UTF8. (I don\u0027t have a full AOSP tree, so I don\u0027t think I can check this 100%.)\n\nTo elaborate further: on Windows, CreateFile() is a macro that expands to either CreateFileA(const char* ansi_string) or CreateFileW(const wchar_t* unicode_string). So on Windows, there are 3 choices:\n\n1. Only use Unicode and wchar_t everywhere. Only have foo(const wchar_t*). Real Windows-only code-bases actually do this.\n2. Have fooA(const char*) and fooW(const char*). Implement fooA() by calling MultiByteToWideChar() and passing the result to fooW(). Callers that use fooA() won\u0027t work with some strings because they can\u0027t be represented.\n3. Do the UTF-8 everywhere strategy like on the website and what we have in adb and in this change. It really seems like the only practical solution for cross-platform code.",
      "parentUuid": "16d269e7_75ed42ba",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 41,
        "endChar": 17
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3942fe30_9fa0c3cd",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "These WideToUTF8 and UTF8ToWide functions are based on the widen()/narrow() functions from sysdeps_win32.cpp with some changes, elaborated below.",
      "range": {
        "startLine": 28,
        "startChar": 5,
        "endLine": 28,
        "endChar": 15
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19337ad8_d90b3faa",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 31,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "The unittest found that the old code wasn\u0027t handling this case.",
      "range": {
        "startLine": 31,
        "startChar": 2,
        "endLine": 31,
        "endChar": 18
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "194a9a42_ac2b9fb8",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "The unittest found that the old code wasn\u0027t returning an error in some invalid char situations. This improves that.",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 24
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d953a2fb_d9f427f6",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "The old code was just calling fatal() here, but I didn\u0027t think that was appropriate for a general library like libbase. A bool is probably better and that\u0027s what Chromium\u0027s similar APIs return (though Chromium also has APIs that ignore errors).",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 17
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "194a9a42_2cd16f56",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2015-10-22T18:28:07Z",
      "side": 1,
      "message": "If I\u0027m reading it right, according to http://en.cppreference.com/w/cpp/string/basic_string this is guaranteed as of C++11.",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 58,
        "endChar": 64
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3675adb9_969c8add",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T22:00:00Z",
      "side": 1,
      "message": "Yeah, I think this comment doesn\u0027t add anything, so I\u0027ll kill it.",
      "parentUuid": "194a9a42_2cd16f56",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 58,
        "endChar": 64
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b9618ebd_91ec4c7b",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2015-10-22T18:28:07Z",
      "side": 1,
      "message": "As I understand it this should never happen since WideCharToMultiByte() will return the same value on both calls, but if we\u0027re going to check this case anyway, perhaps this should be a fatal() if result \u003e chars_required since that would indicate that we probably just corrupted some memory with a buffer overflow.",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 65,
        "endChar": 3
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "166d09ed_1da977fd",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T22:00:00Z",
      "side": 1,
      "message": "My thinking is that in reality the return value doesn\u0027t even need to be checked (since flags are already checked, invalid chars are already checked, size is already checked, etc.), but check it anyway for defensive programming (for anything unexpected). I\u0027m By Design not doing CHECK/LOG(FATAL) here since it seems like that should be up to the caller instead of a base library. After all, who knows where they\u0027re getting their strings.",
      "parentUuid": "b9618ebd_91ec4c7b",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 65,
        "endChar": 3
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16d269e7_f554d237",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1078119
      },
      "writtenOn": "2015-10-22T23:08:23Z",
      "side": 1,
      "message": "In general I agree returning an error is much better than dying. But the caller here has no way to know that this specific event occurred. There\u0027s a world of difference between \"the conversion failed\" and \"the conversion failed and we may have corrupted some of your program\u0027s memory\".\n\nIf result \u003e chars_required the program will hopefully have segfaulted already anyway, so exiting from the library is already a possibility. Adding a fatal() just makes it certain, to reduce randomness and prevent some poor programmer having to try to debug this if somehow it does come up.\n\nAs you say, this will almost certainly never happen, so if nobody else cares I\u0027m fine leaving this as-is, but IMO as long as we\u0027re defensive programming we might as well go all the way :)",
      "parentUuid": "166d09ed_1da977fd",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 65,
        "endChar": 3
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "369ccd29_c4057453",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-23T00:19:34Z",
      "side": 1,
      "message": "Ok, I see what you\u0027re saying, so I added a CHECK_LE(), not just for overall defensive coding, but also since these APIs are kind of peculiar in the first place (i.e. the cb/cch args are so weird, what if I screwed them up? Or what if I pass one size and check against a different size?)\n\nFriendly joke: Now that I understand your thinking, I fully expect you to 1) find all calls to open() and make sure they check for fds \u003c -1, 2) find all calls to read() and add a CHECK_LE() in case it overran the buffer. ;-) ;-) ;-)",
      "parentUuid": "16d269e7_f554d237",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 65,
        "endChar": 3
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59725292_8860a70e",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "The old code was passing -1 to WideCharToMultiByte(), but that just made the code more complicated.",
      "range": {
        "startLine": 71,
        "startChar": 5,
        "endLine": 71,
        "endChar": 67
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d953a2fb_f9f9ebec",
        "filename": "base/u8.cpp",
        "patchSetId": 2
      },
      "lineNbr": 90,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "The old code passed 0 here, but the unittest found that this flag is better to identify errors.",
      "range": {
        "startLine": 90,
        "startChar": 58,
        "endLine": 90,
        "endChar": 78
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "194a9a42_ec25a7e2",
        "filename": "base/u8_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 148,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "This is a change I made to the Chromium unittest.",
      "range": {
        "startLine": 146,
        "startChar": 4,
        "endLine": 148,
        "endChar": 51
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b9618ebd_c67a8cea",
        "filename": "base/u8_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 187,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "This is another change I made to the original Chromium unittest.",
      "range": {
        "startLine": 187,
        "startChar": 0,
        "endLine": 187,
        "endChar": 22
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3942fe30_dfaa4bab",
        "filename": "base/u8_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 214,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-22T08:45:47Z",
      "side": 1,
      "message": "This is another change I made to the original Chromium unittest.",
      "range": {
        "startLine": 212,
        "startChar": 4,
        "endLine": 214,
        "endChar": 51
      },
      "revId": "9a8bfbf4b4e0479ff5ecff0787ddc978fe5c3312",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}