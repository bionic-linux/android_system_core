{
  "comments": [
    {
      "key": {
        "uuid": "19935a02_232042cf",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 8
      },
      "lineNbr": 104,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-07-02T18:57:29Z",
      "side": 1,
      "message": "I see what you\u0027re doing here, but this still seems too complex to me.  Instead of having logic to determine if a directory has files in it or if it is writable, etc, could we do something like the following:\n\nDuring overlayfs setup, take a parameter from the user (defaults to /data, since you\u0027ve mentioned frameworks team is the most common requester and that want /data) for which mount point to use (/cache, or /data).  Throw an error if there is a non-empty mount point in the other locations, otherwise remove the empty upper and work dirs from the other mount point options.\n\nThen during the mount, iterate through the mount points and use the first mount point that has a upper and work directory.\n\nAs an aside, what happens if the mount point is filled or not writable (permissions)?  \n\nIn the former case do we get out of space errors when writing?  That would be the correct behavior to me.\n\nIn the latter case, does the mount() fail due to permissions or do subsequent writes fail due to permissions?  Either seem to be acceptable to me.",
      "revId": "55334337dbf6df5136a3c78b830e6fc0a0900d81",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c4ed762_d46fd023",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 8
      },
      "lineNbr": 104,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-07-02T20:11:34Z",
      "side": 1,
      "message": "overlayfs driver does not do what you think. If it can not create the directory (out of space) inside workdir it actually hard-codes the overlayfs stack to be read-only, so you do _not_ get out of space errors. I think it refuses to remount rw. It would behave the same if you did not specify the workdir.\n\nWe introduce ro.adbd.remount.overlayfs in a later CL. Currently it operates nearly as a bool to true/false/default. But we could make it instead take an overlay tree (eg: /mnt/scratch/overlay) and use that as the specification of which one to use. I would suggest that we change it to the following value-set:\n\ntrue -\u003e automatic directory selection\nfalse -\u003e disable feature\n/data/overlay -\u003e use /data/overlay directory only.\n\u003cempty\u003e - automatic directory selection, automatic reasoning (check if filesystem is squashfs and enable).\n\nThe issue with this is during init earlymount, there are _no_ properties. However, during setup it will work and create the associated directory trees., but if it is presented with a non-standard directory, it will _not_ be searched for at init earlymount time; we would need to provide _all_ possible choices into the overlay_mount_point array for it to work unimpeded.\n\nSimilar to the current problem with mount_all and partners specifying a non-standard fstab location...",
      "parentUuid": "19935a02_232042cf",
      "revId": "55334337dbf6df5136a3c78b830e6fc0a0900d81",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "11379dd5_74a64eb1",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 8
      },
      "lineNbr": 104,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-07-02T20:31:09Z",
      "side": 1,
      "message": "\u003e so you do _not_ get out of space errors\n\nBut you still get an error then, right?  A \"Read only file system\" error?\n\n\u003e I think it refuses to remount rw\n\nRefuses to mount during mount() that is?\n\nEarly mount of overlayfs is tangent from this since it requires the existence of a /scratch, which we\u0027re not handling here, right?",
      "parentUuid": "9c4ed762_d46fd023",
      "revId": "55334337dbf6df5136a3c78b830e6fc0a0900d81",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}