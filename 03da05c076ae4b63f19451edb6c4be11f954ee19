{
  "comments": [
    {
      "key": {
        "uuid": "dd44f361_19e7a18d",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T22:45:53Z",
      "side": 1,
      "message": "Do we know the minimum kernel version required for /sys/module or /sys/fs to report this information?  Assuming this will be there for all kernel versions over some point, it may be worth it to annotate it such that we can remove it in the future or at least be clear to readers why we check so many locations.",
      "revId": "03da05c076ae4b63f19451edb6c4be11f954ee19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fd75bb70_4ee0e478",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-04T23:25:15Z",
      "side": 1,
      "message": "/sys/module/ will depend on the filesystem implementation details, if it imports/exports any params. So this works for 4.9 and higher. Breaks for 3.18 and some 4.4 implementations. tiamen and marlin gave me problems for the overlayfs and for f2fs.\n\n/sys/fs/ similar issue with implementations details. Can give a false negative (device uses ext4 for userdata, then f2fs will not succeed). taimen and marlin gives us the scenario of a false negative for f2fs that needed fortification. When I added f2fs taimen picked up, marlin did not. taimen and marlin failed for overlay too.\n\n/proc/filesystems works on _all_ releases, but it is more costly to read, needs a parse which is greatly simplified here, and if it is \u003e1024 bytes (which is not the current state of affairs, so may be a red herring), ReadFileToString _could_ suffer from atomicity/races with updates (eg partners loading modules) to /proc/filesystems. I do not want to use it if the other two provide their immediate positive results. taimen and marlin picked up here for overlay and here we proved marlin (and taimen) did not have f2fs.",
      "parentUuid": "dd44f361_19e7a18d",
      "revId": "03da05c076ae4b63f19451edb6c4be11f954ee19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6befa39c_1592dad4",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-04T23:40:12Z",
      "side": 1,
      "message": "Added one-line summaries",
      "parentUuid": "fd75bb70_4ee0e478",
      "revId": "03da05c076ae4b63f19451edb6c4be11f954ee19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e122e010_9e9c9d47",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-05T02:56:43Z",
      "side": 1,
      "message": "How costly is it to read and how often are we reading it?  It looks like one of the places where we\u0027re reading it is when setting up scratch for the first time, which seems like a slow enough operation that we won\u0027t be impacted by a marginally slower read.  We pay the cost of maintenance for parsing already by having it as a fallback and it doesn\u0027t look like the parsing itself will be an intense operation.\n\nI don\u0027t understand the atomicity / race / file size limitation.  Are you saying that /proc/filesystems will be corrupted if multiple read calls happen to it?  Or just that we may miss some file systems if a kernel module is being loaded at the same time that we call it?  Neither of those seem likely to me; and if there is a fundamental race, we need to handle it by making sure that file systems kernel modules (if any... do we really expect anyone is going to do this?) are loaded before any of this code runs.\n\nAll to say, that it sounds like a good idea to drop the first two that rely on implementation details and go straight to the node that is specifically meant to tell us which filesystems are available on the device.",
      "parentUuid": "6befa39c_1592dad4",
      "revId": "03da05c076ae4b63f19451edb6c4be11f954ee19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aa2d6217_154c5e7a",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-05T18:04:46Z",
      "side": 1,
      "message": "I can accept dropping the other tests and focus on /proc/filesystems. It will take some time to confirm.\n\n[TL;DR]\n\nWill need to retest with custom builds for every product all over again which took (lazy, advantageous and background) days because I do not have enough space on my machine to maintain all the builds at the same time and wiped betwixt. I used a fresh ToT and switched devices as I worked other issues and rotated through the tests. This code is run during first_stage_init, needs a custom kernel for taimen and marlin, in the adb remount handing code, and adb sync / adb push does not guarantee (FUD) an incremental ability to test this, and certainly does not in the negative case. I can probably do this _smart_ and speed up the testing if I focus on replacing all the affected components.\n\nReadFileToString pulls 1K at a time when it does not know the size of the node, /proc/filesystems does not report its size and thus activates this scenario. This has resulted in data corruption when reading dynamic content throughout the /proc filesystem in multiple locations and we have tried to move code away from using it. If I could find another way I\u0027d stay clear of /proc.\n\n(the maintainers have threatened to deprecate /proc for two decades now ;-/ so it is a losing battle).\n\nYes, not likely w.r.t. /proc/filesystems on Pixel \u003cperiod\u003e IMHO. All we need is for vendor to do something funny, or suffer from the asynchronous instantiation of filesystem modules. Still not likely because the numbers of filesystem modules on most sane installations is \u003c\u003c\u003c\u003c1024 bytes in /proc/filesystems.\n\nIdeally I\u0027d fix ReadFileToStrings to re-read the content from the beginning for nodes in /proc (or any memory filesystems) if it decided to resize and pull more; and to re-read it twice and compare if \u003e4096 bytes to prevent a corrupted read from any reshaping that occurs from page to page.",
      "parentUuid": "e122e010_9e9c9d47",
      "revId": "03da05c076ae4b63f19451edb6c4be11f954ee19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20047729_4f2c8e20",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-05T19:21:28Z",
      "side": 1,
      "message": "That all seems like manageable risk to me.  Worst case, we do reimplement ReadFileToString() to handle a changing snapshot, but I highly doubt we\u0027re going to hit that situation anyway ( \u003e1K size of /proc/filesystems + asynchronously loaded filesystem modules).  Seems like the most maintainable way forward, rather than worrying about the /sys/module and /sys/fs implementation details.",
      "parentUuid": "aa2d6217_154c5e7a",
      "revId": "03da05c076ae4b63f19451edb6c4be11f954ee19",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}