{
  "comments": [
    {
      "key": {
        "uuid": "068cdc85_563af298",
        "filename": "logd/main.cpp",
        "patchSetId": 3
      },
      "lineNbr": 227,
      "author": {
        "id": 1015340
      },
      "writtenOn": "2015-03-20T21:11:51Z",
      "side": 1,
      "message": "You need to use atomics here.  First to ensure the assignment to uid doesn\u0027t race, and second to make sure the reads and writes actually happen (since uid and name aren\u0027t volatile, the compiler could decide to cache the reads, or that the writes have no side effects and can be skipped).",
      "range": {
        "startLine": 219,
        "startChar": 0,
        "endLine": 227,
        "endChar": 16
      },
      "revId": "0afa55e7296199da87ee403379bfcb29765abc46",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "66259842_b529f3b6",
        "filename": "logd/main.cpp",
        "patchSetId": 3
      },
      "lineNbr": 227,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2015-03-20T21:22:26Z",
      "side": 1,
      "message": "Need is a strong word.\n\nsem_post/sem_wait is a set of atomics and futex system calls and has the necessary flush actions and compiler hints. I understand that the atomics will give a developer or future-selves maintaining this code a feeling of comfort.",
      "parentUuid": "068cdc85_563af298",
      "range": {
        "startLine": 219,
        "startChar": 0,
        "endLine": 227,
        "endChar": 16
      },
      "revId": "0afa55e7296199da87ee403379bfcb29765abc46",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "068cdc85_b756b8e5",
        "filename": "logd/main.cpp",
        "patchSetId": 3
      },
      "lineNbr": 227,
      "author": {
        "id": 1015340
      },
      "writtenOn": "2015-03-20T22:36:06Z",
      "side": 1,
      "message": "I stand corrected about sem_{post,wait}.  I checked POSIX and they guarantee memory synchronization.\n\nBut I still think uid needs to be atomic or protected by a lock.  Otherwise you could have a situation where two threads enter the function while uid \u003d\u003d 0, both read uid and decide it\u0027s safe to continue, and then race to write to uid.\n\n(Unless you know only one thread will enter this function at a time, in which case the if (uid) branch is unnecessary anyway.)",
      "parentUuid": "66259842_b529f3b6",
      "range": {
        "startLine": 219,
        "startChar": 0,
        "endLine": 227,
        "endChar": 16
      },
      "revId": "0afa55e7296199da87ee403379bfcb29765abc46",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "46825452_c68f14f9",
        "filename": "logd/main.cpp",
        "patchSetId": 3
      },
      "lineNbr": 227,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2015-03-20T22:54:48Z",
      "side": 1,
      "message": "Only one thread is calling this. I put the comment \u0027Poorman trylock\u0027 so that a future self will realize this is not multi-thread safe and fix it if this function becomes useful.\n\nI should have put the comment \"not multi-thread safe, assume only _one_ thread is calling this function\" ...",
      "parentUuid": "068cdc85_b756b8e5",
      "range": {
        "startLine": 219,
        "startChar": 0,
        "endLine": 227,
        "endChar": 16
      },
      "revId": "0afa55e7296199da87ee403379bfcb29765abc46",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}