{
  "comments": [
    {
      "key": {
        "uuid": "7254a4e4_a9538058",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T02:15:16Z",
      "side": 1,
      "message": "by who?",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_8ca16aaa",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-05-17T05:33:08Z",
      "side": 1,
      "message": "By compare_exchange_weak.  That\u0027s just a reminder about a standard C++ library API.",
      "parentUuid": "7254a4e4_a9538058",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_ccc29246",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T06:07:11Z",
      "side": 1,
      "message": "I don\u0027t know where that code is defined, in the the versions I saw (I did not find the exact version you are using) the current count is passed by value, not by reference, so the local copy could not have been updated.",
      "parentUuid": "7254a4e4_8ca16aaa",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "323eac9c_677b6c7b",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2016-05-17T15:42:14Z",
      "side": 1,
      "message": "The standard C++11 version always takes a reference for the first argument, and the behavior is specified...",
      "parentUuid": "7254a4e4_ccc29246",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_0c4f3a5e",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-05-17T15:42:32Z",
      "side": 1,
      "message": "It\u0027s the C++ standard library compare_exchange_weak.  curCount is passed by reference, for better or worse.  See http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange, for example.  I can add a comment, but I think we usually don\u0027t for the standard library.",
      "parentUuid": "7254a4e4_ccc29246",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_8956bc48",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T02:15:16Z",
      "side": 1,
      "message": "Are you sure this should have relaxed memory ordering? In incStrong the caller knows it already has a strong ref, while here it does not.",
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_ac9e2e60",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-05-17T05:33:08Z",
      "side": 1,
      "message": "You\u0027re commenting on the compare_exchange?  All that matters by the reasoning in the comment at the top is that if this succeeds it happens before a corresponding decrement, and hence all memory effects are visible by the time it matters, i.e. when a zero count is detected. I\u0027m assuming that we never act on a nonzero count; the calls to retrieve counts are only for debugging.",
      "parentUuid": "7254a4e4_8956bc48",
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_0cdf3a1c",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T06:07:11Z",
      "side": 1,
      "message": "I\u0027m referring to the entire function. It is possible there is no problem, but the clients of this code are different from the clients of incStrong. A call to either function is similar to a mutex_lock call in that the client expects the object to be valid after the call returns. If there is no transition from invalid to valid then this is probably ok, but the code below to handle the initial state seems to indicate that this is not always the case.",
      "parentUuid": "7254a4e4_ac9e2e60",
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_8c6a4aa4",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-05-17T15:42:32Z",
      "side": 1,
      "message": "Careful scrutiny here is certainly good, but I think it\u0027s OK as is. We were presumably passed the weak pointer using proper synchronization, so object construction happens before us.  If this function succeeds, then the object can\u0027t be deallocated until we, or a thread we pass the reference to, calls decStrong. So, by the arguments above, anything here happens before destruction.\n\nI don\u0027t fully understand the usage model. If someone is using this for  synchronization, i.e. assuming that because this succeeded they will see certain prior memory effects, then we have a problem.  I\u0027ll add a comment saying that this is not guaranteed. But it never was. We\u0027d just be preserving the brokenness, though possibly increasing failure frequency.",
      "parentUuid": "7254a4e4_0cdf3a1c",
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}