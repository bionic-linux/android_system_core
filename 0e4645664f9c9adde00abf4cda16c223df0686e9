{
  "comments": [
    {
      "key": {
        "uuid": "7254a4e4_a9538058",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T02:15:16Z",
      "side": 1,
      "message": "by who?",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_8ca16aaa",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-05-17T05:33:08Z",
      "side": 1,
      "message": "By compare_exchange_weak.  That\u0027s just a reminder about a standard C++ library API.",
      "parentUuid": "7254a4e4_a9538058",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_ccc29246",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 534,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T06:07:11Z",
      "side": 1,
      "message": "I don\u0027t know where that code is defined, in the the versions I saw (I did not find the exact version you are using) the current count is passed by value, not by reference, so the local copy could not have been updated.",
      "parentUuid": "7254a4e4_8ca16aaa",
      "range": {
        "startLine": 534,
        "startChar": 31,
        "endLine": 534,
        "endChar": 43
      },
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_8956bc48",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T02:15:16Z",
      "side": 1,
      "message": "Are you sure this should have relaxed memory ordering? In incStrong the caller knows it already has a strong ref, while here it does not.",
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_ac9e2e60",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-05-17T05:33:08Z",
      "side": 1,
      "message": "You\u0027re commenting on the compare_exchange?  All that matters by the reasoning in the comment at the top is that if this succeeds it happens before a corresponding decrement, and hence all memory effects are visible by the time it matters, i.e. when a zero count is detected. I\u0027m assuming that we never act on a nonzero count; the calls to retrieve counts are only for debugging.",
      "parentUuid": "7254a4e4_8956bc48",
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7254a4e4_0cdf3a1c",
        "filename": "libutils/RefBase.cpp",
        "patchSetId": 6
      },
      "lineNbr": 535,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-05-17T06:07:11Z",
      "side": 1,
      "message": "I\u0027m referring to the entire function. It is possible there is no problem, but the clients of this code are different from the clients of incStrong. A call to either function is similar to a mutex_lock call in that the client expects the object to be valid after the call returns. If there is no transition from invalid to valid then this is probably ok, but the code below to handle the initial state seems to indicate that this is not always the case.",
      "parentUuid": "7254a4e4_ac9e2e60",
      "revId": "0e4645664f9c9adde00abf4cda16c223df0686e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}