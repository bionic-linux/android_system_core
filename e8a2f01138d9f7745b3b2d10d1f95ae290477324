{
  "comments": [
    {
      "key": {
        "uuid": "TvWs11bA",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2013-04-22T18:04:21Z",
      "side": 1,
      "message": "is there a uevent that triggers this or are you just checking this en every uevent you receive?",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "TwoN-wG8",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2013-04-22T18:57:13Z",
      "side": 1,
      "message": "selinux_status_updated() simply checks a sequence number in a read-only shared page mapped from the kernel by the  selinux_status_open() call to see if it has changed since the last call to selinux_status_updated().  So it is checking on every uevent but the check requires no system calls in the common case.  Implementation of selinux_status_updated() can be found in the corresponding change uploaded for external/libselinux with the same change-id since it is a dependency.\nselinux_status_open()/selinux_status_updated() will fall back to checking a NETLINK_SELINUX socket on older kernels that do not support /sys/fs/selinux/status, but that would only be true for Linux \u003c 2.6.37.",
      "parentUuid": "TvWs11bA",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "T9oylB0s",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2013-04-24T07:54:11Z",
      "side": 1,
      "message": "The question, though, is if you are guaranteed that a uevent is generated at the point when the reload is necessary, or will it be delayed until the next uevent?",
      "parentUuid": "TwoN-wG8",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UA1-JS6A",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2013-04-24T13:12:27Z",
      "side": 1,
      "message": "ueventd doesn\u0027t need to process the reload immediately; it only needs to ensure that it reloads its configuration before it next looks up an entry in it (i.e. selabel_lookup) to label a device node.  There is no uevent generated by the reload, so the handling is delayed until the next uevent, but this should be harmless.  The alternative approach would be to add a descriptor to a NETLINK_SELINUX socket, which does get a notification upon reload, to the poll()\u0027d set in ueventd and handle it there.",
      "parentUuid": "T9oylB0s",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UKTlzLx8",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1000413
      },
      "writtenOn": "2013-04-27T21:26:59Z",
      "side": 1,
      "message": "Hmm, this doesn\u0027t seem like enough actually. What happens when the policy modifies an existing node. With this code, you wouldn\u0027t update it until it got re-created, right?",
      "parentUuid": "UA1-JS6A",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UOelatQM",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2013-04-27T21:30:42Z",
      "side": 1,
      "message": "The policy determines the contexts for created nodes from this point forward. Handling nodes already assigned a context is a separate issue.",
      "parentUuid": "UKTlzLx8",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UM69m.ZU",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1010111
      },
      "writtenOn": "2013-04-30T12:49:17Z",
      "side": 1,
      "message": "That is true, but was also true of the prior code; restarting ueventd did not cause existing nodes to be relabeled either.  Unclear as to whether we want that behavior automatically or if it should only be done via explicit restorecon by whatever dropped the updated policy or upon on the next boot.",
      "parentUuid": "UKTlzLx8",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "UOSwlOxc",
        "filename": "init/devices.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1013433
      },
      "writtenOn": "2013-04-30T15:54:19Z",
      "side": 1,
      "message": "Yes, exactly. \n\nTheir are usually two types of policy reloads, those affecting early boot and those after. Dynamic reloads can affect the late boot process, after data is mounted. An example of where this is handy is the following:\n1. You are well past boot and a driver gets insmod\u0027d\n2. You need to update that label\n\nNow you can rmmod, reload policy, insmod and it works as expected.",
      "parentUuid": "UM69m.ZU",
      "revId": "e8a2f01138d9f7745b3b2d10d1f95ae290477324",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}