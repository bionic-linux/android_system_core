{
  "comments": [
    {
      "key": {
        "uuid": "34d97ed7_df9c8314",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 150,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2019-01-07T19:26:32Z",
      "side": 1,
      "message": "This looks brittle to me, honestly. Wouldn\u0027t it be more stable to create a namespace for the first service that needs it, ensure that it\u0027s kept alive, and then simply join it every time?\n\n(In general, I think these corner cases are a result of not having two namespaces for pre- and post-state, which would more cleanly separate things.)",
      "range": {
        "startLine": 143,
        "startChar": 0,
        "endLine": 150,
        "endChar": 78
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10bb45a0_25818a05",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 150,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-08T02:12:32Z",
      "side": 1,
      "message": "That\u0027s an interesting idea, and I think it\u0027s better in terms of memory usage. But I wonder if it can be implemented. (maybe I am missing something, if so please enlighten me). \n\nIt looks like you are suggesting to use setns to join the \u0027pre-apexd\u0027 mount namespace. But how can we save the mount namespace? The first pre-apexd process might have been finished (or killed), in which case we need to use the second pre-apexd process and so on. If there is a pre-apexd process that is gauranteed to be alive forever (i.e. ueventd?), then we can use /proc/`pidof ueventd`/ns/mnt, but to me this seems to be more brittle than what I am doing here.\n\n\u003e brittle\n\nI don\u0027t understand this part. Could you explain how this could break?",
      "parentUuid": "34d97ed7_df9c8314",
      "range": {
        "startLine": 143,
        "startChar": 0,
        "endLine": 150,
        "endChar": 78
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef465926_f016918e",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 150,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2019-01-08T16:37:22Z",
      "side": 1,
      "message": "See the docs. If you keep either a bind mount or fd open to the corresponding /proc entry, it is kept alive, and you need an fd for setns anyways :-) (the only problem with keeping fd alive is that you need to close it in the child to not run into issues in the zygote etc).\n\nBrittle: easy to break, harder to maintain than necessary. Re-doing the setup means any of the calls below can fail. E.g., you assume you can unmount the linker etc below. Is there a race here? What does the kernel say when someone else is just in the same moment opening those? (Personally no clue, but any number of calls that can fail is worse than a single setup call...) Then comes the question of updating the list. What if you forget to update this code? And similarly, you have to re-run the pre-apexd-mount stage afterwards. That\u0027s a lot of redone work that could go wrong.\n\nIn general, it was just an observation. setns might turn out looking complicated, too. So I\u0027m fine merging this as-is, and we can decide to iterate on it if necessary.",
      "parentUuid": "10bb45a0_25818a05",
      "range": {
        "startLine": 143,
        "startChar": 0,
        "endLine": 150,
        "endChar": 78
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ea913d2_1679833d",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 150,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-11T16:58:57Z",
      "side": 1,
      "message": "I don\u0027t still understand how init can save the fd of its first pre-apexd children. Yeah, let\u0027s talk later. Filed b/122717176",
      "parentUuid": "ef465926_f016918e",
      "range": {
        "startLine": 143,
        "startChar": 0,
        "endLine": 150,
        "endChar": 78
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ad75310_b50d3549",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 996,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2019-01-07T10:47:40Z",
      "side": 1,
      "message": "this seems a bit weird - if the propagation type is set to private, why would they propagate?\n\nI guess it is because bind-mounting /system/lib/libc.so is a mount event on \u0027/\u0027, so even if the mount /system/lib/libc.so itself is private, it will still be propagated because / is \u0027shared\u0027?",
      "range": {
        "startLine": 996,
        "startChar": 21,
        "endLine": 996,
        "endChar": 55
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38a9a58b_772bbf7b",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 996,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-07T11:51:48Z",
      "side": 1,
      "message": "If we are not doing unshare, init and these pre-apexd processes are using the same mount namespace. So, regardless of the propagation type, everything that happen in the mount namespace are visible to all processes.",
      "parentUuid": "6ad75310_b50d3549",
      "range": {
        "startLine": 996,
        "startChar": 21,
        "endLine": 996,
        "endChar": 55
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f0383fe6_4fb21b16",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 996,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2019-01-07T12:39:54Z",
      "side": 1,
      "message": "Right, I\u0027m not saying it\u0027s wrong to unshare, but \u0027This unsharing is required to not propagate...whose propagation type is set to private\u0027 sounded a bit like a contradiction at first :)\n\nBTW just to confirm: the first time I mount something on /system/bin/linker64, it will be propagated based on the propagation settings of \u0027/\u0027; but if I then modify or unmount /system/bin/linker64, it will be propagated based on the propagation setting of \u0027/system/bin/linker64\u0027 itself, right?",
      "parentUuid": "38a9a58b_772bbf7b",
      "range": {
        "startLine": 996,
        "startChar": 21,
        "endLine": 996,
        "endChar": 55
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6c82460c_6062c45e",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 996,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-07T13:08:48Z",
      "side": 1,
      "message": "\u003e BTW just to confirm ...\n\nYes right. You can double-confirm this in your host machine.\n\n----------\n$ echo bootstrap \u003e bootstrap\n$ echo updated \u003e updated\n$ sudo mount --bind bootstrap bootstrap\n$ echo bootstrap\nbootstrap\n$ cat /proc/self/mountinfo \n547 112 254:2 /home/jiyong/temp/bootstrap /usr/local/google/home/jiyong/temp/bootstrap rw,relatime shared:61 - ext4 \n\n// fork a new shell with separate mount namespace\n$ PS1\u003d\u0027pre_apexd# \u0027 sudo unshare -m --propagation unchanged sh\npre_apexd# cat bootstrap\nbootstrap\npre_apexd# cat /proc/self/mountinfo\n658 654 254:2 /home/jiyong/temp/bootstrap /usr/local/google/home/jiyong/temp/bootstrap rw,relatime shared:61 - ext4 \n// note that mountpoint ID has changed. This is a copy of the mountpoint 547.\n\n// open a new terminal (sharing the same mount namespace with the initial shell)\n$ cat /proc/self/mountinfo\n547 112 254:2 /home/jiyong/temp/bootstrap /usr/local/google/home/jiyong/temp/bootstrap rw,relatime shared:61 - ext4 \n// make the existing mount point private and bind-mount the new file\n$ sudo mount --make-private bootstrap\n$ sudo mount --bind updated bootstrap\n$ cat bootstrap\nupdated\n$ cat /proc/self/mountinfo\n547 112 254:2 /home/jiyong/temp/bootstrap /usr/local/google/home/jiyong/temp/bootstrap rw,relatime - ext4 \n667 547 254:2 /home/jiyong/temp/updated /usr/local/google/home/jiyong/temp/bootstrap rw,relatime shared:61 - ext4 \n// note that shared:xxx is not shown for the mountpoint 547\n// the new mount point 667 has 547 whose propagation type is private as its parent. So mounting of 667 is not propagated to any other mount namespace.\n\n// switch to the shell launched with unshare\npre_apexd# cat bootstrap\nbootstrap\npre_apexd# cat /proc/self/mountinfo\n658 654 254:2 /home/jiyong/temp/bootstrap /usr/local/google/home/jiyong/temp/bootstrap rw,relatime shared:61 - ext4",
      "parentUuid": "f0383fe6_4fb21b16",
      "range": {
        "startLine": 996,
        "startChar": 21,
        "endLine": 996,
        "endChar": 55
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "72006e16_975d50a3",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 996,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2019-01-07T13:18:21Z",
      "side": 1,
      "message": "Ok makes sense, thanks!",
      "parentUuid": "6c82460c_6062c45e",
      "range": {
        "startLine": 996,
        "startChar": 21,
        "endLine": 996,
        "endChar": 55
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c14ad8d8_3f473305",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 998,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2019-01-07T10:47:40Z",
      "side": 1,
      "message": "mount",
      "range": {
        "startLine": 998,
        "startChar": 35,
        "endLine": 998,
        "endChar": 40
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db12bcae_9c5141b5",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 998,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-07T11:51:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c14ad8d8_3f473305",
      "range": {
        "startLine": 998,
        "startChar": 35,
        "endLine": 998,
        "endChar": 40
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4bc643bb_605e2498",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1006,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2019-01-07T10:47:40Z",
      "side": 1,
      "message": "does this still work correctly if \u0027pre_apex_\u0027 is true? Should we prevent this code from running in that case?",
      "range": {
        "startLine": 1006,
        "startChar": 9,
        "endLine": 1006,
        "endChar": 45
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34bba72c_ce2890f4",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1006,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-07T11:51:48Z",
      "side": 1,
      "message": "Yes this and pre_apex_ can coexist though we don\u0027t have such service yet. So, no need to prevent pre_apex_ here.",
      "parentUuid": "4bc643bb_605e2498",
      "range": {
        "startLine": 1006,
        "startChar": 9,
        "endLine": 1006,
        "endChar": 45
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e4cc9f5_70141677",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1394,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2019-01-07T10:47:40Z",
      "side": 1,
      "message": "I guess init is single-threaded so this is not racy?",
      "range": {
        "startLine": 1392,
        "startChar": 0,
        "endLine": 1394,
        "endChar": 1
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33dc9f67_bfa5ec0c",
        "filename": "init/service.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1394,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-07T11:51:48Z",
      "side": 1,
      "message": "Right. Everything is executed in the main loop.",
      "parentUuid": "0e4cc9f5_70141677",
      "range": {
        "startLine": 1392,
        "startChar": 0,
        "endLine": 1394,
        "endChar": 1
      },
      "revId": "8ccdd5ae2c6a1f03d5254b89b40bca184fee6ac9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}