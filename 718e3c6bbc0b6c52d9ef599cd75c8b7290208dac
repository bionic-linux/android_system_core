{
  "comments": [
    {
      "key": {
        "uuid": "c599aeb1_2b351148",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 1124848
      },
      "writtenOn": "2019-07-01T18:20:42Z",
      "side": 1,
      "message": "This is still racy. Consider the following events:\n1. lmkd decides based on heuristics to kill process P with pid X\n2. kill_one_process is called \n3. Before start_wait_for_proc_kill can be called, the process P dies for some other reason\n4. Due to pid wrap around, the next pid X is the PID of the process that just died\n5. fork() happens and the pid X is reused for the new process\n6. kill_one_process() now kills the wrong PID X. \n\nI think the possible fixes are:\n1. in kill_one_process, we must verify that the process is still the same after opening with pidfd_open. This can be done by comparing its name with what we expected. If a fork() reused the pid, then very likely its a different name. The race where there the name and the pid both got reused sounds extremely unlikely. However additional /proc/pid metadata can be borrowed to drive this probability down to zero.\n\n2. Open the pidfd for the process when creating the procp struct initially. This way the pid can never be reused.\n\n2. is simpler than 1. but needs to keep fds open.",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8521a2ba_48ee2801",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-07-01T19:37:54Z",
      "side": 1,
      "message": "This is a separate issue which I\u0027m not addressing in this CL. Here I only add support for pidfd polling to detect process death as specified in the description.\nThe race you mentioned exists in the current code as well and should be dealt with separately. It\u0027s quite an unlikely situation and has much lower priority IMO.",
      "parentUuid": "c599aeb1_2b351148",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33c10009_8adb86d6",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 1124848
      },
      "writtenOn": "2019-07-01T21:17:42Z",
      "side": 1,
      "message": "I don\u0027t think it is an \u0027unlikely\u0027 situation, Suren. We had discussions that with a large number of Android devices, even an unlikely situation can become likely.\n\nI am Ok with it if you want to handle this in a separate CL, but I will like you to at least put a TODO note there that the race exists. That is one of the reasons we want pidfd in lmkd and want to do pidfd-based ops is so that we can reserve the PID and prevent the reuse. I agree the race always existed, but pidfd work aims to fix that and IMO we should not downplay / ignore the race exists.\n\nI also don\u0027t see why it is not possible to address it in this CL itself, since the fix is simple. But I leave that to you if you want it in another CL. Thanks.",
      "parentUuid": "8521a2ba_48ee2801",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1725a5a0_b7845280",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 1440,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-07-01T22:30:51Z",
      "side": 1,
      "message": "I\u0027m not downplaying the issue but as I said this is a separate issue with a different priority than this. Instead of TODO item I filed b/136502698 to address this.\n\nThe reason I want to handle that in a separate CL is because there will be a non-zero impact on resource usage to store additional metadata and to compare it before the kills. For option #1 we will have to store names of the processes registered with lmkd, currently we only store pids. For option #2 we will have to do pidfd_open() for each registered process. The overhead for both is unknown at the moment, so I don\u0027t want to mix two changed in one CL as that would complicate impact evaluation. Both options can be implemented independently from this CL.",
      "parentUuid": "33c10009_8adb86d6",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "975ce9fa_4961c5d9",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 2115,
      "author": {
        "id": 1124848
      },
      "writtenOn": "2019-07-01T18:06:10Z",
      "side": 1,
      "message": "IMO we should avoid this dynamic check. AIUI, lmkd will be used only on devices that are 4.14 or newer. Old devices just use the in-kernel LMK. Can we enforce pidfd_open availability as a part of VTS testing for new devices? I feel this check complicates things, it is much better to just write the code so it works only with pidfd_open and enforce that devices are compatible.\n\nLet us talk about this more on this thread.",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb9eb24f_553ef4a6",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 2115,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-07-01T19:37:54Z",
      "side": 1,
      "message": "Your assumption is incorrect. All AndroidGo devices use userspace LMKD and can\u0027t be ignored. Most of them (if not all of them) are based on 4.9 or earlier kernels. In fact current AndroidGo reference device uses 4.9 kernel and userspace LMKD. So I do have to support this for backward compatibility.",
      "parentUuid": "975ce9fa_4961c5d9",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d70a4ef6_2553831a",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 2115,
      "author": {
        "id": 1124848
      },
      "writtenOn": "2019-07-01T21:17:42Z",
      "side": 1,
      "message": "Ah, ok. It wasn\u0027t really an \u0027assumption\u0027 :) It thought we already had email discussion about the kernel version and agreed only \u003e 4.9 kernels need backports. So does that mean you are backporting to \u003c\u003d v4.9 kernel now as well? I think Sandeep should be looped in since he was hesitant on needing backports to older kernels for this.",
      "parentUuid": "eb9eb24f_553ef4a6",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ee437f7a_685cec35",
        "filename": "lmkd/lmkd.c",
        "patchSetId": 2
      },
      "lineNbr": 2115,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-07-01T22:30:51Z",
      "side": 1,
      "message": "4.9 is the earliest version with the backport. All the older ones or the ones that do not have the backports will detect that the feature is missing in the kernel and will not use it. Without this detection I\u0027ll break all devices which are currently using lmkd and do not have pidfd backports. I would rather avoid that :)",
      "parentUuid": "d70a4ef6_2553831a",
      "revId": "718e3c6bbc0b6c52d9ef599cd75c8b7290208dac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}