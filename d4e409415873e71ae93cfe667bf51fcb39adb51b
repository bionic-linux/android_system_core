{
  "comments": [
    {
      "key": {
        "uuid": "c16380f0_69ba2596",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-12-16T17:56:59Z",
      "side": 1,
      "message": "logd",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 3
      },
      "revId": "d4e409415873e71ae93cfe667bf51fcb39adb51b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "815d0834_87fd46c7",
        "filename": "logd/LogTimes.h",
        "patchSetId": 2
      },
      "lineNbr": 72,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-12-16T17:56:59Z",
      "side": 1,
      "message": "Please no.\n\nTL;DR\n\nThis will result in a slow logger port (serial console log, or other slow path) increasing memory pressure on the system. triggerSkip is used to tell the reader threads in an emergency (using up to double requested storage) to dump a series of entries rather than forwarding them so that the memory can be freed. This allows a reader range lock to clear so that pruning can progress.\n\nWe can not allow this to be bypassed or we could get into a (minor) Memory DoS attack should a reader thread be blocked.\n\nArchitectural question: Could the problem be that the writer thread is not waking up to reader thread(s) to process the skip? IS there something blocking the reader thread(s) from waking up? Eventually when we get to double the storage, we kill the reader thread, but up to that point we will be doing a lot of ignored mechanics burning CPU cycles. This code was added because bumping the errant reader threads alone was undesirable if they were merely slow.\n\nNB: Android coding standard, use { }",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 72,
        "endChar": 29
      },
      "revId": "d4e409415873e71ae93cfe667bf51fcb39adb51b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e1d164e3_52413469",
        "filename": "logd/LogTimes.h",
        "patchSetId": 2
      },
      "lineNbr": 72,
      "author": {
        "id": 1061958
      },
      "writtenOn": "2014-12-16T19:50:02Z",
      "side": 1,
      "message": "Yes sure, but in a normal execution scenario we will also have an oldest (this includes the scenario in which we have\nonly one client), so a value from which we start to skip should be set (bufferSize could be an idea).\n\nAdditionally should be taken into account:\n- TimeEntry works on multiple buffers and pruning is done per buffer (skipAhead should be skipAhead[LOG_ID_MAX] set,updated and checked accordingly).\n- clean should call prune with the current number of messages in the buffer;\n\nPlease let me know your opinion on this. So I can push a new patch-set.",
      "parentUuid": "815d0834_87fd46c7",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 72,
        "endChar": 29
      },
      "revId": "d4e409415873e71ae93cfe667bf51fcb39adb51b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "41c2301f_3011064a",
        "filename": "logd/LogTimes.h",
        "patchSetId": 2
      },
      "lineNbr": 72,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-12-16T20:37:15Z",
      "side": 1,
      "message": "KISS and maintainability are the primary goals.\n\nWe start pruning/skipping at 10% over on a per-id basis, and we punt the reader if we are 100% over.\n\nSkip is meant to be a coarse tool to provide a soft means of dealing with a reticent reader client that is behind by \u003e100% of the buffer. The intent was to leave it to caller heuristics to decide by how much, or if to kill the reader\u0027s socket.\n\nLeave the ULONG_MAX alone as it is KISS and means EVERYTHING, refining it to number of messages only means you will be creating edge or race conditions. Dealing with the edge conditions ala #2 was a fine move.\n\nNo value with accurate accounting given that prune request value will be \u0027very large\u0027 or \u0027roughly 10%\u0027. By all means refine the guess, but if it takes more than a few ns to figure out, or is complicated to maintain, walk away.\n\nNB: I am thinking of deprecating white and blacklists; not KISS and so far no one has used it. Also statistics needs to be KISS\u0027d too.",
      "parentUuid": "e1d164e3_52413469",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 72,
        "endChar": 29
      },
      "revId": "d4e409415873e71ae93cfe667bf51fcb39adb51b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}