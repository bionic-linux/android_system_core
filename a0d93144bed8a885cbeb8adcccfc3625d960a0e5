{
  "comments": [
    {
      "key": {
        "uuid": "357a7e73_6aea5212",
        "filename": "fs_mgr/fs_mgr.cpp",
        "patchSetId": 2
      },
      "lineNbr": 750,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2017-04-07T06:15:46Z",
      "side": 1,
      "message": "Why?  Querying avb_handle should be sufficient.",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4ef95d1b_1127dea9",
        "filename": "fs_mgr/fs_mgr.cpp",
        "patchSetId": 2
      },
      "lineNbr": 750,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-11T01:04:39Z",
      "side": 1,
      "message": "Because fs_mgr_avb_open() at line 799 below will return nullptr when there is an error to load AVB metadata from /vbmeta.\n\nSee the a bunch of \"return nullptr\"s:\nhttps://android-review.googlesource.com/#/c/365440/2/fs_mgr/fs_mgr_avb.cpp@448\n\nBy querying avb_handle, we won\u0027t know whether a) it\u0027s NOT-INITIALIZED or b) Failed to load AVB metadata.\n\nAnyway, let me just return -1 here if fs_mgr_avb_open() returns nullptr. So it will be less confusing.",
      "parentUuid": "357a7e73_6aea5212",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f22d2f22_e9950bb4",
        "filename": "fs_mgr/fs_mgr.cpp",
        "patchSetId": 2
      },
      "lineNbr": 750,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2017-04-11T02:16:49Z",
      "side": 1,
      "message": "Right.  I guess I expected that if we cannot load the AVB metadata and need it for a given partition that we\u0027d abort from this function early.  I see that it just continues though.\n\nIn any case, if it continues or not, why differentiate between a) and b)?  It\u0027s only serves as an optimization to not call fs_mgr_avb_open() repeatedly if we\u0027ve failed to load AVB, but given that we\u0027re already in an error path in that case, I don\u0027t think there\u0027s any reason to add code to optimize this path.",
      "parentUuid": "4ef95d1b_1127dea9",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d9c5b66f_8c9f034e",
        "filename": "fs_mgr/fs_mgr.cpp",
        "patchSetId": 2
      },
      "lineNbr": 750,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-11T02:35:40Z",
      "side": 1,
      "message": "Yup, after some thought I agree the optimization is needless. Thanks for checking this in detail!",
      "parentUuid": "f22d2f22_e9950bb4",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "18cb9e2d_03753fcc",
        "filename": "fs_mgr/fs_mgr.cpp",
        "patchSetId": 2
      },
      "lineNbr": 750,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-12T15:55:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d9c5b66f_8c9f034e",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "41301c12_e85b1749",
        "filename": "fs_mgr/fs_mgr_avb.cpp",
        "patchSetId": 2
      },
      "lineNbr": 452,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2017-04-07T06:15:46Z",
      "side": 1,
      "message": "Why?  We\u0027ve been pretty consistently not using nothrow and expecting these daemons to blow up if they can\u0027t get their memory.  I don\u0027t think there\u0027s any graceful recovery from here.",
      "range": {
        "startLine": 452,
        "startChar": 12,
        "endLine": 452,
        "endChar": 26
      },
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4844b95_558f51f7",
        "filename": "fs_mgr/fs_mgr_avb.cpp",
        "patchSetId": 2
      },
      "lineNbr": 452,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-11T01:04:39Z",
      "side": 1,
      "message": "I saw some source using this and thought it\u0027s because we don\u0027t use exception: https://google.github.io/styleguide/cppguide.html#Exceptions\n\nBut I agree using nothrow doesn\u0027t quite matter. Will change it. Thanks!",
      "parentUuid": "41301c12_e85b1749",
      "range": {
        "startLine": 452,
        "startChar": 12,
        "endLine": 452,
        "endChar": 26
      },
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35578325_e9ce41ba",
        "filename": "fs_mgr/fs_mgr_avb.cpp",
        "patchSetId": 2
      },
      "lineNbr": 452,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2017-04-11T01:46:54Z",
      "side": 1,
      "message": "you should only use std::nothrow if you\u0027re expecting to recover from a failure to allocate, typically because the size of your allocation depends on user input.\n\nso if you\u0027re asked to open a file, and the file header says the file contains 3 billion sections, and you try to allocate an array of sizeof(SectionHeader) * 3 billion, say, you might want to be able to gracefully say \"this file implausibly claims to have 3 billion sections\" and keep running. but if you\u0027re just allocating something fixed-size that you need in order to function, it\u0027s much easier to reason about if you just std::terminate because there\u0027s no catch handler for the exception that would otherwise be thrown. the failure to allocate \"can\u0027t happen\" anyway.",
      "parentUuid": "e4844b95_558f51f7",
      "range": {
        "startLine": 452,
        "startChar": 12,
        "endLine": 452,
        "endChar": 26
      },
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b24c9d9_28a197ad",
        "filename": "fs_mgr/fs_mgr_avb.cpp",
        "patchSetId": 2
      },
      "lineNbr": 452,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-11T02:13:46Z",
      "side": 1,
      "message": "I see, makes sense.\nThanks for the detailed explanation!",
      "parentUuid": "35578325_e9ce41ba",
      "range": {
        "startLine": 452,
        "startChar": 12,
        "endLine": 452,
        "endChar": 26
      },
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "24b45a11_4f7265b2",
        "filename": "fs_mgr/fs_mgr_avb.cpp",
        "patchSetId": 2
      },
      "lineNbr": 452,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-12T15:55:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6b24c9d9_28a197ad",
      "range": {
        "startLine": 452,
        "startChar": 12,
        "endLine": 452,
        "endChar": 26
      },
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "576a8a19_68564022",
        "filename": "fs_mgr/fs_mgr_priv_avb.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2017-04-07T06:15:46Z",
      "side": 1,
      "message": "Thinking out loud a bit...\n\nI think we\u0027re over using unique_ptr with a custom deleter too much here.  It\u0027s required for wrapping the C pointers from libavb, but all new types created in fs_mgr should have destructors (or better they should have all of their members have destructors).  So for fs_mgr_avb_handle, I\u0027d rather have something like:\n\nstruct fs_mgr_avb_handle {\n  std::unique_ptr\u003cAvbSlotVerifyData, decltype(\u0026avb_slot_verify_data_free)\u003e avb_slot_verify_data;\n  std::unique_ptr\u003cAvbOps\u003e avb_ops;\n  AvbHandleStatus status;\n}\n\nThen we should get rid of fs_mgr_avb_close() and have fs_mgr_avb_open() return std::unique_ptr\u003cfs_mgr_avb_handle\u003e.  Better, it should be a factory method within fs_mgr_avb_handle, so std::unique_ptr\u003cfs_mgr_avb_handle\u003e fs_mgr_avb_handle::Open()\n\nWe should rework fs_mgr_avb_ops.cpp too.  Get rid of fs_mgr_dummy_avb_ops_free() and have fs_mgr_dummy_avb_ops_new() return a unique_ptr\u003cAvbOps\u003e directly.\n\nAlso, ideally, this would follow the google C++ naming style too, so FsManagerAvbHandle.",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a83601a_25639eb2",
        "filename": "fs_mgr/fs_mgr_priv_avb.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-11T01:04:39Z",
      "side": 1,
      "message": "Thanks for the good suggestions.\n\nBut I would rather not adding the unique_ptr\u003c\u003e inside fs_mgr_avb_handle.\nThe main reason is that avb_slot_verify_data is read-write: avb_slot_verify(..., \u0026avb_slot_verify_data), using a unique_ptr won\u0027t help simplify the code much.\n\nhttps://android.googlesource.com/platform/external/avb/+/master/libavb/avb_slot_verify.h#251\n\ne.g., we would need to have something like:\nAvbSlotVerifyData* slot_data \u003d nullptr.\navb_result \u003d avb_slot_verify(..., \u0026slot_data);\n\nif (avb_result \u003d\u003d ...)\n  FsManagerAvbHandle.avb_slot_verify_data.reset(slot_data);\n\n\nI would rather have the following and free them on the ~FsManagerAvbHandle() so it can work with \"default deleter\".\n\nclass FsManagerAvbOps;  // adding a class to hold device_file_by_name_prefix.\nclass FsManagerAvbHandle {\npublic:\n  std::unique_ptr\u003cFsManagerAvbHandle\u003e FsManagerAvbHandle::Open();\n  ~FsManagerAvbHandle() {\n      if (avb_slot_verify_data)\n         avb_slot_verify_data_free(avb_slot_verify_data);\n  }\nprivate:\n  AvbSlotVerifyData* avb_slot_verify_data;\n  FsManagerAvbOps avb_ops;\n  FsManagerAvbHandleStatus status;\n}\n\nPlease LMK if you have other concern.\nThanks!",
      "parentUuid": "576a8a19_68564022",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7c41d2e4_b040d918",
        "filename": "fs_mgr/fs_mgr_priv_avb.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2017-04-11T02:16:49Z",
      "side": 1,
      "message": "The classes sound good to me the way you\u0027ve written then; I\u0027m sure I\u0027ll have more concrete comments once they\u0027re written. \n\nI think I wrote this on a different CL, but the FsManagerAvbOps should be helped by the user_data element of the AvbOps struct.  \n\nBasically what we want is a class with static methods that cast the AvbOps::user_data into a pointer of the class itself and dispatch to the class methods.  The FakeAvbOps in external/avb/test/fake_avb_ops.h does this (and more than we need actually).",
      "parentUuid": "7a83601a_25639eb2",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "533c7888_cc638c83",
        "filename": "fs_mgr/fs_mgr_priv_avb.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-11T02:35:40Z",
      "side": 1,
      "message": "Yes, that\u0027s exactly my plan to AvbOps::user_data to hold *this for FsManagerAvbOps().\n  \nI actually considered this before when seeing FakeAvbOps(). But just thought it\u0027s a bit overkill given we just need to provide read_from_partition() here (others are dummy).\n  \nAnyway, let\u0027s do this in a C++-ish way so it\u0027s more extendable/readable for future enhancement.\n  \nThanks for reviewing this :)",
      "parentUuid": "7c41d2e4_b040d918",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f16a74b_494ea964",
        "filename": "fs_mgr/fs_mgr_priv_avb.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2017-04-11T16:51:58Z",
      "side": 1,
      "message": "Sgtm.  \n\n\u003e I actually considered this before when seeing FakeAvbOps(). But just thought it\u0027s a bit overkill given we just need to provide read_from_partition() here (others are dummy).\n\nFakeAvbOps is a bit overkill; we definitely don\u0027t need a dispatch_ member.  But since we do need to provide implementations for each of the functions in any case, it makes sense to have a set of virtual functions as they do with the default behavior a no-op and allow subclasses to override and provide strictly the functionality that is needed.\n\nIn general, and I think we both agree and are on this path, but I\u0027ll state it explicitly for posterity: we should make C++ bindings for libavb and only interact with libavb through those bindings.  We can see if it would make sense to include them as a header for libavb itself, but for now, let\u0027s make them for fs_mgr and use them here.",
      "parentUuid": "533c7888_cc638c83",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "68ea894b_fab44dee",
        "filename": "fs_mgr/fs_mgr_priv_avb.h",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1080813
      },
      "writtenOn": "2017-04-12T15:55:02Z",
      "side": 1,
      "message": "Done.\nI guess you meant delegate_? (Agree that we don\u0027t need it :))\n\nAdding virtual functions seems overkill to me.\nPlease see FsManagerAvbOps() in PS-3, it provides the C++ binding for libavb-\u003eavb_slot_verify().\n\nAs David mentioned, the libavb is mainly for bootloader to perform verified boot. The major security checks are done there. In user-space, we actually just need to get the AVB metadata to extract dm-verity params for kernel. \n\nI don\u0027t think any user-space other than fs_mgr will need to use libavb() because \"verified boot\" should be done prior to device mounts/starts the userland.",
      "parentUuid": "8f16a74b_494ea964",
      "revId": "a0d93144bed8a885cbeb8adcccfc3625d960a0e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}