{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "902302ed_8ad06ae9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1902326
      },
      "writtenOn": "2022-04-05T22:00:02Z",
      "side": 1,
      "message": "I\u0027ve implemented the updated `recv` using only safe `Vec` methods, though we could implement it more efficiently using the unsafe API. I figured started with the safe version makes sense, but if there\u0027s a reason to think the performance overhead would be prohibitive then I can rewrite it.",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dacd202_7a938c92",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2022-04-05T22:05:13Z",
      "side": 1,
      "message": "I\u0027m not too sure this kind of API makes a ton of sense in the Trusty scenario, since all our APIs fundamentally have ",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2cfa62e4_1c534e9e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1902326
      },
      "writtenOn": "2022-04-05T23:26:18Z",
      "side": 1,
      "message": "Yeah, I was debating this myself. In theory client code should always be able to declare a fixed-size slice that is large enough, so the `Vec` version shouldn\u0027t be _necessary_.\n\nBut there\u0027s an ergonomic benefit to using `Vec` in that the user doesn\u0027t need to check the returned message length, e.g.\n\n```rust\nlet mut buf \u003d [0u8; 4096];\nlet len \u003d conn.recv_no_alloc(buf.as_mut_slice()).unwrap();\nlet msg_buf \u003d \u0026buf[..len];\n```\n\nversus:\n\n```rust\nlet mut buf \u003d Vec::with_capacity(4096);\nconn.recv(\u0026mut buf).unwrap();\n```\n\nIt\u0027s a minor difference, but it\u0027s one less point of failure and bit more ergonomic to use. idk if that\u0027s enough of a reason to have the `Vec` version.",
      "parentUuid": "6dacd202_7a938c92",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcd91941_6ff434a6",
        "filename": "trusty/libtrusty-rs/src/lib.rs",
        "patchSetId": 1
      },
      "lineNbr": 148,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2022-04-05T22:05:13Z",
      "side": 1,
      "message": "Have we considered just doing:\n1. If space is reserved, assume it\u0027s the right amount\n2. Otherwise, reserve 4096 bytes, more than any Trusty message can contain\n?\n\nThis avoids looping (though we might still want to loop to handle EINTR, I guess, but I don\u0027t think we ever return EINTR)",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "094082d1_918f61ee",
        "filename": "trusty/libtrusty-rs/src/lib.rs",
        "patchSetId": 1
      },
      "lineNbr": 148,
      "author": {
        "id": 1902326
      },
      "writtenOn": "2022-04-05T23:26:18Z",
      "side": 1,
      "message": "Ah, that would also be a good solution if we\u0027re not worried about allocating more than might be necessary (which is probably be fine here? idk how careful you have to be with allocations in a HAL process).",
      "parentUuid": "bcd91941_6ff434a6",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b946cd41_5ff30e2f",
        "filename": "trusty/libtrusty-rs/src/lib.rs",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2022-04-05T22:05:13Z",
      "side": 1,
      "message": "recv_no_alloc",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f382721_9ec06eb1",
        "filename": "trusty/libtrusty-rs/src/lib.rs",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 1902326
      },
      "writtenOn": "2022-04-05T23:26:18Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b946cd41_5ff30e2f",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4e6a43b_5cd37b5f",
        "filename": "trusty/libtrusty-rs/src/lib.rs",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2022-04-05T22:05:13Z",
      "side": 1,
      "message": "libc::EMSGSIZE",
      "range": {
        "startLine": 165,
        "startChar": 32,
        "endLine": 165,
        "endChar": 34
      },
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1123e6c2_5e0a289a",
        "filename": "trusty/libtrusty-rs/src/lib.rs",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1902326
      },
      "writtenOn": "2022-04-05T23:26:18Z",
      "side": 1,
      "message": "Oh. duh ðŸ¤¦",
      "parentUuid": "c4e6a43b_5cd37b5f",
      "range": {
        "startLine": 165,
        "startChar": 32,
        "endLine": 165,
        "endChar": 34
      },
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b15cebff_7ee73d96",
        "filename": "trusty/libtrusty-rs/tipc-test-rs/main.rs",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2022-04-05T22:08:08Z",
      "side": 1,
      "message": "Why are we using vec! for any of this? These are all fixed size buffers, so why isn\u0027t it just `let mut send_buf \u003d [0u8; msg_len]`;\nand later `let mut recv_buf \u003d [0u8; msg_len]`;\n?\n\nThis is fine since it\u0027s just test code, but we already know the expected sizes of everything, why use heap allocated, dynamically sized data.",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23914665_66807632",
        "filename": "trusty/libtrusty-rs/tipc-test-rs/main.rs",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1902326
      },
      "writtenOn": "2022-04-05T23:26:18Z",
      "side": 1,
      "message": "`msg_len` is a variable, so we can\u0027t use a fixed-size array. We could instead use a fixed size array that\u0027s extra large and then carve a `msg_len` sized slice out of it, but that\u0027s way more cumbersome than just using `Vec`, especially for test code.",
      "parentUuid": "b15cebff_7ee73d96",
      "revId": "e952a9b0ca9208b17f3b1a0e01758d27c09cee71",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}