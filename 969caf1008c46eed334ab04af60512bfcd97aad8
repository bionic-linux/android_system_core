{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7aa3a706_d9347114",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-10T20:31:16Z",
      "side": 1,
      "message": "This is only releasing one refcount of ownership.\n\nCall \u0027releaseOne\u0027 and add docs a bit, either on the method or in the Strong",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb3d0484_baf5c1ca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-10T20:31:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7aa3a706_d9347114",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4267800_556a3d7c",
        "filename": "libutils/binder/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-10T20:31:16Z",
      "side": 1,
      "message": "This is only releasing one refcount of ownership. Maybe \u0027releaseOne\u0027 or similar? Or document more. In the commit message, you say instead of running ~sp. Of course, it\u0027s unsafe in generaly to call \u0027delete ret\u0027. You must call \u0027ret-\u003edecStrong()\u0027 because there may be something else that owns it. Or were you thinking something else?\n\nDo you have the case where you want to use this, so I can see what you mean? I can see how this API would be useful, but it\u0027s also probably better to avoid managing ownership like this.",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03c81f43_63d70f37",
        "filename": "libutils/binder/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2023-11-10T20:42:10Z",
      "side": 1,
      "message": "I called it `release()` because that\u0027s what `std::unique_ptr` calls it. It\u0027s on a specific sp\u003c\u003e, so I\u0027m not sure releaseOne would add much additional clarity?\n\nAs for usage, yeah any place we need to store a shared pointer in a jlong as a broadly common example. I want to migrate to using sp\u003cT\u003e::make() as a general rule, but then hit the issue with this missing\n\nExamples:\n\nhttps://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/hwui/jni/android_graphics_RenderNode.cpp;drc\u003dcab4afeb64bbc6280990b34bd55270b19218ac04;l\u003d61\n\nhttps://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/hwui/jni/Gainmap.cpp;drc\u003db1c20eea9e53c2ae1147ce44ed25e524a4e51cc1;l\u003d62\n\nhttps://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/jni/android_window_ScreenCapture.cpp;drc\u003d20ca02e27015e8ae53f4283500fb20933d55053c;l\u003d239",
      "parentUuid": "b4267800_556a3d7c",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d74f5fbf_5bc6dcba",
        "filename": "libutils/binder/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-10T20:53:18Z",
      "side": 1,
      "message": "btw - you saw the cflag you can set to migrate to sp\u003cT\u003e::make, right? ðŸ˜„ ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION - you should set this!\n\nAnyway, there is no std::shared_ptr::release. \u0027release\u0027 often carries the connotation that you now own the object, which is not true here, so I think there is some opportunity for confusion here.\n\nYou have the code now:\n\n```\n    sp\u003cgui::IScreenCaptureListener\u003e listener \u003d\n            sp\u003cScreenCaptureListenerWrapper\u003e::make(env, consumerObj);\n    listener-\u003eincStrong((void*)nativeCreateScreenCaptureListener);\n    return reinterpret_cast\u003cjlong\u003e(listener.get());\n```\n\nwith this change, it could be changed to:\n\n```\n    return reinterpret_cast\u003cjlong\u003e(sp\u003cScreenCaptureListenerWrapper\u003e::make(env, consumerObj).release());\n```\n\nOne downside actually is that you\u0027d lose the debug information \u0027(void*) nativeCreateScreenCaptureListener\u0027, but that seems okay. Also, if you use this API, you\u0027ll no longer have matching \u0027incStrong\u0027 and \u0027decStrong\u0027, which I honestly see as the biggest clarity issue - you have to know you are pairing decStrong with incStrong in the constructor.\n\nDo you think there\u0027s some other more explicit name we could use? I think the code I quoted above with incStrong and make is probably better than a shortcut - fewer things to think about at the cost of a few lines of code, but if you feel strongly about adding this API, I think it needs more docs, bigger name to distinguish it from \u0027release\u0027, and maybe add a test as well?\n\nbut yeah, I am not convinced we should encourage this type of thing, as necessary as it is. WDYT?",
      "parentUuid": "03c81f43_63d70f37",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "268f1145_7026d056",
        "filename": "libutils/binder/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2023-11-10T20:59:54Z",
      "side": 1,
      "message": "\u003e Anyway, there is no std::shared_ptr::release. \u0027release\u0027 often carries the connotation that you now own the object\n\nYeah but that\u0027s because shared_ptr is an external refcount system, which StrongPointer is not.\n\n\u003e you have to know you are pairing decStrong with incStrong in the constructor.\n\nYeah but that\u0027s very well defined and very explicit since the type itself is the one doing the refcounting, not sp\u003c\u003e (unlike std::shared_ptr)\n\n\u003e One downside actually is that you\u0027d lose the debug information \u0027(void*) nativeCreateScreenCaptureListener\u0027, but that seems okay. \n\nIt\u0027s a no-op on LightRefBase which is all my chunk of sp\u003c\u003e usages cares about ðŸ˜Š\n\n\u003e but yeah, I am not convinced we should encourage this type of thing, as necessary as it is. WDYT?\n\nIt\u0027s pretty silly to force me to pay for 2 atomics I don\u0027t need, no? That\u0027s a pretty big discouragement to using `ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION`",
      "parentUuid": "d74f5fbf_5bc6dcba",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "948c742d_c3b1889c",
        "filename": "libutils/binder/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-10T21:07:36Z",
      "side": 1,
      "message": "You can still do:\n\n`A* a \u003d new A(); a-\u003eincStrong();` with ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION\n\nThe only thing you can\u0027t do is use `sp(T* other);  // NOLINT(implicit)`. Instead, you would have to use `sp\u003cT\u003e::fromExisting(T* other)` which is the same, except if \u0027other\u0027 has zero refcounts at that point (it is actually unowned), it will abort.\n\nor if you have a code case where you get an sp and you need to take ownership from an sp\u003c\u003e, could you share this case as well? (I think https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/hwui/jni/Gainmap.cpp;l\u003d62;drc\u003db1c20eea9e53c2ae1147ce44ed25e524a4e51cc1 needs the extra atomic incStrong usage with or without this change).\n\n\u003e but if you feel strongly about adding this API, I think it needs more docs, bigger name to distinguish it from \u0027release\u0027, and maybe add a test as well?",
      "parentUuid": "268f1145_7026d056",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "394bb21b_b164b4bb",
        "filename": "libutils/binder/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2023-11-10T21:14:22Z",
      "side": 1,
      "message": "\u003e I think https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/hwui/jni/Gainmap.cpp;l\u003d62;drc\u003db1c20eea9e53c2ae1147ce44ed25e524a4e51cc1 needs the extra atomic incStrong usage with or without this change\n\nIt wouldn\u0027t, the local sp\u003c\u003e already did the incStrong when it was constructed\n\n\u003e You can still do: `A* a \u003d new A(); a-\u003eincStrong();` with ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION\n\nYeah but then I have to remember if RefBase initializes with refcount\u003d0 or refcount\u003d1 which is more error prone than a blanket rule of \"only use sp\u003cT\u003e::make()\" and then if I have an sp\u003c\u003e I always know I have an owned ref count, and can just .release() if I need to pass ownership to a jlong or a C callback or whatever.\n\n\u003e bigger name to distinguish it from \u0027release\u0027\n\nStill not following why it needs a different name? It\u0027s the same as unique_ptr? That is, the RAII wrapper stops managing it, and you now have to. See also unique_fd::release() https://cs.android.com/android/platform/superproject/+/master:system/libbase/include/android-base/unique_fd.h;drc\u003d7bc8db18d96e9c76d72aefe16826981fbf44fba4;l\u003d100\n\nThis is a pretty common pattern for RAII owning classes. sk_sp\u003c\u003e also has this and also calls it release(): https://source.corp.google.com/h/googleplex-android/platform/superproject/main/+/main:external/skia/include/core/SkRefCnt.h;l\u003d324",
      "parentUuid": "948c742d_c3b1889c",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26ad9f37_9e22a003",
        "filename": "libutils/binder/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 103,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-10T21:28:38Z",
      "side": 1,
      "message": "I think it keeps the sp\u003c\u003e intact here:\nhttps://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/hwui/hwui/Bitmap.h;l\u003d206;drc\u003dac175cc44ff40634aa9b8d8fb15cb5dd94ab8285\n\nright? So - after you call Gainmap_extractFromBitmap, both the Bitmap and the new Java Gainmap will be pointing to the same sp\u003c\u003e? So, before you have one refcount, and you must come up with another one? So I don\u0027t see a case where sp\u003cT\u003e::fromExisting wouldn\u0027t work.\n\nIt\u0027s unfortunate it would require an extra allocation to use \u0027struct MyJniObj { sp\u003cT\u003e t; }\u0027 so the JNI layer doesn\u0027t have to get involved with RefBase implementation details.\n\n\u003e Yeah but then I have to remember if RefBase\n\nMore APIs is strictly more complicated and more things people need to learn about to use in Android. An API being simpler doesn\u0027t mean we should add it - it\u0027s still more APIs. I think:\n1. we really don\u0027t want people using RefBase like this (or honestly using RefBase at all if possible - all the gotchas with internal refcounts..).\n2. we can already express this behavior with the existing APIs (pending discussion on Gainmap)\n\nSo I really am not convinced on this. That being said, I\u0027m also not totally opposed to the API. The situation here is beyond horrible already, so I don\u0027t feel like I can take the high-road position the excellent std::shared_ptr authors took by not including anything remotely similar to \u0027release\u0027 in their API ðŸ˜„ - that is - I\u0027d prefer to keep everything behind managed pointers where the (already unfortunately VERY leaky) type system prevents mistakes, but if you really want it, okay ðŸ˜Š\n\nAnyway, if \u0027release\u0027 is used with other \u0027shared\u0027 things, then I wouldn\u0027t ask you to change the name, but I think we should still explicitly document how this is only one ref count, the client needs to manually call decStrong, it\u0027s not exclusive ownership. Also, add to the StrongPointer_test.cpp.",
      "parentUuid": "394bb21b_b164b4bb",
      "revId": "969caf1008c46eed334ab04af60512bfcd97aad8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}