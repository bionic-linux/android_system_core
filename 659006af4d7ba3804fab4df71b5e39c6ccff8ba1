{
  "comments": [
    {
      "key": {
        "uuid": "8bd3c31c_cf394906",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "Is there any particular reason for the selection of 1024?\n\nIt seems more robust to ensure O_CLOEXEC is set on all file descriptors that we care about, and in particular to check /proc/self/fd/ instead of relying on a hard-coded constant.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_3a6cb17b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "This is an arbitrary number selected to hopefully close all of the file descriptors. The point of this isn\u0027t to reimplement O_CLOEXEC, it\u0027s to allow us to log failure and create communication pipes when all of the file descriptors *before* the exec happens. (see the comment at line 162)",
      "parentUuid": "8bd3c31c_cf394906",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_75764a4b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "It seems then that we\u0027d want to look in /proc/self/fd and check our ulimit to see if we need to do this, rather than making assumptions.\n\nIf we\u0027re in a sufficiently weird state that we\u0027ve hit the ulimit for file descriptors, it\u0027s reasonable that we may also be in a sufficiently weird state that they\u0027re all above 1024.",
      "parentUuid": "8bd3c31c_3a6cb17b",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bc73767_260e56e3",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T22:41:12Z",
      "side": 1,
      "message": "Actually, it looks like you may just be able to increase the soft limit at runtime.\n\nshell@angler:/ $ ulimit -n\n1024\nshell@angler:/ $ ulimit -nH\n4096",
      "parentUuid": "8bd3c31c_75764a4b",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_6f267dd5",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 198,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "It\u0027s not clear what this actually does, since any effects will be lost via the exec",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_8faae16b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 198,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "It gets passed as an argument to exec.",
      "parentUuid": "8bd3c31c_6f267dd5",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_356cc27b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 198,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8bd3c31c_8faae16b",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_cf2ce9b1",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 227,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "This needs to be done in a loop, checking for the exit status.  For example, a SIGSTOP sent to the child should still cause this wait to exit.  See WIFEXITED.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_af8a4566",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 271,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "Why are we not just using pthread here?  I\u0027m sure there\u0027s a good reason, it\u0027s just not mentioned.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_ba7fe119",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 271,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "See the comment at line 162",
      "parentUuid": "8bd3c31c_af8a4566",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_f5897a0a",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 271,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "It\u0027s probably worthwhile to add a line comment that just calls out \"this is basically pthread_create without CLONE_FILES and XYZ\"",
      "parentUuid": "8bd3c31c_ba7fe119",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_afcb25ab",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 341,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "Why are we doing all of this manually instead of using pthread?\n\nPresumably, it\u0027s to limit the size of the stack and ensure it\u0027s bounded by guard pages on either side.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_0fac11d4",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 346,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "I\u0027m not sure I understand why we\u0027re skipping over 0x10 bytes at the base of the stack.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_9a94dd1d",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 346,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "To satisfy ABI requirements on stack alignment",
      "parentUuid": "8bd3c31c_0fac11d4",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_f5a25a82",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 346,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "0xABCDE000 is sufficiently aligned as 0xABCDE010.  There shouldn\u0027t be a need to skip over 16 bytes, unless there\u0027s code that does something silly like dereferencing sp.  Stack frame allocation usually decrements SP before storing.",
      "parentUuid": "8bd3c31c_9a94dd1d",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_0f2ed1ed",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 79,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "O_CLOEXEC?",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_6fae7d3c",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "This should be atomic, no?",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_7ac8f941",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "This process is entirely single threaded, these callbacks happen in a serialized fashion upon input on a socket (or timeout).",
      "parentUuid": "8bd3c31c_6fae7d3c",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_b5da92fc",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "Then the name is a bit misleading, no?",
      "parentUuid": "8bd3c31c_7ac8f941",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_4fd299bb",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 165,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "There\u0027s a race condition here, if multiple concurrent dumps take the \u0027false\u0027 branch.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}