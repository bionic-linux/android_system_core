{
  "comments": [
    {
      "key": {
        "uuid": "201d4ac8_260fda61",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1045553
      },
      "writtenOn": "2017-08-03T22:29:40Z",
      "side": 1,
      "message": "If you do it this way, there is no way to detect that secure side sent more data than you can handle. This is because iov_len will become 0 and readv would drop data on the floor without generating any errors.",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "918b8e70_566bb86e",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1125188
      },
      "writtenOn": "2017-08-04T21:30:11Z",
      "side": 1,
      "message": "I think this would be caught by line 73\n\nif (*out_size \u003e\u003d out_max_size) {\n   ....\n   return -ENOMEM;\n}\n\nSo iov_len should never be 0.",
      "parentUuid": "201d4ac8_260fda61",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1aadd009_2cae0dff",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1045553
      },
      "writtenOn": "2017-08-09T17:32:10Z",
      "side": 1,
      "message": "you assume that incoming message is going to have non zero payload, which is technically not guaranteed, as, protocol that you defining allows zero payload.",
      "parentUuid": "918b8e70_566bb86e",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "26b717f7_3a281812",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1125188
      },
      "writtenOn": "2017-08-09T17:52:32Z",
      "side": 1,
      "message": "What if I check for iov_len \u003d\u003d 0 when (out_max_size - *out_size) \u003c KEYMASTER_MAX_BUFFER_LEN? Not sure of another way to read data directly into the out buffer.",
      "parentUuid": "1aadd009_2cae0dff",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "54c1a6a1_ef3c9de7",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1125188
      },
      "writtenOn": "2017-08-09T17:53:23Z",
      "side": 1,
      "message": "Or I can continue to use a temporary buffer of size KEYMASTER_MAX_BUFFER_LEN",
      "parentUuid": "26b717f7_3a281812",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7d18af8_31af9c0a",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1045553
      },
      "writtenOn": "2017-08-09T18:03:28Z",
      "side": 1,
      "message": "or if out_max_size \u003d\u003d *out_size and you still need to read final message, direct it to dummy location. 1 byte will be enough.",
      "parentUuid": "54c1a6a1_ef3c9de7",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5b84e99a_9c10d089",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1045553
      },
      "writtenOn": "2017-08-09T18:19:04Z",
      "side": 1,
      "message": "or you have to always setup iovec for guard byte, because there is a case when last message gets truncated.",
      "parentUuid": "b7d18af8_31af9c0a",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eebf9cf6_8477790d",
        "filename": "trusty/keymaster/trusty_keymaster_ipc.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1125188
      },
      "writtenOn": "2017-08-09T23:14:03Z",
      "side": 1,
      "message": "As discussed offline, changed this so that the tipc connection is reset on tipc errors. This way we don\u0027t have to read and drop remaining messages when out_buf is too small.",
      "parentUuid": "5b84e99a_9c10d089",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 80,
        "endChar": 36
      },
      "revId": "f1d33308fe696cd41e12ebfea056ae1952c4f6f5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}