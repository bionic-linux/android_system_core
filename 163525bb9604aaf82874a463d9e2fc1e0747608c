{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a35ed3eb_8e3517a6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1453063
      },
      "writtenOn": "2023-11-02T11:53:12Z",
      "side": 1,
      "message": "enh@ - do you want to land your esr stuff before this, or shall we land both and just merge them later?",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee54f869_0f57a68e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-02T20:50:11Z",
      "side": 1,
      "message": "oh, i didn\u0027t notice +cferris wasn\u0027t here.\n\nhe can cast the deciding vote, but personally i\u0027m not convinced this is particularly useful? i think what i\u0027d really like (and have long wanted, and for SIGILL too) is to disassemble the faulting instruction... but with just a read/write/dunno flag, i\u0027m still going to end up doing that manually anyway.\n\n(plus, like i said earlier when i thought cferris was already cc:ed, i defer to him for how much breakage changing this oft-regexed line is likely to cause...)",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7147d933_812686cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-02T20:51:23Z",
      "side": 1,
      "message": "(and specifically for this question --- nothing should be blocked on the esr stuff; i have no idea when i\u0027ll have the time to look at that again :-( anyone who wants that change should probably just take it over themselves!)",
      "parentUuid": "a35ed3eb_8e3517a6",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e195bae3_969459b5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2023-11-02T21:58:30Z",
      "side": 1,
      "message": "I would also tend toward not adding this distinction. I have never needed to know whether a crash is due to a read or a write. I also just use the disassembled instructions to figure out what\u0027s going on.\n\nWhat\u0027s the motivation for adding this?",
      "parentUuid": "ee54f869_0f57a68e",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfc80b9e_6873d846",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1005967
      },
      "writtenOn": "2023-11-02T22:18:44Z",
      "side": 1,
      "message": "While we are on this topic - how do you disassemble instructions from a tombstone memory dump? I\u0027ve got this monstrosity but there must be a better way:\n```\nperl -pe \u0027s/([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2}) ?/0x$8,0x$7,0x$6,0x$5,0x$4,0x$3,0x$2,0x$1,/g\u0027 | llvm-mc -triple\u003daarch64 -disassemble\n```",
      "parentUuid": "e195bae3_969459b5",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdb47d47_350d8fe0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-02T22:52:56Z",
      "side": 1,
      "message": "/me sheepishly admits \"that, except manually rather than with perl\" :-(\n\n(but, yeah, we should totally teach the script how to do this. iirc agampe@ wrote something, but we never got it integrated for some reason? i\u0027ll be very embarrassed if it\u0027s actually there and i\u0027ve just not been using it!)",
      "parentUuid": "dfc80b9e_6873d846",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a42e131b_c1120258",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1453063
      },
      "writtenOn": "2023-11-03T12:40:01Z",
      "side": 1,
      "message": "A few reasons to do this:\n 1. There\u0027s a longstanding request from ASA as this would help with their analysis of external bug reports.\n 2. Feature parity with ASan and HWASan.\n 3. Understanding third-party app crashes and OEM device crashes easier, where we don\u0027t have access to the code immediately.\n 4. Convenience. I often want this feature for a quick at-a-glance :).",
      "parentUuid": "cdb47d47_350d8fe0",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "610ffb42_67cf32a8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2023-11-03T15:43:43Z",
      "side": 1,
      "message": "\u003e There\u0027s a longstanding request from ASA as this would help with their analysis of external bug reports.\n\ndid they say _how_? (since that\u0027s a bit of a circular argument, since we\u0027re saying we don\u0027t believe that :-) )\n\n\u003e Feature parity with ASan and HWASan.\n\nfor me the useful part there is the information about the buffer, not whether it\u0027s a read or a write?\n\n\u003e Understanding third-party app crashes and OEM device crashes easier, where we don\u0027t have access to the code immediately.\n\nthat sounds like yet another vote for \"if we can\u0027t disassemble, at least dump the instruction\"...\n\n\u003e Convenience. I often want this feature for a quick at-a-glance :).\n\n_why_ though? what do you do with this information (and especially in non-asan/hwasan contexts)?",
      "parentUuid": "a42e131b_c1120258",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3eaa7d7_ec629820",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1453063
      },
      "writtenOn": "2023-11-07T15:56:46Z",
      "side": 1,
      "message": "Here\u0027s a scenario that I believe summarises the value for ASA:\n\n 1. You get a GWP-ASan/MTE bug report with a tombstone. It doesn\u0027t have logcat or register contentx.\n 2. You throw it into go/as, which gives you nice pretty line numbers.\n 3. It symbolizes to a line that is `*v \u003d x[i];` It\u0027s not clear whether the OOB is from the read of `x[i]` or the write of `*v`.\n 4. You have to download the full symbols to look at the diassembly to figure out that it\u0027s a write access.\n 5a. Because the OOB was a write, you mark it as \"critical\" and move on with your day.\n 5b. Because the OOB was a read, you have to do the taint analysis to make sure that it doesn\u0027t end up a write, before you mark it as \"high\".\n \n#4 is unnecessary if you know that it\u0027s a write. Downloading full symbols sucks, as you know, and takes time.\n\nHere\u0027s a scenario that I want:\n\n 1. I get $VAST_QUANTITY of GWP-ASan bugs from OEM devices.\n 2. I want to figure out how many of them are reads vs. writes for a quick and dirty analysis of use-after-free bugs on Android.\n 3. I can then use this data to see how great asymmetric MTE is by the basis of \"the first bad memory access was caught synchronously).\n \nYes, I\u0027m happier with disassembly and disassembly would be a superset of this feature. But I\u0027m not looking to implement it right now and are very happy with the cheap read/write flag for the low time investment :).",
      "parentUuid": "610ffb42_67cf32a8",
      "revId": "163525bb9604aaf82874a463d9e2fc1e0747608c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}