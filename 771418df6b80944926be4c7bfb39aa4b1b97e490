{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "94f1e081_05ccbded",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 35,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "nit: mixing snake case in camel case repository (everywhere)",
      "range": {
        "startLine": 35,
        "startChar": 26,
        "endLine": 35,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "250bef7a_129ff842",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 35,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "Sorry about that, have done a lot of jumping back and forth between various style conventions in AOSP during this project!",
      "parentUuid": "94f1e081_05ccbded",
      "range": {
        "startLine": 35,
        "startChar": 26,
        "endLine": 35,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "840f1947_85711f3b",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 58,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "gRefDeletedLock, but do consider \u0027std::atomic\u003cbool\u003e\u0027 for this kind of thing",
      "range": {
        "startLine": 58,
        "startChar": 7,
        "endLine": 58,
        "endChar": 13
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "22e45bed_9ec0f4c2",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 58,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "I did look into using atomics for this, but I didn\u0027t see an easy way to block only on writes using them. I would be surprised if it was impossible using atomics, but I\u0027m not sure they\u0027re really designed for solving this specific problem.",
      "parentUuid": "840f1947_85711f3b",
      "range": {
        "startLine": 58,
        "startChar": 7,
        "endLine": 58,
        "endChar": 13
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "811b2949_c8008294",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "gRefDeleted",
      "range": {
        "startLine": 59,
        "startChar": 5,
        "endLine": 59,
        "endChar": 15
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4d587685_1542c389",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "811b2949_c8008294",
      "range": {
        "startLine": 59,
        "startChar": 5,
        "endLine": 59,
        "endChar": 15
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aede6130_b5dc1a82",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "this should no longer be needed right, since these reflect the underlying stores, but strong_weak/weak_count you have reflect API usages, right? (especially since strong_count/weak_count can be zero, I\u0027m not sure what these would do)",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dbeefba_4dcc473b",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-17T23:54:52Z",
      "side": 1,
      "message": "There\u0027s a LOG_ALWAYS_FATAL_IF in decStrong that will completely crash the fuzzer if decStrong is called with only one remaining strong reference, same for weak references, which is why I have this check.",
      "parentUuid": "aede6130_b5dc1a82",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2791c49_5053e569",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T00:04:01Z",
      "side": 1,
      "message": "this should be if the strong count was 0 or very very big (it\u0027s trying to detect underflow). Note fetch_sub is returning the value of the ref count before the subtraction is applied",
      "parentUuid": "0dbeefba_4dcc473b",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1399b73c_65a05a4e",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-18T00:13:47Z",
      "side": 1,
      "message": "So I guess I\u0027m a little confused about how that works. I see the call to removeStrongRef, then the count is set to mStrong.fetch_sub (so I\u0027m guessing this is the strong count minus 1?), then that value is run through BAD_STRONG. If anything it seems like that logic should trigger when the strong count is 1 or less, which seems to be the behavior I was encountering (thus the strong_count - 1 check)",
      "parentUuid": "c2791c49_5053e569",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "678f0f14_6d2b9874",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T01:06:17Z",
      "side": 1,
      "message": "\u003e #define BAD_STRONG(c) \\\n\u003e         ((c) \u003d\u003d 0 || ((c) \u0026 (~(MAX_COUNT | INITIAL_STRONG_VALUE))) !\u003d 0)\n\u003e ...\n\u003e void RefBase::decStrong(const void* id) const\n\u003e {\n\u003e ...\n\u003e     const int32_t c \u003d refs-\u003emStrong.fetch_sub(1, std::memory_order_release);\n\u003e ...\n\u003e     LOG_ALWAYS_FATAL_IF(BAD_STRONG(c), \"decStrong() called on %p too many times\",\n\u003e             refs);\n\nHere is the code from RefBase.cpp. If mStrong was 1, then c will be 1, and BAD_STRONG(1) is false, so those won\u0027t be a fatal error (it\u0027ll go on to call onLastStrongRef).",
      "parentUuid": "1399b73c_65a05a4e",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b1a259d3_5954f278",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "Ah yeah you\u0027re right, sorry!",
      "parentUuid": "678f0f14_6d2b9874",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a36e1ecc_aa7aa711",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "nit: this is not a recursive mutex, but L137 could take it if it erroneously calls ~RefBaseSubclass. prefer to only hold lock when it is needed, for L134",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f01dfbf_a7bebed3",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-17T23:54:52Z",
      "side": 1,
      "message": "We want to avoid referencing it when L137 is called in another thread. The intent behind using a RWLock was so that L137 could take the lock if RefBaseSubclass is destroyed.",
      "parentUuid": "a36e1ecc_aa7aa711",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f3bccdd_59afaa1d",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T00:04:01Z",
      "side": 1,
      "message": "I feel refDeleted isn\u0027t needed here at all actually, since the thread should know whether it can dec/inc this class based on the local strong_count/weak_count only, regardless of what the other threads do, right?",
      "parentUuid": "9f01dfbf_a7bebed3",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b1774ac_658cfda8",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-18T00:13:47Z",
      "side": 1,
      "message": "I guess you\u0027re right actually. As long as this thread\u0027s strong/weak count are greater than zero the object should exist. Same goes for decrementing strong/weak at the end.",
      "parentUuid": "8f3bccdd_59afaa1d",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a1565a2_fb69d5a6",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T01:06:17Z",
      "side": 1,
      "message": "Yeah - then also make sure to store global weakref_type* getWeakRefs so that you can dec weak on this, if the RefBase object is already destroyed (instead of having to dereference ref-\u003egetWeakRefs..)",
      "parentUuid": "5b1774ac_658cfda8",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "05873441_e0614d8c",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "If we remove all weak refs before strong ones, there shouldn\u0027t be any remaining weak refs when the object is deleted, right?\nI\u0027ve done this regardless, just for good measure.",
      "parentUuid": "1a1565a2_fb69d5a6",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3062e259_84adcf59",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 142,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "unnecessary check, and L147, this is never set to nullptr",
      "range": {
        "startLine": 142,
        "startChar": 11,
        "endLine": 142,
        "endChar": 26
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6532dfa1_3309b705",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 142,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3062e259_84adcf59",
      "range": {
        "startLine": 142,
        "startChar": 11,
        "endLine": 142,
        "endChar": 26
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf4ed78c_a76596e6",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 151,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "this still leaks weak refs, should decrement all of the weak refs first (or hold onto getWeakRefs), and then decrement the strong refs, which could cause the object to get deleted.\n\nYou can check, but I would expect that L149 always gets hit?",
      "range": {
        "startLine": 149,
        "startChar": 0,
        "endLine": 151,
        "endChar": 9
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f0d1cc1_51a08467",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 151,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "I did see L149 hit, although refDeleted was not usually true. Regardless, will reverse the order here.",
      "parentUuid": "cf4ed78c_a76596e6",
      "range": {
        "startLine": 149,
        "startChar": 0,
        "endLine": 151,
        "endChar": 9
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9797fea_351ad343",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "this should be a fuzzer error, right?",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 185,
        "endChar": 5
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "694aae51_dfbb9ee3",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-23T23:05:48Z",
      "side": 1,
      "message": "Correct, this should never happen. Removing this check.",
      "parentUuid": "d9797fea_351ad343",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 185,
        "endChar": 5
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e990a38_0d68a699",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-24T19:04:32Z",
      "side": 1,
      "message": "nit: I meant, add, for instance \u0027LOG_ALWAYS_FATAL_IF(!refDeleted, \"ref should be deleted, leak?\")\u0027",
      "parentUuid": "694aae51_dfbb9ee3",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 185,
        "endChar": 5
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "51ec85c0_08b5947a",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-24T21:59:49Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "1e990a38_0d68a699",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 185,
        "endChar": 5
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2df2f5d3_5fed5045",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-25T22:14:09Z",
      "side": 1,
      "message": "I actually added this and found there\u0027s a case that isn\u0027t fuzzer error where this is legitimately not cleaned up, which is when no thread adds or removes references (such as with an empty input), meaning no logic is ever run to decrement weak or strong references, so the object is never deleted. To better resolve this, I think I\u0027ll store a global value for \"hasModifiedRefs\" that\u0027s set to false at the start of each run, but is then set to true if any operations modify refs. Then, after the threads are done I\u0027ll have a LOG_ALWAYS_FATAL_IF asserting the object either deleted or hasModifiedRefs is false, but not both, and manually delete refbase if hasModifiedRefs is false",
      "parentUuid": "51ec85c0_08b5947a",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 185,
        "endChar": 5
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "140bf48f_d0657e38",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-25T23:07:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2df2f5d3_5fed5045",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 185,
        "endChar": 5
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}