{
  "comments": [
    {
      "key": {
        "uuid": "ea599146_f3e4f358",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-08-11T20:31:45Z",
      "side": 1,
      "message": "Don\u0027t you still need compiler changes to make this workable? The compiler will need to know that min_sdk_version (to control things like omitting SysV hashes, enabling relr, etc), and needs to know sdk_version to control API visibility.",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86c1e8da_8cf3485d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-08-11T23:59:46Z",
      "side": 1,
      "message": "No, at least for now. Right now, for most of the modules, sdk_version is not set which means they are compiled with the latest (current) SDK. Since there is no API beyond the latest SDK, there is no need to be conditional about compileSdkVersion. If a symbol cannot be found at build-time, that\u0027s it. The module author probably has made a typo.\n\nFor the few (30+) modules that have sdk_version set, they seem to be happy with __ANDROID_API__ which now tracks minSdkVersion.\n\nThis will be needed only when a header from a library whose sdk_version is X is used by another library whose sdk_version is Y \u003c X. In this case, the exporter header is compiled with the less number of APIs than it was designed for. However, this is prohibited by the build system; it ensures that Y \u003e\u003d X.",
      "parentUuid": "ea599146_f3e4f358",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d86c9d5_5f317d9a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-08-12T21:22:54Z",
      "side": 1,
      "message": "I think I\u0027m missing something, so apologies if it seems like I\u0027m explaining the obvious below. If I\u0027m not, great! If I am it should make it more clear what bad assumption I\u0027ve made ðŸ˜Š\n\nHow are those modules targeting \"current\" ensuring that Clang and bionic don\u0027t enable features that aren\u0027t supported in their minSdkVersion?\n\nTo illustrate the point, Bionic started supporting ELF TLS in API 29, and Clang should be enabling that for any build 29+. iirc APEX only goes back to 29, but if it _did_ go back to 28 , how would `sdk_version: \"current\"` APEX modules prevent ELF TLS from being used?\n\nThat particular case is a hypothetical since both APEX and ELF TLS landed in the same version and there haven\u0027t been any new features that would cause this sort of problem added between 29 and now, but there will be more in the future, so this is a real problem that needs to be solved.\n\nThe fix is that APEX builds need to tell Clang their actual min_sdk_version. But those builds _also_ need to tell clang their sdk_version, because that\u0027s what `__attribute__((availability))` needs to operate on. Right now Clang thinks Android builds only have one API level, min_sdk_version, and that one version is used for both concepts.",
      "parentUuid": "86c1e8da_8cf3485d",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}