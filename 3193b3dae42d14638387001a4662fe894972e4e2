{
  "comments": [
    {
      "key": {
        "uuid": "ea599146_f3e4f358",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-08-11T20:31:45Z",
      "side": 1,
      "message": "Don\u0027t you still need compiler changes to make this workable? The compiler will need to know that min_sdk_version (to control things like omitting SysV hashes, enabling relr, etc), and needs to know sdk_version to control API visibility.",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86c1e8da_8cf3485d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-08-11T23:59:46Z",
      "side": 1,
      "message": "No, at least for now. Right now, for most of the modules, sdk_version is not set which means they are compiled with the latest (current) SDK. Since there is no API beyond the latest SDK, there is no need to be conditional about compileSdkVersion. If a symbol cannot be found at build-time, that\u0027s it. The module author probably has made a typo.\n\nFor the few (30+) modules that have sdk_version set, they seem to be happy with __ANDROID_API__ which now tracks minSdkVersion.\n\nThis will be needed only when a header from a library whose sdk_version is X is used by another library whose sdk_version is Y \u003c X. In this case, the exporter header is compiled with the less number of APIs than it was designed for. However, this is prohibited by the build system; it ensures that Y \u003e\u003d X.",
      "parentUuid": "ea599146_f3e4f358",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d86c9d5_5f317d9a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-08-12T21:22:54Z",
      "side": 1,
      "message": "I think I\u0027m missing something, so apologies if it seems like I\u0027m explaining the obvious below. If I\u0027m not, great! If I am it should make it more clear what bad assumption I\u0027ve made ðŸ˜Š\n\nHow are those modules targeting \"current\" ensuring that Clang and bionic don\u0027t enable features that aren\u0027t supported in their minSdkVersion?\n\nTo illustrate the point, Bionic started supporting ELF TLS in API 29, and Clang should be enabling that for any build 29+. iirc APEX only goes back to 29, but if it _did_ go back to 28 , how would `sdk_version: \"current\"` APEX modules prevent ELF TLS from being used?\n\nThat particular case is a hypothetical since both APEX and ELF TLS landed in the same version and there haven\u0027t been any new features that would cause this sort of problem added between 29 and now, but there will be more in the future, so this is a real problem that needs to be solved.\n\nThe fix is that APEX builds need to tell Clang their actual min_sdk_version. But those builds _also_ need to tell clang their sdk_version, because that\u0027s what `__attribute__((availability))` needs to operate on. Right now Clang thinks Android builds only have one API level, min_sdk_version, and that one version is used for both concepts.",
      "parentUuid": "86c1e8da_8cf3485d",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be94e05e_fca00c86",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-08-13T04:40:28Z",
      "side": 1,
      "message": "No. I always hear you and appreciate all of your inputs. ðŸ˜Š\n\nIn your hypothetical scenario, if the APEX had to support 28+, it should have set min_sdk_version to 28, which in turn have forced execs/libs in the APEX to have min_sdk_version that is \u003c\u003d 28. This min_sdk_version shall be used as the version suffix of the clang triple, and `__ANDROID_API__` as well. That should have controlled the enabling of ELF TLS as well. The execs/libs might have different sdk_version values (most of them would just use \u0027current\u0027), but that shouldn\u0027t affect the enabling of ELF TLS. If I am understanding go/android-elf-tls correctly, pre-29 platforms can\u0027t support binaries built with ELF TLS. So this should really be based off of min_sdk_version, not compileSdkVersion.\n\n\u003e But those builds _also_ need to tell clang their sdk_version, because that\u0027s what `__attribute__((availability))` needs to operate on.\n\nThis is the part that I don\u0027t understand. I have thought that the availability attribute should operate on min_sdk_version. With -target aarch64-linux-android30 (and of course with -Wunguarded-availability) the compiler doesn\u0027t require __builtin_available guard for the use of pre-30 APIs, but does mandate the guard for 30+ APIs. So, 30 should be from min_sdk_version. If it was from sdk_version (which in most cases is set to \u0027current\u0027) as is the case of now, no guard would have been required because 10000 \u003e\u003d any API. \n\nI am not aware of any case that the compiler need to understand compileSdkVersion and behave differently. In my understanding, compileSdkVersion just determines the headers and stub libraries that will be used for compilation/linkinig.",
      "parentUuid": "2d86c9d5_5f317d9a",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b10b38e_c5db8cc4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 25,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2020-08-13T06:40:45Z",
      "side": 1,
      "message": "Ah, I see where I was confused. I for some reason had gotten it into my head that we were trying to expose only the APIs between min_sdk_version and sdk_version as weak symbols, but leave anything past sdk_version as completely unavailable.\n\nYou\u0027re completely right, no need to do what I was saying if that\u0027s not a thing we need :) It doesn\u0027t appear `__attribute__((availability))` has support for that behavior anyway.",
      "parentUuid": "be94e05e_fca00c86",
      "range": {
        "startLine": 24,
        "startChar": 62,
        "endLine": 25,
        "endChar": 42
      },
      "revId": "3193b3dae42d14638387001a4662fe894972e4e2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}