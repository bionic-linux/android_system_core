{
  "comments": [
    {
      "key": {
        "uuid": "a5a4cb87_236f8a7e",
        "filename": "liblog/log_read.c",
        "patchSetId": 4
      },
      "lineNbr": 313,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-04-22T00:16:22Z",
      "side": 1,
      "message": "won\u0027t this cause trouble on loaded systems?",
      "revId": "696817d3524e2fb8bbbcc2ec3526f4383f789163",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "45b4efaf_4bd7395d",
        "filename": "liblog/log_read.c",
        "patchSetId": 4
      },
      "lineNbr": 313,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-22T00:31:16Z",
      "side": 1,
      "message": "Yes, it *may*, this is a heuristic. I chatted with Colin on this. We currently use 5ms for turnaround timing in other code when dealing with a UNIX domain socket. The write breakup is done inside the kernel (and not in user space on the sender side) and is part of the sk layers, and is not at the application level. We chose to up this to 20ms instead of 5ms here because experience has shown that when user space is involved, this is virtually guaranteed (scheduler, no hardware involvement, with a 100 value for HZ) as *poll* will also suffer pushback when the system is loaded and stretch user space. We may re-address the 5ms value we use elsewhere, but so far no bugs have been reported.\n\nKeep in mind that logcat -S output is currently a developer feature, and is *only* producing output in the 40KB range on first boot after a complete wipe. After a reboot, the statistics will not exceed 16KB even after running for a week (with dex2oat finished). The most important (interpreted) data is within the first 16KB in any case, the remainder is more for completeness of raw information than anything and this was an overly valiant effort to try to resolve getting truncated.",
      "parentUuid": "a5a4cb87_236f8a7e",
      "revId": "696817d3524e2fb8bbbcc2ec3526f4383f789163",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e5aa4352_654826ea",
        "filename": "liblog/log_read.c",
        "patchSetId": 4
      },
      "lineNbr": 313,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-22T00:34:05Z",
      "side": 1,
      "message": "BTW, I ran load, and had a sched_yield() here and that was enough to get the kernel to reload the pipe.",
      "parentUuid": "45b4efaf_4bd7395d",
      "revId": "696817d3524e2fb8bbbcc2ec3526f4383f789163",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}