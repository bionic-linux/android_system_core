{
  "comments": [
    {
      "key": {
        "uuid": "d7f6229d_85cd76cc",
        "filename": "adb/sysdeps_test.cpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2016-05-18T20:36:36Z",
      "side": 1,
      "message": "I like the idea of testing try_lock() after lock(), but this suggests that the behavior may be undefined:\n\nhttp://en.cppreference.com/w/cpp/thread/mutex/try_lock\n\nSomething to watch out for in case this test fails in the future?",
      "range": {
        "startLine": 253,
        "startChar": 17,
        "endLine": 253,
        "endChar": 29
      },
      "revId": "305254be60865e38b08a823d2fd9208f77eb1924",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d7f6229d_8096044c",
        "filename": "adb/sysdeps_test.cpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-05-18T21:21:40Z",
      "side": 1,
      "message": "Yeah, you\u0027re right. It seems that (at least my reading of) POSIX says that pthread_mutex_trylock has defined behavior in this case, so we can probably get away with it here?\n\n(Also noticed in reading the spec that destroying a mutex while it\u0027s held is UB, so fixed that.)",
      "parentUuid": "d7f6229d_85cd76cc",
      "range": {
        "startLine": 253,
        "startChar": 17,
        "endLine": 253,
        "endChar": 29
      },
      "revId": "305254be60865e38b08a823d2fd9208f77eb1924",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d7f6229d_20e3d0ed",
        "filename": "adb/sysdeps_test.cpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2016-05-18T21:25:37Z",
      "side": 1,
      "message": "I guess I meant that if the spec says that if lock+try_lock is UB, if you write a test to do that and even if it passes right now, in the future it might not pass and might crash or have general weirdness. So do you want to be on the hook for that in the future?, or just comment out that portion of the test. You guys are maintaining the code, so it\u0027s your call.",
      "parentUuid": "d7f6229d_8096044c",
      "range": {
        "startLine": 253,
        "startChar": 17,
        "endLine": 253,
        "endChar": 29
      },
      "revId": "305254be60865e38b08a823d2fd9208f77eb1924",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d7f6229d_808444e8",
        "filename": "adb/sysdeps_test.cpp",
        "patchSetId": 6
      },
      "lineNbr": 253,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2016-05-18T21:44:26Z",
      "side": 1,
      "message": "I think the try_locks in the tests are fine. I think the cppreference.com means try_lock can return false even if the lock is just released by other threads. But in L286, the try_lock is called just after m.lock(), I can\u0027t imagine any implementation can have it return false.",
      "parentUuid": "d7f6229d_20e3d0ed",
      "range": {
        "startLine": 253,
        "startChar": 17,
        "endLine": 253,
        "endChar": 29
      },
      "revId": "305254be60865e38b08a823d2fd9208f77eb1924",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}