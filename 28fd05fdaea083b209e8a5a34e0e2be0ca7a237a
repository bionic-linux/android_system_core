{
  "comments": [
    {
      "key": {
        "uuid": "d18c445d_e457734b",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-06T21:33:48Z",
      "side": 1,
      "message": "It\u0027s essential that this checks for an odd value; I didn\u0027t see that check anywhere else either.",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cecc1ff1_c06d6432",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-06T22:08:31Z",
      "side": 1,
      "message": "Actually, I believe the linked list can be still read safely despite the value being odd. (That is half of the point... For crashed process it will be always odd)\nIt means we can not reason the descriptors time stamp, but that is not needed for this use case. It is only needed for simple perf which can wait for even value.",
      "parentUuid": "d18c445d_e457734b",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa081bd4_bf8f52cf",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-06T22:55:08Z",
      "side": 1,
      "message": "Why will it always be odd for crashed processes? It will remain odd if the process crashed while writing the data structure, in which case the data structure is inconsistent, and we can make no guarantees. E.g. desc.first_entry could conceivably be half of one pointer, and half another. We can still try to read it on a best-effort basis, but we\u0027re well into heuristic territory. My strong intuition is that case needs to be handled separately; if it is useful to wait for a consistent snapshot, we almost certainly want to do that. But if the process is dead, we have to do the best we can.",
      "parentUuid": "cecc1ff1_c06d6432",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5838b5c9_23dc2f1f",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-07T13:08:43Z",
      "side": 1,
      "message": "It is unlikely, but it might be odd for crashed process. I meant that if it starts as odd, it will remain to be odd forever.\n\nThe data structure is semi-consistent. In particular, I believe first_entry can not be torn, and we can iterate over the whole linked list and access all ELF files without worry of reading inconsistent data.  On the other hand, we can not read the descriptor timestamp, and we don\u0027t know if we caught the first_entry before or after modification.  But, in this use case, this is enough.  Simpleperf has different requirements, and it will certainly want to wait for fully consistent (even) snapshot.\n\nMy intuition is the opposite - I would like to have just one code path which just works regardless of whether the process is making progress or not, and regardless whether we are doing the unwind in-process or out-of-process.  I think as soon as we start making guesses about the state of the process, adding timeouts, etc... we are getting tricky territory.",
      "parentUuid": "aa081bd4_bf8f52cf",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "020c9ae7_0bb09087",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-07T18:40:58Z",
      "side": 1,
      "message": "The C++ language allows first_entry to be torn. That\u0027s probably unlikely, given the ARM instruction set and alignment rules, but it\u0027s certainly allowed. And in fact some memcpy implementations do byte-by-byte copies on short structures. Certainly the backpointer in the first entry of the list can point to a node that\u0027s not reachable by forward traversal, or vice-versa, etc.\n\nThere is a substantial literature on obstruction-free and lock-free linked lists that are designed precisely to address this kind of issue, and keep the list usable at all times. This is not a correct algorithm to do that, nor do you probably want to use one of those here.\n\nA lot of this probably becomes easier if the list here is contiguous in memory, so it can be read with a single memcpy. I don\u0027t know whether that\u0027s a possibility.\n\nI think the rules for traversing this structure with an odd counter are fundamentally different. You can probably keep most of the code common. But I do think that a debugger wants to try quite hard to read a consistent version before proceeding with the odd counter. As a user, I\u0027d certainly be willing to wait for a one second timeout before taking the risk of garbled data.",
      "parentUuid": "5838b5c9_23dc2f1f",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8cf3f0e_db27938c",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-09T21:13:19Z",
      "side": 1,
      "message": "I am assuming that in practice reading or writting of an aligned pointer will be always atomic on all the architectures we care about. Hence I down\u0027t worry about it being torn.\n\nI don\u0027t care about memcpy being torn. Those must be always verified later by the (atomic) seqlock.\n\nThe linked list is only iterated from head forward, so the backpointer is irrelevant. \n\nSo I still argue that the algorithm, as written, is in practice safe.\n\n\nThe list could be made contiguous in memory (at least least allocated in blocks), but I don\u0027t see the benefit.\n\nI am worried about starting to put timeouts in.  I don\u0027t think potentially blocking in the backtrace for a second is acceptable.\n\nThe only thing that I somewhat worry about is the properties of process_vm_readv.  Plain old pointer read in process should be in-practice always atomic.  I am not sure if the same is true of process_vm_readv.  I would trust ptrace a bit more, but still, I can not find discussion of it online.",
      "parentUuid": "020c9ae7_0bb09087",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22bb55ff_68de44cc",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 237,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-06T22:55:08Z",
      "side": 1,
      "message": "Entry_addr was previously read from the seq_lock-protected data structure. That means the data structure it points to may be deallocated just before the SafeRead here, if there is a concurrent deleteJITCodeEntryInternal. This has nothing to do with fences or memory ordering. This means we always assume the the reader will not crash as a result of reading a bogus address? SafeRead is safe in the sense that it can\u0027t SEGV? If so, that\u0027s again a strong assumption on all readers that should be stated.\n\nIt seems to me that this is central here. If we have to avoid reader SEGV\u0027s, then I think we need a mechanism like hazard pointers to ensure that the writer doesn\u0027t deallocate anything we\u0027re still looking at, and we fundamentally need the writer to know about readers. At that point, some form of rwlock starts to look much more attractive to me. If the reader code is always safe against SEGVs, then I think we can make this logic work, though it\u0027s still really tricky to do it in a way that\u0027s at least mostly compatible with the C++ memory model.",
      "range": {
        "startLine": 237,
        "startChar": 4,
        "endLine": 237,
        "endChar": 70
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bc013e0f_2f3b3fd4",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 237,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-07T13:08:43Z",
      "side": 1,
      "message": "Correct, the reader needs to be safe from SEGVs, although I still don\u0027t think we need lock to achieve.\n\nlibunwind uses process_vm_readv for memory reading which I believe fails gracefully for unmmaped memory.\n\nanother alternative would be to just handle the SEGV, but that is not as neat.\n\nfinally, Chris is planning to wrap m(un)map for debug-malloc, which means if we run in-process we can synchronize between the read and munmap.",
      "parentUuid": "22bb55ff_68de44cc",
      "range": {
        "startLine": 237,
        "startChar": 4,
        "endLine": 237,
        "endChar": 70
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "188e7304_45563652",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 237,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-07T18:40:58Z",
      "side": 1,
      "message": "Good. That works, but needs to be documented.",
      "parentUuid": "bc013e0f_2f3b3fd4",
      "range": {
        "startLine": 237,
        "startChar": 4,
        "endLine": 237,
        "endChar": 70
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}