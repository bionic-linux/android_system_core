{
  "comments": [
    {
      "key": {
        "uuid": "d18c445d_e457734b",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-06T21:33:48Z",
      "side": 1,
      "message": "It\u0027s essential that this checks for an odd value; I didn\u0027t see that check anywhere else either.",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cecc1ff1_c06d6432",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-06T22:08:31Z",
      "side": 1,
      "message": "Actually, I believe the linked list can be still read safely despite the value being odd. (That is half of the point... For crashed process it will be always odd)\nIt means we can not reason the descriptors time stamp, but that is not needed for this use case. It is only needed for simple perf which can wait for even value.",
      "parentUuid": "d18c445d_e457734b",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa081bd4_bf8f52cf",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-06T22:55:08Z",
      "side": 1,
      "message": "Why will it always be odd for crashed processes? It will remain odd if the process crashed while writing the data structure, in which case the data structure is inconsistent, and we can make no guarantees. E.g. desc.first_entry could conceivably be half of one pointer, and half another. We can still try to read it on a best-effort basis, but we\u0027re well into heuristic territory. My strong intuition is that case needs to be handled separately; if it is useful to wait for a consistent snapshot, we almost certainly want to do that. But if the process is dead, we have to do the best we can.",
      "parentUuid": "cecc1ff1_c06d6432",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5838b5c9_23dc2f1f",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 217,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-07T13:08:43Z",
      "side": 1,
      "message": "It is unlikely, but it might be odd for crashed process. I meant that if it starts as odd, it will remain to be odd forever.\n\nThe data structure is semi-consistent. In particular, I believe first_entry can not be torn, and we can iterate over the whole linked list and access all ELF files without worry of reading inconsistent data.  On the other hand, we can not read the descriptor timestamp, and we don\u0027t know if we caught the first_entry before or after modification.  But, in this use case, this is enough.  Simpleperf has different requirements, and it will certainly want to wait for fully consistent (even) snapshot.\n\nMy intuition is the opposite - I would like to have just one code path which just works regardless of whether the process is making progress or not, and regardless whether we are doing the unwind in-process or out-of-process.  I think as soon as we start making guesses about the state of the process, adding timeouts, etc... we are getting tricky territory.",
      "parentUuid": "aa081bd4_bf8f52cf",
      "range": {
        "startLine": 215,
        "startChar": 2,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22bb55ff_68de44cc",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 237,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-06T22:55:08Z",
      "side": 1,
      "message": "Entry_addr was previously read from the seq_lock-protected data structure. That means the data structure it points to may be deallocated just before the SafeRead here, if there is a concurrent deleteJITCodeEntryInternal. This has nothing to do with fences or memory ordering. This means we always assume the the reader will not crash as a result of reading a bogus address? SafeRead is safe in the sense that it can\u0027t SEGV? If so, that\u0027s again a strong assumption on all readers that should be stated.\n\nIt seems to me that this is central here. If we have to avoid reader SEGV\u0027s, then I think we need a mechanism like hazard pointers to ensure that the writer doesn\u0027t deallocate anything we\u0027re still looking at, and we fundamentally need the writer to know about readers. At that point, some form of rwlock starts to look much more attractive to me. If the reader code is always safe against SEGVs, then I think we can make this logic work, though it\u0027s still really tricky to do it in a way that\u0027s at least mostly compatible with the C++ memory model.",
      "range": {
        "startLine": 237,
        "startChar": 4,
        "endLine": 237,
        "endChar": 70
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bc013e0f_2f3b3fd4",
        "filename": "libunwindstack/JitDebug.cpp",
        "patchSetId": 2
      },
      "lineNbr": 237,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-07T13:08:43Z",
      "side": 1,
      "message": "Correct, the reader needs to be safe from SEGVs, although I still don\u0027t think we need lock to achieve.\n\nlibunwind uses process_vm_readv for memory reading which I believe fails gracefully for unmmaped memory.\n\nanother alternative would be to just handle the SEGV, but that is not as neat.\n\nfinally, Chris is planning to wrap m(un)map for debug-malloc, which means if we run in-process we can synchronize between the read and munmap.",
      "parentUuid": "22bb55ff_68de44cc",
      "range": {
        "startLine": 237,
        "startChar": 4,
        "endLine": 237,
        "endChar": 70
      },
      "revId": "28fd05fdaea083b209e8a5a34e0e2be0ca7a237a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}