{
  "comments": [
    {
      "key": {
        "uuid": "ee42832d_227ab618",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 2
      },
      "lineNbr": 180,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-09T18:46:00Z",
      "side": 1,
      "message": "if timeout_ms is _zero_ then after disabling wakesources, go straight to \"mem\" \u003e /sys/powwr/state.",
      "range": {
        "startLine": 180,
        "startChar": 0,
        "endLine": 180,
        "endChar": 23
      },
      "revId": "20fc26c6fa896f31a320c014dc774fb7317cd330",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48c2e89f_42347426",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 2
      },
      "lineNbr": 185,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-09T18:46:00Z",
      "side": 1,
      "message": "CLOCK_REALTIME",
      "range": {
        "startLine": 185,
        "startChar": 18,
        "endLine": 185,
        "endChar": 33
      },
      "revId": "20fc26c6fa896f31a320c014dc774fb7317cd330",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cdddba1_cc67b5f9",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 2
      },
      "lineNbr": 190,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-09T18:46:00Z",
      "side": 1,
      "message": "We expect the caller has released, or is in the process of releasing (eg: driver or HAL completing an action), all wakelocks. We should not be actively releasing wakelocks (except a libsuspend one used for preventing autosuspend?). The whole idea of a relaxed autosuspend is to find an appropriate juncture for a clean-ish shutdown for when the activities have acquiesce, and if they take too long, then pull the rug.",
      "range": {
        "startLine": 190,
        "startChar": 22,
        "endLine": 190,
        "endChar": 35
      },
      "revId": "20fc26c6fa896f31a320c014dc774fb7317cd330",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62c0cb95_03efe404",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 2
      },
      "lineNbr": 194,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-09T18:46:00Z",
      "side": 1,
      "message": "This should be ahead of disabling wakesources because once we start doing that, an autosuspend would be considered ill-timed.\n\nIn the case of this being in a different process, holding a libsuspend wakelock would do the \u0027trick\u0027 of holding back autosuspend at least until we are ready to \u0027relax\u0027.",
      "range": {
        "startLine": 192,
        "startChar": 0,
        "endLine": 194,
        "endChar": 28
      },
      "revId": "20fc26c6fa896f31a320c014dc774fb7317cd330",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf596b51_83e0663f",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 2
      },
      "lineNbr": 207,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-09T18:46:00Z",
      "side": 1,
      "message": "If we time out, then I expect us to do an immediate force suspend; Errors notwithstanding.",
      "range": {
        "startLine": 205,
        "startChar": 0,
        "endLine": 207,
        "endChar": 9
      },
      "revId": "20fc26c6fa896f31a320c014dc774fb7317cd330",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "076e160f_ddca517c",
        "filename": "libsuspend/autosuspend_wakeup_count.cpp",
        "patchSetId": 2
      },
      "lineNbr": 261,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-01-09T18:46:00Z",
      "side": 1,
      "message": "This one disturbs me the most, since you could end up running multiple autosuspend threads, where there should only be one.\n\nAnd since you do not want to init routines, maybe you split the init to operate on an as-need basis (on first enable() call, or first force_suspend with a non-zero timeout). Maybe devote a cross-process flock() (/dev/libsuspend.lock, NB: not /dev/libsuspend.sem) to prevent multiple instances?",
      "range": {
        "startLine": 257,
        "startChar": 0,
        "endLine": 261,
        "endChar": 5
      },
      "revId": "20fc26c6fa896f31a320c014dc774fb7317cd330",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}