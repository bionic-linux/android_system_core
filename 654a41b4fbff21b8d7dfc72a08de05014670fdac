{
  "comments": [
    {
      "key": {
        "uuid": "aa1c9852_a03803ea",
        "filename": "include/netd_client/NetdClient.h",
        "patchSetId": 5
      },
      "lineNbr": 21,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "Not in alphabetical order.",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff281483_446aa7f7",
        "filename": "include/netd_client/NetdClient.h",
        "patchSetId": 5
      },
      "lineNbr": 21,
      "author": {
        "id": 1031429
      },
      "writtenOn": "2014-05-21T18:29:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aa1c9852_a03803ea",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f3f0cb7_5046ece0",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 93,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "You only took half of my recommendation.  You need ANDROID_MEMBAR_FULL() here.",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f58ec40_ce2d9785",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 93,
      "author": {
        "id": 1031429
      },
      "writtenOn": "2014-05-21T14:17:11Z",
      "side": 1,
      "message": "I don\u0027t see the need for a memory barrier here.\n\nAs far as I understand, a memory barrier ensures that the compiler/CPU will not reorder loads/stores across it. Within this context, there are no other independent global loads/stores anyway.\n\nPerhaps your concern is that you want other threads/CPUs to see the effects of the change immediately? I.e., maybe there\u0027s a chance that the store will remain in the local CPU\u0027s store-buffer indefinitely and never make it to the caches / main memory?\n\nFirst, if another CPU tries to read the variable, cache coherency guarantees that it will see the correct value. There\u0027s no chance that it will use an older value.\n\nSecond, a memory barrier doesn\u0027t guarantee that the store-buffer is flushed anyway. References:\nhttp://www.freebsd.org/doc/en/books/arch-handbook/smp-lock-fundamentals.html: \"a memory barrier does not force the contents of a CPU\u0027s local cache or store buffer to flush\"\nhttp://www.rdrop.com/~paulmck/scalability/paper/whymb.2009.04.05a.pdf: \" it could use the store buﬀer to hold subsequent stores until all of the prior entries in the store buﬀer had been applied.\"\n\nOr perhaps your concern is that there is some other store operation in the caller\u0027s context which should be guaranteed to occur after the operation here? So, something like this:\n\n    // thread 1\n    setNetworkForProcess(...);\n    flag \u003d 1;\n\n    // thread 2\n    if (flag) {\n        // depend on netIdForProcess being up-to-date\n\nSo, without a memory barrier, it\u0027s possible that the flag gets updated first, before netIdForProcess. But this argument doesn\u0027t hold water, because:\n1. We have no obligation to imagine that this is possible and support it. Otherwise, this reduces to saying that any library function that performs any global store must immediately then apply a memory barrier. And conversely, that if it reads any global store, it must first apply a barrier prior to the load.\n2. The caller needs to synchronize access to the flag anyway. So, they are going to need a store-release in thread 1, and an acquire-load in thread 2. So, that provides the necessary barrier/synchronization.",
      "parentUuid": "3f3f0cb7_5046ece0",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f3504d1_fc513691",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 93,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-21T19:33:02Z",
      "side": 1,
      "message": "I\u0027m fine without the memory-barrier.  I agree with much of your logic.  I still feel a memory barrier would make this function more correct if one assumes it\u0027s definition to be that once the function has returned its affect is in place.   Assuming the awesome cache coherency of modern processors I feel people assume when a function completes that it\u0027s effect is heard on all cores.  Without the memory-barrier the divergence from strict adherence to this definition is minimal, so I\u0027m fine with continuing without the memory barrier.\n\nLet me explain with a little example of where a memory barrier would make things more correct given these definitions:\n\nTwo networks connect almost simultaneously.  Two threads call setNetworkForBlah() almost simultaneously to begin using these new networks.  After calling setNetworkForBlah() these two threads immediately read some hardware clock using a load instruction.  These two threads write to a log something along the lines of \"started using network X at time Y\".  Later analysis of the log assumes that things happening at later times overrule older events, so we might attribute all traffic to the last network selected.  The problem is without strict ordering of loads and stores the load of the timer may be swapped with the store to the netId, in which case we might attribute all traffic to the wrong network.\n\nAnyhow, yes, my test case is contrived and someone would be silly to not use locking or some other more proper synchronization, but a memory barrier is a simple way to not necessarily enforce that by the time the function has returned that the change has taken place, but to enforce that the by the perceivable time (i.e. reading from a clock) the functions has returned that the change has taken place.\n\nAnother way to look at this is:  If the netId were a larger struct such that it couldn\u0027t fit in sig_atomic_t, some locking would have to be used to access it, in which case the release of the lock would guarantee the ordering that a memory barrier would provide in this implementation.",
      "parentUuid": "3f58ec40_ce2d9785",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f8344c5_16b14ce4",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 93,
      "author": {
        "id": 1031429
      },
      "writtenOn": "2014-05-21T20:05:19Z",
      "side": 1,
      "message": "Thanks for the detailed response. As we discussed and agreed offline, we\u0027ll go without the barrier for now.\n\nRe: the point in your last paragraph, I agree. I\u0027ve added a TODO to convert \"volatile sig_atomic_t\" to std::atomic\u003c\u003e. Conveniently, std::atomic\u003c\u003e works for any POD type, and not just primitive types, so that\u0027s definitely the right way to go for the future.",
      "parentUuid": "7f3504d1_fc513691",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aa1c9852_803b07e6",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "Ditto.",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf4bfc72_84bd46f2",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1031429
      },
      "writtenOn": "2014-05-21T18:29:10Z",
      "side": 1,
      "message": "ditto :)",
      "parentUuid": "aa1c9852_803b07e6",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f3f0cb7_b05e38a0",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 138,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "How come we don\u0027t have legitimate types for this?  Like:\ntypedef struct {\n  uint8_t command;\n} NetdCommandHeader;\ntypedef struct {\n  NetdCommandHeader header;\n  unsigned netId;\n} NetdNetForSocketCommand;",
      "range": {
        "startLine": 137,
        "startChar": 4,
        "endLine": 138,
        "endChar": 44
      },
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf4bfc72_04803637",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 138,
      "author": {
        "id": 1031429
      },
      "writtenOn": "2014-05-21T18:29:10Z",
      "side": 1,
      "message": "Done. To avoid proliferation of data types for each command, I\u0027ve coalesced the types into a single command, with a note that the netId argument is ignored for all but one. This also makes it easy on the receiving side to receive data of that type directly, instead of going through a char[] buffer.",
      "parentUuid": "3f3f0cb7_b05e38a0",
      "range": {
        "startLine": 137,
        "startChar": 4,
        "endLine": 138,
        "endChar": 44
      },
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}