{
  "comments": [
    {
      "key": {
        "uuid": "aa1c9852_a03803ea",
        "filename": "include/netd_client/NetdClient.h",
        "patchSetId": 5
      },
      "lineNbr": 21,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "Not in alphabetical order.",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f3f0cb7_5046ece0",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 93,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "You only took half of my recommendation.  You need ANDROID_MEMBAR_FULL() here.",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f58ec40_ce2d9785",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 93,
      "author": {
        "id": 1031429
      },
      "writtenOn": "2014-05-21T14:17:11Z",
      "side": 1,
      "message": "I don\u0027t see the need for a memory barrier here.\n\nAs far as I understand, a memory barrier ensures that the compiler/CPU will not reorder loads/stores across it. Within this context, there are no other independent global loads/stores anyway.\n\nPerhaps your concern is that you want other threads/CPUs to see the effects of the change immediately? I.e., maybe there\u0027s a chance that the store will remain in the local CPU\u0027s store-buffer indefinitely and never make it to the caches / main memory?\n\nFirst, if another CPU tries to read the variable, cache coherency guarantees that it will see the correct value. There\u0027s no chance that it will use an older value.\n\nSecond, a memory barrier doesn\u0027t guarantee that the store-buffer is flushed anyway. References:\nhttp://www.freebsd.org/doc/en/books/arch-handbook/smp-lock-fundamentals.html: \"a memory barrier does not force the contents of a CPU\u0027s local cache or store buffer to flush\"\nhttp://www.rdrop.com/~paulmck/scalability/paper/whymb.2009.04.05a.pdf: \" it could use the store buﬀer to hold subsequent stores until all of the prior entries in the store buﬀer had been applied.\"\n\nOr perhaps your concern is that there is some other store operation in the caller\u0027s context which should be guaranteed to occur after the operation here? So, something like this:\n\n    // thread 1\n    setNetworkForProcess(...);\n    flag \u003d 1;\n\n    // thread 2\n    if (flag) {\n        // depend on netIdForProcess being up-to-date\n\nSo, without a memory barrier, it\u0027s possible that the flag gets updated first, before netIdForProcess. But this argument doesn\u0027t hold water, because:\n1. We have no obligation to imagine that this is possible and support it. Otherwise, this reduces to saying that any library function that performs any global store must immediately then apply a memory barrier. And conversely, that if it reads any global store, it must first apply a barrier prior to the load.\n2. The caller needs to synchronize access to the flag anyway. So, they are going to need a store-release in thread 1, and an acquire-load in thread 2. So, that provides the necessary barrier/synchronization.",
      "parentUuid": "3f3f0cb7_5046ece0",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aa1c9852_803b07e6",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 106,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "Ditto.",
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f3f0cb7_b05e38a0",
        "filename": "libnetd_client/NetdClient.cpp",
        "patchSetId": 5
      },
      "lineNbr": 138,
      "author": {
        "id": 1016583
      },
      "writtenOn": "2014-05-20T10:59:55Z",
      "side": 1,
      "message": "How come we don\u0027t have legitimate types for this?  Like:\ntypedef struct {\n  uint8_t command;\n} NetdCommandHeader;\ntypedef struct {\n  NetdCommandHeader header;\n  unsigned netId;\n} NetdNetForSocketCommand;",
      "range": {
        "startLine": 137,
        "startChar": 4,
        "endLine": 138,
        "endChar": 44
      },
      "revId": "654a41b4fbff21b8d7dfc72a08de05014670fdac",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}