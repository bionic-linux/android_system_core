{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "598d2bfe_547c0953",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_format.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2021-03-31T05:01:18Z",
      "side": 1,
      "message": "Why do we need this pre-reserved scratch space, vs putting a 2MB run within data like kCowReplaceOp does?",
      "revId": "ee99faf7cd2dbd9a08030c045cf430724e377ac2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77d0c18b_9faf5294",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_format.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1724998
      },
      "writtenOn": "2021-03-31T05:30:19Z",
      "side": 1,
      "message": "Probably the next patch will add more clarity to it on why we need this scratch space; but here is some explanation:\n\n1: We will mmap this entire region of memory and will explicitly be used by one thread in this region - both read and writes go onto this region.\n\n2: I didn\u0027t want to mess with the existing data section of the COW. The region is not meant to be touched by worker threads.\n\n3: There is very minimal change in the parsing logic.\n\nProbably all of this could be done on the run - something like how kCowClusterOps operation is added while writes are going on and is transparent to update-engine. However, I would like to know what is the drawback of having this scratch space than squeezing somewhere in the COW file on the run ?",
      "parentUuid": "598d2bfe_547c0953",
      "revId": "ee99faf7cd2dbd9a08030c045cf430724e377ac2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04c0e562_81bb7b69",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_format.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2021-03-31T20:26:46Z",
      "side": 1,
      "message": "The drawback is it makes the format more idiosyncratic. If inlined into data, no parsing changes are needed since it\u0027d fit into the existing structure. Whereas if hardcoded at the beginning, ParseOps(), InitPos(), and AddOperation() all get more special cases. It\u0027s true it\u0027s not huge in LoC but the complexity of the format is getting high. Especially if we ever want to change the buffer size, it looks like it could get dicey.\n\nI _think_ with inlining, and putting the buffer op first in the first cluter, we\u0027d get:\n\n[Header][Cluster #1][2MB BUFFER][Data for Cluster #1 Replace Ops][Cluster#2]...\n\nWhich is pretty similar structurally, just with less parsing changes needed.",
      "parentUuid": "77d0c18b_9faf5294",
      "revId": "ee99faf7cd2dbd9a08030c045cf430724e377ac2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aceea3dc_781bfb25",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_format.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1045980
      },
      "writtenOn": "2021-04-02T00:08:55Z",
      "side": 1,
      "message": "I need to go through the patch in more detail, but if we\u0027re making that section act more like the other data areas, we\u0027ll want to add it to IsMetadataOp, so the readers and stuff that don\u0027t care about that sort of stuff don\u0027t see it.",
      "parentUuid": "04c0e562_81bb7b69",
      "revId": "ee99faf7cd2dbd9a08030c045cf430724e377ac2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b2d76bd_b565f1f3",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_format.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 1724998
      },
      "writtenOn": "2021-04-02T00:25:16Z",
      "side": 1,
      "message": "Yeah.. My idea was to avoid adding that to ops_ buffer when parsing in ParseOps(); in that way, none of the readers will every encounter this buffer and only one thread (read-ahead therad) will just read this op.\n\nBut I get the consistency aspect as mentioned by David. \n\nOne of the other point of having this upfront is that I pack the header and the new buffer op into a single 4k page - This is required when flushing the data to scratch space. This was carefully crafted as the order of operation is important. That logic is in next patch - \n\nhttps://android-review.googlesource.com/c/platform/system/core/+/1656315/3\n\nLook for function:\n\nbool Snapuserd::ReadAheadIOCompleted()\n\n--------\n\nI will have to re-visit to see how it impacts that logic with the above change in\nthe COW format.",
      "parentUuid": "aceea3dc_781bfb25",
      "revId": "ee99faf7cd2dbd9a08030c045cf430724e377ac2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}