{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8064a035_072c4aff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2022-02-24T00:21:34Z",
      "side": 1,
      "message": "How do we make this test repeatable?",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a98e5b53_503eec1d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1724998
      },
      "writtenOn": "2022-02-24T00:34:08Z",
      "side": 1,
      "message": "We need fault injection. There are couple of ways to do this:\n\n1: We can have a socket call \"fail-merge\", wherein when merge is in-progress, client can invoke the socket call; snapuserd daemon will then fail the merge and fall back. I am working on this test case and will update it as a separate CL. For now, this has been tested by explicitly injecting the fault by instrumenting in the actual OTA path.",
      "parentUuid": "8064a035_072c4aff",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "61c67d32_2be0ab73",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 24,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2022-02-24T05:17:14Z",
      "side": 1,
      "message": "sgtm, as long as we don\u0027t forget to do it.",
      "parentUuid": "a98e5b53_503eec1d",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "005c745a_67ae8b6b",
        "filename": "fs_mgr/libsnapshot/cow_reader.cpp",
        "patchSetId": 2
      },
      "lineNbr": 605,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2022-02-24T00:21:34Z",
      "side": 1,
      "message": "How does the caller know when it\u0027s safe to call Prev? (eg, \"Done\" only works in one direction)",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1bdf8e17_62f12a92",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_reader.h",
        "patchSetId": 2
      },
      "lineNbr": 104,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2022-02-24T00:21:34Z",
      "side": 1,
      "message": "This should be pure virtual?",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcf8fb88_715fe446",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_reader.h",
        "patchSetId": 2
      },
      "lineNbr": 104,
      "author": {
        "id": 1724998
      },
      "writtenOn": "2022-02-24T00:34:08Z",
      "side": 1,
      "message": "There is no need to implement this for other classes. Only the Merge Iterator is the one which actually needs it.",
      "parentUuid": "1bdf8e17_62f12a92",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ba05dc40_1347027a",
        "filename": "fs_mgr/libsnapshot/include/libsnapshot/cow_reader.h",
        "patchSetId": 2
      },
      "lineNbr": 104,
      "author": {
        "id": 1724998
      },
      "writtenOn": "2022-02-24T02:19:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bcf8fb88_715fe446",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1738354_e7f11e77",
        "filename": "fs_mgr/libsnapshot/snapuserd/user-space-merge/snapuserd_merge.cpp",
        "patchSetId": 2
      },
      "lineNbr": 455,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2022-02-24T00:21:34Z",
      "side": 1,
      "message": "A \"rewind\" style API might be more appropriate here",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8afa4b50_de06faf8",
        "filename": "fs_mgr/libsnapshot/snapuserd/user-space-merge/snapuserd_merge.cpp",
        "patchSetId": 2
      },
      "lineNbr": 462,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2022-02-24T00:21:34Z",
      "side": 1,
      "message": "This control flow is kind of confusing. In four branches there are two breaks, an implicit continue, and a return. Pulling it out into a helper function would probably help, since then you could early return if the async merge succeeds. But maybe there is some other way to organize this.",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a9a24e2_8a2e7ec7",
        "filename": "fs_mgr/libsnapshot/snapuserd/user-space-merge/snapuserd_merge.cpp",
        "patchSetId": 2
      },
      "lineNbr": 462,
      "author": {
        "id": 1724998
      },
      "writtenOn": "2022-02-24T02:19:42Z",
      "side": 1,
      "message": "Re-structure the flow.. Hope it is easy now.",
      "parentUuid": "8afa4b50_de06faf8",
      "revId": "85ef10bf40febe63d0f96bf79362a0e125177989",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}