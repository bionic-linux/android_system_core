{
  "comments": [
    {
      "key": {
        "uuid": "9f2d2ef3_479a72d2",
        "filename": "libziparchive/zip_archive.cc",
        "patchSetId": 1
      },
      "lineNbr": 1382,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-04-07T15:39:16Z",
      "side": 1,
      "message": "ExtractToWriter is private, so you could just make it take a unique_ptr?",
      "range": {
        "startLine": 1382,
        "startChar": 41,
        "endLine": 1382,
        "endChar": 53
      },
      "revId": "9f1f3c5c1e1ed14fdd5ebf37d7f2887a12f152b9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f15a0d2_764d11d6",
        "filename": "libziparchive/zip_archive_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 510,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-04-07T15:39:16Z",
      "side": 1,
      "message": "should this be allowed, or should we actually fail in cases where the provided buffer is too small? looking at a selection of callers in cs/, it seems like we\u0027d hide their bug --- a bug which isn\u0027t likely right now, but is potentially more likely when we\u0027re supporting zip64 (though admittedly only for files that are unrealistically large to want to extract to memory).",
      "revId": "9f1f3c5c1e1ed14fdd5ebf37d7f2887a12f152b9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c652f253_aa771025",
        "filename": "libziparchive/zip_archive_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 510,
      "author": {
        "id": 1088085
      },
      "writtenOn": "2020-04-07T17:59:32Z",
      "side": 1,
      "message": "We actually have the check and fail the creation if (declared_length \u003e size). The L510 is valid since buffer size 1 \u003e entry size 0. And it\u0027s a special edge case for buffer size 0 \u003d entry size 0.",
      "parentUuid": "2f15a0d2_764d11d6",
      "revId": "9f1f3c5c1e1ed14fdd5ebf37d7f2887a12f152b9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0313bd2a_303099b8",
        "filename": "libziparchive/zip_archive_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 510,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2020-04-07T18:14:36Z",
      "side": 1,
      "message": "ah, okay, in that case just add comments before these ExtractToMemory calls to make it clearer what exactly they\u0027re testing. (i didn\u0027t guess that, despite the assert on line 508.)\n\nshould we allow the uint8_t* to be nullptr if size \u003d\u003d 0, like the libc mem* functions do? (and add an explicit test for that?)\n\nalso, why is the static_cast on L508 to unit32_t for a ZipEntry64? shouldn\u0027t it be a 64-bit type?",
      "parentUuid": "c652f253_aa771025",
      "revId": "9f1f3c5c1e1ed14fdd5ebf37d7f2887a12f152b9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6548999a_01e9b120",
        "filename": "libziparchive/zip_archive_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 510,
      "author": {
        "id": 1088085
      },
      "writtenOn": "2020-04-07T18:28:51Z",
      "side": 1,
      "message": "re L508, looks like old code haven\u0027t been changed..\n\nactually std::vector\u003cuint8_t\u003e vec_buf(uncompressed_length) creates a nullptr if uncompressed_length is 0. I am mimicking the real use case here. Probably I should explicitly say nullptr?",
      "parentUuid": "0313bd2a_303099b8",
      "revId": "9f1f3c5c1e1ed14fdd5ebf37d7f2887a12f152b9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}