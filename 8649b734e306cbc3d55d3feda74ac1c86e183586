{
  "comments": [
    {
      "key": {
        "uuid": "184c3426_84a1e871",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 550,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-05-30T17:45:44Z",
      "side": 1,
      "message": "MS_MOVE works on full subtrees, so you probably need to prune grand-child mounts and only move the direct descendants of the parent mount.  Though, likely not a case we\u0027ll see often (or at all hopefully).\n\nAlso means that the direction of handling the submounts doesn\u0027t matter, since they\u0027ll by definition be disjoint.",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a9ee037_debc5593",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 550,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-05-30T21:09:37Z",
      "side": 1,
      "message": "Good to know.\n\nChanging this code to prune was uglier IMHO and the only difference it made was we did not have to carefully craft our order below: from move.rbegin()) for unroll, and from move.cbegin() for roll. It did mean we track more mounts to move (unroll) and back (roll). I feel we could opt for less complexity and not prune.\n\nBut, if you feel that the pruning of the grand-children is a welcome efficiency, and makes it less fragile (eg: some future self reverses unroll) then I will add something like:\n\n    for (const auto\u0026 entry : fstab) {\n-        if (android::base::StartsWith(entry.mount_point, mount_point + \"/\")) {\n-            move.emplace_back(entry.mount_point);\n-        }\n+        auto less_specific \u003d [\u0026entry](const std::string\u0026 mount_point) {\n+            return android::base::StartsWith(entry.mount_point, mount_point + \"/\");\n+        };\n+        if (!less_specific(mount_point)) continue;\n+        auto more_specific \u003d [\u0026entry](const std::string\u0026 mount_point) {\n+            return android::base::StartsWith(mount_point, entry.mount_point + \"/\");\n+        };\n+        move.erase(remove_if(move.begin(), move.end(), more_specific), move.end());\n+        if (std::find_if(move.begin(), move.end(), less_specific) !\u003d move.end()) continue;\n+        move.emplace_back(entry.mount_point);\n     }\n\nLooking for your feedback (especially if you have a better idea for pruning), as this is a grey area for maintenance.",
      "parentUuid": "184c3426_84a1e871",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d67268ba_d0fae6c4",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 550,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-05-30T22:51:24Z",
      "side": 1,
      "message": "Hm, do we need to check for more specific mount points and erase them?  If the current code assumes that /proc/mounts goes from least specific to more specific, then we can make that assumption here too, right?  Otherwise, if we don\u0027t want to rely on that, then we definitely don\u0027t want to rely on going through the mounts backwards doing the right thing in the current code.\n\nAlso, we can swap the checks for less specific and the erasing of more specific entries if that makes the code slightly cleaner; figure if there\u0027s a less specific entry in the vector, then it would already have cleared out the more specific entries.\n\nI think it\u0027s better if we do the prune first still.  It\u0027ll segment this into two overall simpler pieces, and the pruning is separately unit testable if we\u0027re worried about the complexity of that operation.",
      "parentUuid": "9a9ee037_debc5593",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ece1907_b4a7a92d",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 550,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-05-31T00:22:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d67268ba_d0fae6c4",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a53a116_b4482400",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 557,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-05-30T17:45:44Z",
      "side": 1,
      "message": "No reason to clear this here; might as well let it deallocate when it goes out of scope?",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "750000a6_a116f1bd",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 557,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-05-30T21:09:37Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "5a53a116_b4482400",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9bfd94c5_631b43a9",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-05-30T17:45:44Z",
      "side": 1,
      "message": "Is it only the parent that we need to be concerned about, or all parents?  Or can we assume that we\u0027re not going to worry this case?",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20ab59ea_b16b02b6",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-05-30T21:09:37Z",
      "side": 1,
      "message": "The direct parent is all that is checked in the kernel it appears. I confirmed experimentally in that / (SHARED) has /vendor (marked PRIVATE) which has /vendor/firmware_mnt (this one being moved)",
      "parentUuid": "9bfd94c5_631b43a9",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "64a4068a_b664de3f",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-05-30T22:51:24Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "20ab59ea_b16b02b6",
      "revId": "8649b734e306cbc3d55d3feda74ac1c86e183586",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}