{
  "comments": [
    {
      "key": {
        "uuid": "095ca04f_9ea4fb67",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-04-04T23:27:00Z",
      "side": 1,
      "message": "Is that actually what the shell does?  I don\u0027t see that in the few commands that I ran.\n\nIn any case, I\u0027d rather not bake this in.  I almost wish we hadn\u0027t had a string for command for the API into liblogcat.  We could have had a LogcatCommand class where users filled out the information they wanted explicitly with setters.  It would have prevented the need for getopt_long_r() and been much more intuitive in situations like this.",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9984de0_69da1d94",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-04-05T16:09:16Z",
      "side": 1,
      "message": "Just reporting rationalization for possible tacit approval. Does not mean I am tied to this form.\n\nI wanted it to look like the same call signature as android::base::ReadXXXXToString\n\nI needed _something_ to be _guaranteed_ in the output stream for callers to determine if the error was catastrophic, or from an error return from the command execution. If the command had _no_ output (stdout or stderr) and an error return value then we have an issue in callers that wish to differentiate command success or failure. I did not want to complicate the argument list more because _most_ (of the hundreds of possible) of callers do not care. content.empty() thus differentiates catastrophic unexpected failure from return code; with the added benefit if they want to expand on the return code, it is in the data stream in an easy-to-parse form (last character is a \u0027|\u0027), but that is not the point (and probably should be dropped as an API).\n\nI _should_ have stated in the comment something like if the command was spawned and reported an error code in execution, that A) function returns false and B) that content.empty() is guaranteed to return false _only_ if \"2\u003e\u00261\" redirection has been added to the command string. If some other system error prevented execution, that A) function returns false and B) that content.empty() returns true.\n\nFYI: each additional argument costs roughly 45ns in overlead.\n\n$ adb $H1 shell\nhikey:/ $ false\n1|hikey:/ $\n\nAnd there you see \"\\n1|\" in the output from the shell ...",
      "parentUuid": "095ca04f_9ea4fb67",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "29883b61_90b717a3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-04-05T18:11:43Z",
      "side": 1,
      "message": "\u003e I did not want to complicate the argument list more because _most_ (of the hundreds of possible) of callers do not care.\n\nOne optional parameter (let them set it to nullptr) doesn\u0027t complicate the argument list, especially not compared to the explicitly complicated interface of asking callers to add a 2\u003e\u00261 and then asking them to parse the output string to get the retval.\n\nAre there really hundreds of possible callers for this?  How many processes call logcat in this way?  I\u0027d be interested in seeing which ones besides the obvious (dumpstate, bootstat).\n\n\u003e FYI: each additional argument costs roughly 45ns in overlead.\n\nThis is orders of magnitude lower than anything we should care about.\n\n\u003e And there you see \"\\n1|\" in the output from the shell ...\n\nI guess that only happens for non-zero retval.  It also happens with or without 2\u003e\u00261, so that makes this an even more confusing option.",
      "parentUuid": "d9984de0_69da1d94",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d61b94bc_87f2ae60",
        "filename": "logcat/file.cpp",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-04-04T23:27:00Z",
      "side": 1,
      "message": "Perhaps we just have an int* retval as a parameter and fill it out as long as we didn\u0027t get a nullptr for input?\n\nThen this function itself can return whether or not the popen() succeeded and *retval will be the result of the actual logcat command.",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a7264a4_4f4977c5",
        "filename": "logcat/file.cpp",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-04-05T16:09:16Z",
      "side": 1,
      "message": "I\u0027ll can buy that, but then the jni gets correspondingly uglier too (where each parameter requires considerable more overhead to process). If I follow w/o a retval and encode the string accordingly, then jni call pattern is roughly the same as the ReadLogcatToString call pattern.\n\nThe jni returns a string, and additional parameter references are an anti-pattern.\n\nHowever we can return nullptr as the error return.\n\nBut that does not deal with partial return, which for logcat is very important.",
      "parentUuid": "d61b94bc_87f2ae60",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63761e33_d6a0869a",
        "filename": "logcat/file.cpp",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-04-05T18:11:43Z",
      "side": 1,
      "message": "What JNI users are there for this?  \n\nCan we return a data class with both the string and the int?  That seems to be the most \u0027java-esque\u0027 pattern here.",
      "parentUuid": "2a7264a4_4f4977c5",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "336c3789_32567a90",
        "filename": "logcat/file.cpp",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-04-05T18:24:21Z",
      "side": 1,
      "message": "https://www.youtube.com/watch?v\u003dKBKXu3Kg4yg\n\nAll java, C or C++ users that pipe/fork/exec the logcat executable currently need to transition to liblogcat.so (see the associated bugs).\n\nThe alternative is to use the (Java/C++/C) log reader interface (introduced in L) and process the binary event data directly.\n\nIt is considered a security issue to use exec as an API.\n\nAs for return value, I want this to be KISS since we expect to replace executeShellCommand, runShellCommand (or open-coded equivalents that are littered throughout our codebase) with executeLogcatCommand with runLogcatCommand respectively; I want the cleanup to be near effortless and fluid.",
      "parentUuid": "63761e33_d6a0869a",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99aa9f5b_2805d823",
        "filename": "logcat/file.cpp",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-04-05T18:29:24Z",
      "side": 1,
      "message": "\u003e As for return value, I want this to be KISS since we expect to replace executeShellCommand, runShellCommand (or open-coded equivalents that are littered throughout our codebase) with executeLogcatCommand with runLogcatCommand respectively; I want the cleanup to be near effortless and fluid.\n\nThis is the wrong goal to me.  I\u0027d rather spend the effort up front to convert people from executeShellCommand() to a new future looking interface than do what\u0027s easier now at the cost of future maintenance.  Like I said earlier, we wouldn\u0027t have ever needed getopt_long_r() if we had a more traditional interface where users create a LogcatCommand class, specific the options they want, then get the options to .Run(), .RunInThread(), etc it.  They could then query the string result, int retval, etc through other accessors as well.",
      "parentUuid": "336c3789_32567a90",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ca08e8a_a9658c48",
        "filename": "logcat/file.cpp",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-04-05T18:31:07Z",
      "side": 1,
      "message": "NB: The art folks have created FastNative@ and CriticalNative@ class of calls to improve performance. Using a clazz to collect/return a data class is considered somewhat expensive by these standards. Although I will be using the JNIEnv native parameter anyways, so it looks like I can not use either of these faster native calls for this new interface (still learning from \u0027em in my trial balloon https://android-review.googlesource.com/c/platform/frameworks/base/+/656830)",
      "parentUuid": "336c3789_32567a90",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d53c789_7bea8fa1",
        "filename": "logcat/file.cpp",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-04-05T18:35:23Z",
      "side": 1,
      "message": "Are any of these callers in performance critical sections of code?  Are these JNI performance deltas in the same order of magnitude as the logcat commands themselves?\n\nI\u0027m assuming not and if so, I\u0027d rather focus on creating a clean API than these small performance deltas.",
      "parentUuid": "9ca08e8a_a9658c48",
      "revId": "a0a8f3fcf98af53cba6afad131e5ec7715eb56b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}