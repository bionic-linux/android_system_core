{
  "comments": [
    {
      "key": {
        "uuid": "4fc107ba_642e0223",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "Why limit to squashfs?",
      "range": {
        "startLine": 17,
        "startChar": 34,
        "endLine": 17,
        "endChar": 42
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "23a246a6_c1579066",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "Because that is the primary use case that needs to be supported automatically.\n\nWe have additional CLs to add other automatic selection use cases. Additional CLs add the ability to force or disable.",
      "parentUuid": "4fc107ba_642e0223",
      "range": {
        "startLine": 17,
        "startChar": 34,
        "endLine": 17,
        "endChar": 42
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2940324_bb1fb6ba",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 23,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "Would it not be easier to mandate that the fstab entry includes upperdir, lowerdir, and workdir instead of trying to figure this out automatically?  I think it\u0027d be better to have marginally more specification in the fstab, which would reduce this code size and make the overlayfs mount deterministic.",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac9da48a_2ff53fe6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 23,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "The first reason I came up with having the entries specified is that there are 5 possible overlayfs mounts, a number that may increase over time (they added /product last release), each has an option of three possible upper and workdir locations (two on most practical installation, but three on Logical resizable partition). Adding 15 overlayfs entries to the fstab to enable a moderately esoteric debug-only feature places a lot of burden on the default use case.\n\nAll the entries are to be discarded on a \"user\" build, we have no mechanism for doing so.\n\nActually, there is no use case for overriding them IMHO. But I would be remiss in not being able to allow a means to override them ;-/ for those that want determinism.\n\nI have discovered determinism is a goal that is counter to bootability in a development environment. What if /cache (always smaller) can be mounted, but /data (larger) can not, then what do we do to allow an adb remount + reboot cycle? I should really split all the code that reads the fstab for overlayfs and add them in later CLs, but then there would be complaints in the current API over unused parameters...\n\nMy biggest worry about affing overlayfs entries is they are only used on userdebug, and their presence on \"user\" is a security risk.\n\nI was thinking of adding a flag \"userdebug\" that is part of the fstab manager flags field and have them ignored on \"user\". Since there are only 4 flag bits left, I felt that was a limited space problem. I eventually settled on \"wait\" as the _ignore_ flag.",
      "parentUuid": "f2940324_bb1fb6ba",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06841892_749e2ca6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 23,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-26T18:28:23Z",
      "side": 1,
      "message": "\u003e each has an option of three possible upper and workdir locations\n\nWhy?  I would assume that a given device would have a single set of upper/workdir locations.  \n\n\u003e But I would be remiss in not being able to allow a means to override them ;-/ for those that want determinism.\n\nI assume that everyone wants determinism, which is why I figure having one set in the fstab and no automatic searching is best for everyone.\n\n\u003e I have discovered determinism is a goal that is counter to bootability in a development environment. What if /cache (always smaller) can be mounted, but /data (larger) can not, then what do we do to allow an adb remount + reboot cycle? \n\nMount /cache?  I feel like using /data is a bad idea in general, especially since all Treble devices have first stage mount, so they\u0027ll be running off of system way before data is mounted.  There will be a whole slew of executables and libraries that won\u0027t be possible to change via overlayfs, which is a pretty big negative.  \n\nRealistically, the only way to do this safely is that overlayfs mounts need to happen very early and only use upper/workdir paths that can be early mounted.  I guess this may be hard for A/B devices without /cache (or at least without a large one) and without dm-linear\u0027s extra space, but I don\u0027t think we\u0027re going to have that combination of devices in the future, right? (A/B with squashfs without dm-linear) ?",
      "parentUuid": "ac9da48a_2ff53fe6",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "582d5aae_624c2269",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 23,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T22:12:00Z",
      "side": 1,
      "message": "1) if /data can not mount, we may have to rely on /cache in order to provide adb push or adb sync updates to diagnose why /data did not mount, so the list of entries will be list the preferences. I have already used this feature prototype and debugging for _this_ CL\u0027s features. (you can not imagine how good I felt having this automation help me develop this, adb sync just worked and I felt a warm glow, despite it not being deterministic). Now I am just one user, but I would prefer that if a resource for overlayfs is inaccessible, that another is found so we can move on. So many times I have sat there at the boot animation (/data not mounting) and would be annoyed if I could not do an adb push to investigate/fix the problem.\n\n2) I fully understand why you want determinism. I was admittedly seeing it as an afterthought to even allow fstab overrides, but I also know how many engineers _hate_ a system that is too smart for its own good. I imagined a fully deterministic setup, and imagined the bring-up engineers populating these entries as a \"why bother\" scenario, much like what happens when trying to run gdb without a symbol table handy, others that utilize such setups just live with the restriction rather than investigating how to do it right until it is downright inconvenient. I still think I can make this all happen for everyone without the fstab entries for overlayfs, and hence I do have some resistance, but I am listening (and worrying) because it _is_ simpler to implement, but its utility will drop somewhat.\n\n3) /cache can be mounted early, so it makes a great case for this early overlayfs issue, but its size is small (256MB). So some cases /cache is best, and other cases /data is best, and I can even imagine a scenario where /cache is best for /system and /data is best for /product. However, the largest users of the adb-sync feature are not bringup folks, but frameworks, where late mounting is not a problem.\n\nFor A/B devices with LRAP, we intend to create a /scratch directory to a \u0027free space\u0027 or \u0027dm-scavenge\u0027 resource that should early mount. /scratch would be a priority if available, and a fs_mgr_mount_all(nullptr) should work off device tree and at the first stage.\n\nBecause of multiple use cases, all anyone can do is mount as early as possible. As it stands _today_ and you will find that if /data is late mounted, that the code will mount to /cache, For LRAP it will mount to /scratch as it is larger and available immediately, and for cases where there is no /scratch, and /data and /cache mount at the same phase (hikey BTW), that it will use /data. It works as you desire without overrides ... and if we wanted fstab overrides to make it deterministic, they get baked into the kernel (YOW) device tree, which I want no part of.\n\nI had a late overlayfs handle, after adbd was up. I even used that adbd to mount to /data. I then restarted adbd and it started using the _new_ one and agave me the diagnosis I needed. Although not as straightforward as an early deployment of overlayfs, and despite that the content needed came late, I had an option that a bring-up artist could use.\n\nRegardless, there has to be some runtime logic because overlayfs is a security issue on \"user\" builds, and some of the logic can not happen at FirstMount init phase. None of the ro.* properties exist, if I allowed it to happen at FirstMount on \"user\" then I have to cancel the feature ...",
      "parentUuid": "06841892_749e2ca6",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2d711c9_2c899a53",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "Why three options?  I can understand defaulting to \u003cmount_point\u003e and allowing an override, but I don\u0027t see a reason to have the third.",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c05ef0f_ff9af3a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "If there is no context xattr at the \u003cmount_point\u003e (remember, this is for a debug device that can be setup incorrectly), then we have to survive and still boot far enough for us to get adb and shell going. I explored that as one of the use cases and had to add the guess for the root node\u0027s context. I should really collect it from /plat_file_contexts, but the complexity of adding a pgrep got to me; and the fact that it lists an incorrect context for /oem (u:object_r:oemfs:s0) also presented a problem.",
      "parentUuid": "c2d711c9_2c899a53",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "821f027e_6202bb2b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-26T18:28:23Z",
      "side": 1,
      "message": "\u003e If there is no context xattr at the \u003cmount_point\u003e (remember, this is for a debug device that can be setup incorrectly), then we have to survive and still boot far enough for us to get adb and shell going\n\nNo, we don\u0027t.  Debug device or not, I think it\u0027s a safe assumption to say that overlayfs is only going to work if the underlying FS is well formed.  If developers *really* need to work with a system where there\u0027s no context xattr, then rootcontext\u003d seems allowable as an override, but not the third option to try to guess it.",
      "parentUuid": "2c05ef0f_ff9af3a9",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd6e8d5b_021aaab2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T22:12:00Z",
      "side": 1,
      "message": "rootcontext\u003d was only needed if things were not well formed (upperdir\u003d and lowerdir\u003d had to _both_ be set, if they weren\u0027t, things got ugly and device did not boot, or prevented shell from executing). I require it because this is not the case if we used a _real_ remount of an ext4 filesystem, it provided on-par behavior.\n\nThe guess is not from left field:\n\n// list of known mount points and default selinux label\nconst std::map\u003cstd::string, std::string\u003e default_label_from_mount_point \u003d {\n        {\"/system\",  \"system_file\"},\n        {\"/product\", \"system_file\"},\n        {\"/vendor\",  \"vendor_file\"},\n        {\"/odm\",     \"vendor_file\"},\n        {\"/oem\",     \"vendor_file\"},\n};\n\nand let\u0027s say we added a /google partition (without a table entry), what would be so wrong about guessing google_file?",
      "parentUuid": "821f027e_6202bb2b",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4c45971_03248ca5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "Hmmm, I thought I noted to myself to pass in the fstab as supplied by mount_all. I failed to make this change ...",
      "range": {
        "startLine": 28,
        "startChar": 30,
        "endLine": 29,
        "endChar": 27
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05ee5d72_d1a576ee",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "Why does /proc/mounts need to be traversed?  Why not simply mount all of the overlayfs entries in the fstab?",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "010a91a3_c7d39d55",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "We do not want to remount overlayfs overtop an overlayfs. Detecting if it is there or not already helps. Later versions of overlayfs (ToT upstream) have busy checks and will reject the later mount attempts, but still, do not want to attempt a remount that I know will result in an error.\n\nThere are no overlayfs\u0027 in the fstab :-). Making the partners add them could be informational, but in 99.9% of the cases of no use. We do not want the entries to exist on \"user\" builds, then they represent \"risk\". But frankly, I don\u0027t want any there because they will get it wrong. I would be remiss in not supporting them and using some of the flags to direct activities, but it is so easy to get the mount parameters wrong especially since we have to introduce overlayfs driver changes to support Android (if they chose to remove override_cred\u003d b/c their kernel does not support it, overlayfs will not allow a successful boot.).",
      "parentUuid": "05ee5d72_d1a576ee",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d8f08d7_9dd5cfae",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-26T18:28:23Z",
      "side": 1,
      "message": "Understood why to have the /proc/mounts traversal.\n\nThat\u0027s not what the code seems to do though.  It traverses the provided fstab, which looks like its the default fstab in the adb case, then checks that the mounts are not already in /proc/mounts before it tries to mount them.  I don\u0027t see the logic that attempts to find suitable overlayfs mounts then checks that they\u0027re not in the fstab, then mounts them.  fs_mgr_overlayfs_setup() attempts to set up the directories, but I don\u0027t see it actually mount them.",
      "parentUuid": "010a91a3_c7d39d55",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db0f30e3_cde8903b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T22:12:00Z",
      "side": 1,
      "message": "fs_mgr_overlayfs_mount_all() does this. If you don\u0027t see it, means my code is obfuscated and needs to be written more clearly. I am already doing so in my working branch, I see that it was not clear and became much clearer when I used a subroutine to do the search and find ...",
      "parentUuid": "7d8f08d7_9dd5cfae",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "226b80ff_7bde142b",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 105,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "const auto\u0026 here and in a few other places too.",
      "range": {
        "startLine": 105,
        "startChar": 9,
        "endLine": 105,
        "endChar": 13
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ab84423_abb0753c",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 105,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "226b80ff_7bde142b",
      "range": {
        "startLine": 105,
        "startChar": 9,
        "endLine": 105,
        "endChar": 13
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "db77526b_fa265abb",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 248,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "This seems wrong.  The map is unconditionally cleared at the end of this function?",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de399d45_0f1862ff",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 248,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "No, it does not, it is a global\n\nWish it was not so, but the fs_mgr_update_verity_state has no object var that can be passed in its current interface.\n\nI do not think that is a bad thing (for now).",
      "parentUuid": "db77526b_fa265abb",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b10a373f_7b99a521",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 248,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-26T18:28:23Z",
      "side": 1,
      "message": "Why is it a map then if the purpose is just to check if the mount_point was verified?\n\nIn any case, the fs_mgr is a static lib and we make no guarantees that functions are not changed. \n So it\u0027s probably best to fix fs_mgr_update_verity_state() to take a std::function for the callback so you can use a lambda here with a capture that does what you actually want instead of the thread-unsafe (though all the callers are single threaded anyway, right?) global.",
      "parentUuid": "de399d45_0f1862ff",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51095902_6c979f19",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 248,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T22:12:00Z",
      "side": 1,
      "message": "agreed, we are like minded, I am just a little lazier :-}",
      "parentUuid": "b10a373f_7b99a521",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "53b94576_1eecf2fa",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 286,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "Probably not a good way to use a return value.  Why isn\u0027t just true if everything is set up correctly and false with rollbacks if things were not set up?",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bc59b38_b42a9983",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 286,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "I can return a std::pair\u003cbool, bool\u003e I guess. But that success information is useless to the caller (has no action for the info, the logs will tell us why and how it failed, especially if it was partial, and a bug can be filed). What is success, if we are imbalanced and can perform and adb remount?\n\nIf the partner choses deterministic (overlayfs entries), then failure can more easily be determined too. But what action do we take? The most probable is to keep what we have, reboot, and try again.\n\nFor userdebug, even a partial layout is helpful (eg: provide override for /system, but not /vendor; or imbalanced /system on /data and /vendor on /scratch), so rolling back also seemed like a bad plan. The user will see the problem during adb sync or adb push, and file a bug; the logs will tell us what we got wrong. Given that before this change no facility existed for successful operations of these commands for squashfs, I can live with that.\n\nIf nothing needed to change (including a failure to change anything), then the caller does not need to reboot. That is the purpose of the return, because we can move on to adb remount immediately. That is why we have to comment this unusual return condition.",
      "parentUuid": "53b94576_1eecf2fa",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9abc685a_71f18752",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 286,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T15:35:40Z",
      "side": 1,
      "message": "opted to use\n\nstruct success_change {\n    bool success;\n    bool change;\n}\n\nas return value from these classes of functions",
      "parentUuid": "9bc59b38_b42a9983",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e16d2042_c1e6d2ec",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 286,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-26T18:28:23Z",
      "side": 1,
      "message": "What is change needed for?  I took a look at the adb code, which I think is the user of changed and it seems that changed implies something changed that requires a reboot.  Is that necessarily true for these changes?  Making a directory doesn\u0027t seem to be something that requires a reboot.\n\nIn any case if this is needed, having a bool return for success and a bool* changed as an out parameter may be the most clear.",
      "parentUuid": "9abc685a_71f18752",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0b0cacf_6b9a2774",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 286,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T22:12:00Z",
      "side": 1,
      "message": "I had already switch gears in my internal branch and went with bool return and bool* changed ... :-)\n\nIf we change it, we want a reboot for an earlier mount. But I have half a mind to support late mount as-is, expecting adb sync _then_ reboot by the caller to take advantage of an early-mount. So I may be waffling a bit on even needing change boolean to manage when to take a reboot or not.",
      "parentUuid": "e16d2042_c1e6d2ec",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47dffb99_fecf3b70",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 317,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-26T18:28:23Z",
      "side": 1,
      "message": "Just noticing this.  You should probably just use setfscreatecon() before the mkdir() instead.  It\u0027s safer and less code.",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2914caf_32bc63d0",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 317,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T22:12:00Z",
      "side": 1,
      "message": "Thanks",
      "parentUuid": "47dffb99_fecf3b70",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eeebda9f_a3f52a54",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 432,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "Ooops, forgot to add const fstab* fstab to the argument list to be the primary source of fstab, and not fs_mgr_read_fstab_default(). I added it to the others above, but missed this spot.",
      "range": {
        "startLine": 432,
        "startChar": 31,
        "endLine": 432,
        "endChar": 33
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b81f098_447f925e",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 432,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-26T18:28:23Z",
      "side": 1,
      "message": "Why would there be a different fstab besides fs_mgr_read_fstab_default()?  I\u0027m suggesting that none of these functions should take fstab* as an argument.",
      "parentUuid": "eeebda9f_a3f52a54",
      "range": {
        "startLine": 432,
        "startChar": 31,
        "endLine": 432,
        "endChar": 33
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "833ab5fd_4ee179a1",
        "filename": "fs_mgr/fs_mgr_overlayfs.cpp",
        "patchSetId": 3
      },
      "lineNbr": 432,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-26T22:12:00Z",
      "side": 1,
      "message": "Alas, we have a non-standard fstab supplied to mount_all, and this allows us to support that.\n\n(I have since pressured the developers to change to a standard fstab).\n\nMaybe you need to add checking if the mount_all is pointing to standard fstab, and report an error in your buildtime check? Then I would be more comfortable w/o an fstab parameter to this new API?",
      "parentUuid": "6b81f098_447f925e",
      "range": {
        "startLine": 432,
        "startChar": 31,
        "endLine": 432,
        "endChar": 33
      },
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db0b78e8_3ad0f052",
        "filename": "fs_mgr/include/fs_mgr_overlayfs.h",
        "patchSetId": 3
      },
      "lineNbr": 23,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-06-25T21:03:50Z",
      "side": 1,
      "message": "Any use case for allowing users to specify an fstab that isn\u0027t just the default one?",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9aa0c1b_31c238e6",
        "filename": "fs_mgr/include/fs_mgr_overlayfs.h",
        "patchSetId": 3
      },
      "lineNbr": 23,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-06-25T22:06:48Z",
      "side": 1,
      "message": "For now, there isn\u0027t, but the non-standard ones just keep on coming up and one day I hope we fix it ...",
      "parentUuid": "db0b78e8_3ad0f052",
      "revId": "8ea9088f4819f14610c1071defdd644d12f285c0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}