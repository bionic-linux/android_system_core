{
  "comments": [
    {
      "key": {
        "uuid": "28046895_f3a32e35",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T02:10:39Z",
      "side": 1,
      "message": "Ultra-nit #2: do we want unordered_map?",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c666e277_4a9f6622",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-05-02T02:18:10Z",
      "side": 1,
      "message": "I depend on the iterators not being invalidated on subsequent additions/deletions so I don\u0027t need to wrap the function in unique_ptr.  I\u0027ve got that commented below.",
      "parentUuid": "28046895_f3a32e35",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4eab7b1a_1ce2e637",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T02:21:45Z",
      "side": 1,
      "message": "Sure. We could look up the function by FD instead I guess. But this is fine. (Maybe \"// Use map for iterator stability\"?)",
      "parentUuid": "c666e277_4a9f6622",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d655f7dd_06773955",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-05-02T02:24:56Z",
      "side": 1,
      "message": "I figure the comment is better next to where I actually depend on the iterator remaining constant.\n\nI didn\u0027t want to do the look up by FD since that\u0027ll add (a trivial amount of) overheard to each of these calls.",
      "parentUuid": "4eab7b1a_1ce2e637",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a93e8349_a9bccd3e",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T02:28:42Z",
      "side": 1,
      "message": "Another option, even simpler, might be a big std::vector\u003cstd::function\u003cvoid()\u003e\u003e; just use the fd to index into the array. The FD set is dense, so you wouldn\u0027t waste much space. And you wouldn\u0027t have to redundantly store the FD numbers, since the FD would be implicit in the position. (Or a std::vector\u003cunique_ptr\u003cstd::function\u003cvoid()\u003e\u003e\u003e to make the array smaller and keep std::function memory stability.)\n\nBut just to be clear: there are lots of ways of doing this thing. This one is fine.",
      "parentUuid": "d655f7dd_06773955",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e9be5b2_504a6a29",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-05-02T15:00:24Z",
      "side": 1,
      "message": "Thanks for the explanation, std::map may just solve a std::unordered_map gotcha.\n\n[TL;DR]\n\nAfterthoughts: I have been hit with std::unordered_map validity/corruption and multithreading issues. The maps were _large_ and needed to scale, so I do not think I had a choice. logd has r/w locks and iterator requisition; perhaps other profiles of list/maps/tables could unburden some of the coarse locks and aid performance? In some of the places, if an iterator could remain valid through unlocked manipulation, all could be better.\n\nAfterQuestions: Is there a way we could emulate read-copy-update locking in user space with libcxx?",
      "parentUuid": "a93e8349_a9bccd3e",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f4add82_5f45525c",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-05-02T15:54:06Z",
      "side": 1,
      "message": "From what I understand: Both maps require locks.  Reader/writer locks are sufficient.  You can use a reference to std::map\u0027s value after unlocking since the iterators don\u0027t invalidate (As long as nothing is concurrently deleting that entry), but you need to hold the lock until you\u0027ve stopped using the reference for std::unordered_map.  \n\nIf your unordered_map values are unique_ptr\u0027s, then you can unlock once you\u0027ve used .get() to get a pointer (better to deference too and take a reference) to the value contained within the unique_ptr.\n\n\u003e Is there a way we could emulate read-copy-update locking in user space with libcxx\n\nAs in have the same RCU behavior as the kernel but with libcxx?  Nothing I\u0027ve seen would do this.",
      "parentUuid": "2e9be5b2_504a6a29",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0479b7e0_aadcf925",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T16:05:09Z",
      "side": 1,
      "message": "Huh? As Tom says, the contains have the same concurrency behavior. If you\u0027re been hit with \"validity/corruption issues\", perhaps you weren\u0027t playing by the iterator invalidation rules.\n\nRe RCU: there are various user-space RCU implementations available. None of them is warranted here.",
      "parentUuid": "5f4add82_5f45525c",
      "range": {
        "startLine": 134,
        "startChar": 12,
        "endLine": 134,
        "endChar": 15
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10ffebef_52ffa92c",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T02:10:39Z",
      "side": 1,
      "message": "Out of curiosity: why bother with std::invoke here? I\u0027d have reached for making a named std::function\u003cvoid()\u003e\u0026 and just calling through that with the usual syntax.",
      "range": {
        "startLine": 832,
        "startChar": 12,
        "endLine": 832,
        "endChar": 65
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12e465c9_4792b657",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-05-02T02:18:10Z",
      "side": 1,
      "message": "I\u0027ve gotten into the habit of using std::invoke since it makes the intent clear to me.  I can drop it if everyone\u0027s against it here.",
      "parentUuid": "10ffebef_52ffa92c",
      "range": {
        "startLine": 832,
        "startChar": 12,
        "endLine": 832,
        "endChar": 65
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55c73407_1e3df5e3",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T02:21:45Z",
      "side": 1,
      "message": "I\u0027m not for or against it --- I was just curious.",
      "parentUuid": "12e465c9_4792b657",
      "range": {
        "startLine": 832,
        "startChar": 12,
        "endLine": 832,
        "endChar": 65
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b903c66_e37b1a9b",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-05-02T15:00:24Z",
      "side": 1,
      "message": "For clearly _documenting_ that a function is being called (it is better than adding a comment IMHO), I am all for it as long as it does not cause undue run-time overhead. I am satisfied that if tomcherry@ sez no overhead, all is good :-)",
      "parentUuid": "55c73407_1e3df5e3",
      "range": {
        "startLine": 832,
        "startChar": 12,
        "endLine": 832,
        "endChar": 65
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1f46ccd_f4438c66",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-05-02T15:54:06Z",
      "side": 1,
      "message": "Yup, exactly what I use it.",
      "parentUuid": "5b903c66_e37b1a9b",
      "range": {
        "startLine": 832,
        "startChar": 12,
        "endLine": 832,
        "endChar": 65
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f95f2339_54ee9083",
        "filename": "init/init.cpp",
        "patchSetId": 3
      },
      "lineNbr": 832,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T16:05:09Z",
      "side": 1,
      "message": "Then why aren\u0027t you using std::invoke to call epoll_wait above? Or printf? Or exit? In C++, parenthesis after an identifier already indicate calling, so invoke is redundant. You need neither a comment nor invoke here.\n\n\u003e I am satisfied that if tomcherry@ sez no overhead, all is good :-)\n\nI put my trust in objdump, not people.",
      "parentUuid": "b1f46ccd_f4438c66",
      "range": {
        "startLine": 832,
        "startChar": 12,
        "endLine": 832,
        "endChar": 65
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a54b1470_9d75e2de",
        "filename": "init/init.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T02:10:39Z",
      "side": 1,
      "message": "Ultra-nit: do we want to add a TODO to change this to std::unique_function when it\u0027s available?",
      "range": {
        "startLine": 46,
        "startChar": 41,
        "endLine": 46,
        "endChar": 49
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad9cf9ca_37883c5b",
        "filename": "init/init.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-05-02T02:18:10Z",
      "side": 1,
      "message": "Is that even in C++2a?  Probably better to not have a TODO unless there\u0027s a line of sight on fixing it.  We\u0027ll be able to search for std::function once it\u0027s available anyway.",
      "parentUuid": "a54b1470_9d75e2de",
      "range": {
        "startLine": 46,
        "startChar": 41,
        "endLine": 46,
        "endChar": 49
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2da9ba21_8c34a3f3",
        "filename": "init/init.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-05-02T02:21:45Z",
      "side": 1,
      "message": "Based on some internal conversations over in the C++ channel, I think it\u0027s going to be in 2a. But yeah, we can just look for opportunities to switch when unique_function arrives.",
      "parentUuid": "ad9cf9ca_37883c5b",
      "range": {
        "startLine": 46,
        "startChar": 41,
        "endLine": 46,
        "endChar": 49
      },
      "revId": "2d458f0e0163f98888c7687d3c6bb9f45a8c725f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}