{
  "comments": [
    {
      "key": {
        "uuid": "f6dbe336_3c11082d",
        "filename": "logd/LogTimes.cpp",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-08-08T16:07:03Z",
      "side": 1,
      "message": "why wouldn\u0027t you just return NULL?",
      "revId": "2dfa2c1a9137bed4e0f1b639f21602a3f2f97a6b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16c87774_962dac80",
        "filename": "logd/LogTimes.cpp",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-08-08T16:30:38Z",
      "side": 1,
      "message": "I choose so to be pedantic about directly calling pthread_exit to be explicit about the paths.\n\npthread_cleanup_push() (and, if memory serves, other historically similar entities) is not what you think it is (I know you know what it is ;-\u003e). It is a (sometimes) dysfunctional block context to pthread_cleanup_pop and is required. However, historically there is a difference in thread locking when processing the cleanup operations within the context of pthread_exit and when pthread_cleanup_pop is called out in the thread just before exit. The alternative is:\n\n    pthread_cleanup_pop();\n    return NULL;\n\nWhich has a difference in atomicity because the thread is still \u0027alive\u0027 until return NULL, but the thread is \u0027dead\u0027 while the cleanup is being called in pthread_exit. Since then I have preferred:\n\n    pthread_exit(NULL);\n    pthread_cleanup_pop();\n    return NULL;\n\nI was bitten by this (circa 2002, port to *all* UNIXii) difference and I am still smarting over it.\n\nI know, this is a decade later, and Linux _or_ Bionic is our target. If you are confident I am holding on to too much history, I\u0027ll relax ...",
      "parentUuid": "f6dbe336_3c11082d",
      "revId": "2dfa2c1a9137bed4e0f1b639f21602a3f2f97a6b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f6dbe336_bc5998c1",
        "filename": "logd/LogTimes.cpp",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-08-08T16:39:45Z",
      "side": 1,
      "message": "no, you couldn\u0027t write\n\n    pthread_cleanup_pop(true);\n    return NULL;\n\nbecause, as you say, the pop is really a \"} while\".\n\nyou\u0027d just return NULL here (which is equivalent to calling pthread_exit(NULL) but less weird), and then you\u0027d\n\n    pthread_cleanup_pop(true);\n    return NULL;\n\nat the end (i.e. just remove the pthread_exit and the NOTREACH).\n\nthat\u0027s exactly the same because the return NULL is equivalent to pthread_exit(NULL), and the first thing that pthread_exit does is call your cleanup functions.",
      "parentUuid": "16c87774_962dac80",
      "revId": "2dfa2c1a9137bed4e0f1b639f21602a3f2f97a6b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "360c9b77_44d9c204",
        "filename": "logd/LogTimes.cpp",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-08-08T16:53:46Z",
      "side": 1,
      "message": "You misunderstand me. Let me try to rephrase. I am still siding on complying, just want to make it clear so that you understand the reasoning and can confirm we are both in sync.\n\n\u0027here\u0027 return NULL ok ... yes, only done here to *match* the bottom in pedantic operations. It always incurs a twinge of pain when the mid-routine exit differs from the exit at the bottom.\n\nBut the point is:\n\n    pthread_cleanup_pop(true);\n    return NULL;\n\nat the bottom is *not* the same thing as the cleanup is done in the context of the thread, and not in the context of the \u0027exit\u0027. If we want it to be performed in the \u0027exit\u0027 rather than in the contest of the thread:\n\n    return NULL;\n    pthread_cleanup_pop(true);\n\n-or less strange-\n\n    pthread_exit(NULL);\n    pthread_cleanup_pop(true);\n    return NULL;\n\neg: one of the problems (and I must admit this has more to do with the previous code which ran transitory threads, rather than this code which runs a persistent thread) is that the former can lead to more VSS taken under heavy load because the stack cleanup is no longer atomic in the general case.",
      "parentUuid": "f6dbe336_bc5998c1",
      "revId": "2dfa2c1a9137bed4e0f1b639f21602a3f2f97a6b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f6dbe336_3c7748e7",
        "filename": "logd/LogTimes.cpp",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-08-08T17:02:31Z",
      "side": 1,
      "message": "i don\u0027t know what you mean by \"context of the thread\" versus \"context of the exit\". pthread_exit runs on the same thread. the cleanup routines are the first thing pthread_exit runs. there\u0027s no difference. the thread stack (obviously) doesn\u0027t get unmapped until all code that needs to run on the thread has been run. (except the exit syscall which has to run without a valid sp!)",
      "parentUuid": "360c9b77_44d9c204",
      "revId": "2dfa2c1a9137bed4e0f1b639f21602a3f2f97a6b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "360c9b77_c13f64f1",
        "filename": "logd/LogTimes.cpp",
        "patchSetId": 1
      },
      "lineNbr": 157,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-08-08T16:07:03Z",
      "side": 1,
      "message": "likewise.",
      "revId": "2dfa2c1a9137bed4e0f1b639f21602a3f2f97a6b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}