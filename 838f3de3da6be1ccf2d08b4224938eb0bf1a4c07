{
  "comments": [
    {
      "key": {
        "uuid": "c5e8dfcd_3643e8cf",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-04-24T22:04:41Z",
      "side": 1,
      "message": "\u0027ret\u0027 is a confusing name here. \u0027total_length\u0027?",
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5c1bf53_77348a01",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-24T22:35:22Z",
      "side": 1,
      "message": "ret is already defined and used and is a ssize_t, this is merely a result of good \u0027C\u0027 hygiene by not proliferating too many automatic variables. payload_length is more descriptive, it is not a total_length.",
      "parentUuid": "c5e8dfcd_3643e8cf",
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a5e5abf4_751008b2",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-04-24T23:05:57Z",
      "side": 1,
      "message": "you know you\u0027re allowed to switch to C++? or just add -std\u003dc99 to your CFLAGS?",
      "parentUuid": "c5c1bf53_77348a01",
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5c1bf53_57cb0e85",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-24T23:12:43Z",
      "side": 1,
      "message": "This may prejudice me, but I define \u0027C\u0027 as to what the kernel source enforces on us. I can speak some Ukrainian, and English, for example, I feel evil when I mix the two. Purity on one side or the other just feels right :-)",
      "parentUuid": "a5e5abf4_751008b2",
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5e8dfcd_714d7af8",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2014-04-24T23:18:15Z",
      "side": 1,
      "message": "Do we care if ret overflows? The check on 209 could be skipped.\n\n(assuming the implementation-specific undefined behavior of signed overflow will lead to something reasonable like wrapping around to negative)",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 64
      },
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2581bb17_364866e9",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-25T15:37:41Z",
      "side": 1,
      "message": "ret will never(tm) overflow as it is a ssize_t ;-\u003e. 209 is the code that truncates the buffer, but your point does mean:\n\nif ((size_t)ret \u003e LOGGER_ENTRY_MAX_PAYLOAD)\n\nShould have been used. This code has been refactored and committed, will consider hardening CL based on this critique.",
      "parentUuid": "c5e8dfcd_714d7af8",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 64
      },
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a5e5abf4_0ab88360",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-04-24T22:04:41Z",
      "side": 1,
      "message": "wouldn\u0027t this be clearer in the loop? i think you\u0027re trying to say \"if the last iov_len \u003e\u003d max, -EINVAL; otherwise truncate\"?\n\nthat seems weird. why not just pass min(total_length, LOGGER_ENTRY_MAX_PAYLOAD) to writev?",
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "659e536e_14f51a68",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-24T22:35:22Z",
      "side": 1,
      "message": "if the last iov_len \u003c what we can subtract to result in truncation, we KISS return -EINVAL. Doing it in the loop would deal with truncating the packet better I will agree.\n\nIn this KISS implementation, we have to ensure that the total length is limited, if the length comes from other fields other than the last one, we will reject the message as unworkable. min on this one iovec will *not* limit the overall length as per our goal.",
      "parentUuid": "a5e5abf4_0ab88360",
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a5e5abf4_75c728d9",
        "filename": "liblog/logd_write.c",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-04-24T23:05:57Z",
      "side": 1,
      "message": "why isn\u0027t the simplest thing to just pass min(total_length, LOGGER_ENTRY_MAX_PAYLOAD) to writev?",
      "parentUuid": "659e536e_14f51a68",
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "85b427df_af116975",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 499,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-04-24T22:04:41Z",
      "side": 1,
      "message": "where did this number come from?",
      "range": {
        "startLine": 499,
        "startChar": 27,
        "endLine": 499,
        "endChar": 34
      },
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a5be8bc4_16cefa3f",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 499,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-24T22:35:22Z",
      "side": 1,
      "message": "From the associated bug, Igor picked it as associated with a separate bug that posted a message this long and left him confused because nothing showed up in logcat (not even truncated). I like it because it is ridiculously long, longer than what even some folks would set the logd circular buffer sizes to.",
      "parentUuid": "85b427df_af116975",
      "range": {
        "startLine": 499,
        "startChar": 27,
        "endLine": 499,
        "endChar": 34
      },
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "85b427df_a1fc1d93",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 499,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2014-04-24T23:05:57Z",
      "side": 1,
      "message": "wouldn\u0027t 2 * LOGGER_ENTRY_MAX_PAYLOAD be a better idea?",
      "parentUuid": "a5be8bc4_16cefa3f",
      "range": {
        "startLine": 499,
        "startChar": 27,
        "endLine": 499,
        "endChar": 34
      },
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a5e5abf4_35404069",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 499,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2014-04-24T23:18:15Z",
      "side": 1,
      "message": "In my tests using numbers slightly larger than LOGGER_ENTRY_MAX_PAYLOAD was perfectly fine (it would truncate down to LOGGER_ENTRY_MAX_PAYLOAD once it hit logcat)\n\nIt\u0027s possible that this value is related to maximum size of an atomic packet for SOCK_DGRAM instead of LOGGER_ENTRY_MAX_PAYLOAD, but I didn\u0027t investigate it that far down.",
      "parentUuid": "85b427df_a1fc1d93",
      "range": {
        "startLine": 499,
        "startChar": 27,
        "endLine": 499,
        "endChar": 34
      },
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2581bb17_d660ea61",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 499,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2014-04-25T15:37:41Z",
      "side": 1,
      "message": "I want a buffer that exceeds both LOGGER_ENTRY_MAX_PAYLOAD and any inconceivable max dgram size in the network layer. There are multiple sources of truncation in each vintage of all loggers, and an equally inconsistent set of checks. I also want, should this test be used on the legacy kernel logger, to stress it to the max as well.\n\nThis test could be performed independently on any Android release, OEM submissions etc. So tailoring it for our current expected behavior and underlying mechanisms and libraries is how I got into this trouble in the first place ;-\u003e\n\nBTW, any value above 64K will meet this condition, 3266519 doubly so \u003cgrin\u003e\n\nHowever, svelte phones could choke? I will look into running this test on a hammerhead svelt to be sure, at my convenience.",
      "parentUuid": "a5e5abf4_35404069",
      "range": {
        "startLine": 499,
        "startChar": 27,
        "endLine": 499,
        "endChar": 34
      },
      "revId": "838f3de3da6be1ccf2d08b4224938eb0bf1a4c07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}