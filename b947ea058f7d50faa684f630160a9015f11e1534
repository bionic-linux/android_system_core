{
  "comments": [
    {
      "key": {
        "uuid": "ccaec9c6_37a884e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-22T16:58:14Z",
      "side": 1,
      "message": "Apologies for the delayed response!",
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97301d55_44299743",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 82,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-16T18:33:15Z",
      "side": 1,
      "message": "by setting the weak count here, we may enter into a situation where a decWeak decrements the weak count, and so we can no longer decrement the strong count. You should probably avoid changing the weak count here for that reason",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 35
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ddc8fb3b_b9e56829",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 82,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-22T16:58:14Z",
      "side": 1,
      "message": "The reason I am incrementing the weak count here is because internally incStrong also calls incWeak. Is this similar to forceIncStrong, where the weak ref is promoted to a strong ref, so effectively only the number of strong refs have increased?",
      "parentUuid": "97301d55_44299743",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 35
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "377e96fc_851a3c7c",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 82,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-22T17:13:30Z",
      "side": 1,
      "message": "The goal of strong_count/weak_count, I don\u0027t think should be to keep track of the internal state of the refbase, but the external state.\n\nThat is, every forceIncStrong/incStrong should be coupled with a decStrong. Every incWeak should be coupled with a decWeak. This is the API contract, and the fact that internally incStrong calls incWeak is an implementation detail.\n\nBy tracking the internal state, we may incStrong (strong++ weak++) then decWeak (weak--). Then, it seems that the RefBase object is left in an inconsistent state (strong\u003d1, weak\u003d0), which shouldn\u0027t be possible.",
      "parentUuid": "ddc8fb3b_b9e56829",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 35
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce453e38_09993474",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 82,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-23T20:25:56Z",
      "side": 1,
      "message": "Ah okay I think I understand. To confirm, you\u0027re saying that regardless of what happens internally, we should only track the counts we are explicitly asking to increment or decrement, and any differences in state internally that lead to de referencing or other problems should be considered bugs because they break the API contract?",
      "parentUuid": "377e96fc_851a3c7c",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 35
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9cb013c1_5d1ec063",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-16T18:33:15Z",
      "side": 1,
      "message": "this would be racey, but ref is never set to nullptr elsewhere in the fuzzer",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 120,
        "endChar": 9
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50a843b1_e99ad39e",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-22T16:58:14Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "9cb013c1_5d1ec063",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 120,
        "endChar": 9
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2970200f_cd72d55a",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-16T18:33:15Z",
      "side": 1,
      "message": "We know there is a bug if this is ever false, but canDecrementStrong is true (because we would leak)",
      "range": {
        "startLine": 124,
        "startChar": 59,
        "endLine": 124,
        "endChar": 75
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99ce4d12_bcb05e49",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 124,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-22T16:58:14Z",
      "side": 1,
      "message": "Gotcha, will remove canDecrementWeak here so we have visibility into that bug as a leak.",
      "parentUuid": "2970200f_cd72d55a",
      "range": {
        "startLine": 124,
        "startChar": 59,
        "endLine": 124,
        "endChar": 75
      },
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e136794b_761e36a1",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-16T18:33:15Z",
      "side": 1,
      "message": "if one thread calls incStrong, then another calls decStrong, this object would be deleted, and other dereferences of ref would be invalid",
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24888b23_2ee009f6",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-22T16:58:14Z",
      "side": 1,
      "message": "That was originally the intent with the ref \u003d\u003d nullptr check breaking the loop in fuzzOps, so the threads let themselves die if the object does dereference itself. You\u0027re right that it is racey though. I would expect that issue to manifest itself fairly quickly, especially given this can have up to ten threads, but I didn\u0027t hit it after several million iterations... The logic in canDecrementStrong/weak which subtracts 1 from the count before checking is probably what\u0027s preventing this from dereferencing itself.",
      "parentUuid": "e136794b_761e36a1",
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0dd0f7f6_b5683b6c",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 2
      },
      "lineNbr": 150,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-22T17:13:30Z",
      "side": 1,
      "message": "The pointer to this object won\u0027t be changed by any calls to it.\n\nit\u0027s much like this:\n\n    T* t \u003d new ..; // say pointer has value 0x4848\n    // arbitrary incStrong/decStrong operations\n    // eventually result in:\n        delete t;\n    // t still has value 0x4848\n\nUsing \u0027sp\u0027 is different, since the existence of this object w/ non-null mPtr means that incStrong has been called. Only when that object is deleted is decStrong called.",
      "parentUuid": "24888b23_2ee009f6",
      "revId": "b947ea058f7d50faa684f630160a9015f11e1534",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}