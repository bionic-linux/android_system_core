{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2b0ab840_28b4c7fb",
        "filename": "init/service.cpp",
        "patchSetId": 1
      },
      "lineNbr": 144,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-04-10T20:31:35Z",
      "side": 1,
      "message": "hey, if you like this patch, I\u0027ll fix this, but first, fixing the instances so it won\u0027t log as much on boot",
      "range": {
        "startLine": 144,
        "startChar": 0,
        "endLine": 144,
        "endChar": 67
      },
      "revId": "2d48b2a7ff28deb6e0b74c4f7c29847cc9c3d0f4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "848ac9d5_9c618bc4",
        "filename": "init/service_parser.cpp",
        "patchSetId": 1
      },
      "lineNbr": 680,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2023-04-12T22:02:02Z",
      "side": 1,
      "message": "It\u0027s a little unwieldy to have both uid() and uid_ exposed, and it\u0027d be the only member exposed that way. At least in one iteration of the style guide, if not the current one, that\u0027s not recommended.\n\nSince most callers just want the uid-or-zero, I\u0027d add a second boolean, something like \"has_uid\" or \"specified_uid\". It\u0027ll make this patch significantly smaller too.",
      "revId": "2d48b2a7ff28deb6e0b74c4f7c29847cc9c3d0f4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55b2d5a8_6fff6470",
        "filename": "init/service_parser.cpp",
        "patchSetId": 1
      },
      "lineNbr": 680,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-04-12T22:19:04Z",
      "side": 1,
      "message": "It would also introduce the possibility of having an inconsistent data structure, since manual bookkeeping is required - which is why I did\u0027t go with the boolean.\n\nI assume you\u0027re okay with the patch if I make \u0027uid_\u0027 private and introduce an API - \u0027has_explicit_uid\u0027? I\u0027ll also finish cleaning up the Service constructor in that case.",
      "parentUuid": "848ac9d5_9c618bc4",
      "revId": "2d48b2a7ff28deb6e0b74c4f7c29847cc9c3d0f4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "552e7fa7_ab086817",
        "filename": "init/service_parser.cpp",
        "patchSetId": 1
      },
      "lineNbr": 680,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2023-04-12T23:23:15Z",
      "side": 1,
      "message": "It\u0027s not really much bookkeeping, is it? And why would they go out of sync? It\u0027s separate pieces of information: \"effective uid\" and \"was the uid explicit\". Also, this is the only place that cares about the new state.",
      "parentUuid": "55b2d5a8_6fff6470",
      "revId": "2d48b2a7ff28deb6e0b74c4f7c29847cc9c3d0f4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31864e94_2c587907",
        "filename": "init/service_parser.cpp",
        "patchSetId": 1
      },
      "lineNbr": 680,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-04-12T23:45:56Z",
      "side": 1,
      "message": "Sure it can be thought of as two pieces of information, but it\u0027s not what\u0027s important. The reason to use std::optional is that if the UID is set, we\u0027ll know it\u0027s explicit. It\u0027s going to be encoded as two separate fields underneath std::optional, but the API contract of std::optional limits what combinations of states can occur. With a uid + a bool, it\u0027s possible to express the state \"UID \u003d 400\" and \"not explicitly set\". This combination of states is not expressible using std::optional.\n\nI also agree it\u0027ll be a smaller patch. Though - if someone sets uid\u003d400 somewhere else and forgets to set the bit, they won\u0027t have a reminder. This could be an existing downstream patch, unlikely as you say it would be. The real risk is that if the code says \"has_uid ? uid : 0\". In this case, a patch which sets uid explicitly (uid\u003d400) but forgets to set the bool would silently set the process to be root. It could be avoided (has_uid || uid !\u003d 0 ? uid : 0) - maybe with a log when it\u0027s inconsistent - b/c we don\u0027t abort in init), but I don\u0027t see how to make the boolean super great either.\n\nI imagine you know all that though, and you just don\u0027t like the combo uid_/uid(), and you don\u0027t like how big this patch is - and I agree with you on both counts - this patch leaves something to be desired.\n\nSo - I\u0027d like your opinion on two other approaches to implementation:\n1. exposing has_uid()/uid() and forcing proc_attr_ to hide uid_\n2. removing this from touching service.h/cpp, and implement this as a feature on GetParserMap by adding additional min/max counts for fields there - this is generic and could also be used to solve b/277628515 by encoding additional information.",
      "parentUuid": "552e7fa7_ab086817",
      "revId": "2d48b2a7ff28deb6e0b74c4f7c29847cc9c3d0f4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}