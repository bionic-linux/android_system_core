{
  "comments": [
    {
      "key": {
        "uuid": "18eef932_c23da0fc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-11-16T23:06:04Z",
      "side": 1,
      "message": "What\u0027re the pros/cons to doing it this way?  Why not have a scratch_a / scratch_b for this case?",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "331b2aa7_15670a48",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-11-16T23:47:32Z",
      "side": 1,
      "message": "The reason scratch got mentioned is because it\u0027s the only unsuffixed partition. Either we disallow them (and make overlayfs do scratch_a/scratch_b), or we allow them and figure out where they go.\n\nIf we allow one in each partition (as this patch does), it\u0027s basically as if they\u0027ve been automatically suffixed. It is a bit weird that the same name can be observed differently based on the slot, but that\u0027s basically what suffixing does to begin with. And nothing outside of fastbootd reads from the inactive super partition.\n\nAnother alternative is to put unsuffixed partitions in one place, and search both supers to find where it was placed. (Or always put them in \"A\" or something).\n\nOr finally, we could just disallow unsuffixed partitions on retrofit devices, and make overlayfs do scratch_a/scratch_b. I could see an argument that scratch should be suffixed even for non-retrofit devices, since then you could have separate modifications to both slots.\n\nIf we do want to support unsuffixed partitions, I\u0027m in favor of the approach in this patch. It doesn\u0027t force any changes to adb remount or overlayfs, and it makes the changes to OpenLogicalPartition and friends simpler.",
      "parentUuid": "18eef932_c23da0fc",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bfc3e3ba_c7ede004",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-11-16T23:55:43Z",
      "side": 1,
      "message": "What would fastboot getvar / fastboot getvar all report with two scratch partitions?  I guess that\u0027s my only concern and it\u0027s not a particularly large one.\n\nI don\u0027t have a strong opinion either way, just curious to hear your / salyzyn@\u0027s opinion on the pros/cons here.  If you both think this is the best, then let\u0027s go for it.",
      "parentUuid": "331b2aa7_15670a48",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b052690b_64fea03f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-11-17T00:34:31Z",
      "side": 1,
      "message": "Good point - I just realized that \"getvar all\" will not report the inactive super partition. I\u0027ll fix that in the next version of this patch.\n\nPro for allowing unsuffixed partitions: it\u0027s almost no work to support them with this method. Con: I have no idea what to do about the getvar all case :) the simplest thing would be to ignore the inactive one (doing nothing, it would double-report it).\n\nPro for banning unsuffixed partitions: none of this weirdness. Cons: None for fastbootd. I\u0027m not sure for overlayfs. Need Mark\u0027s input on scratch_a/b.\n\n(Note: banning unsuffixed partitions would only need to be done on retrofit devices, but maybe it\u0027s a reasonable policy on any A/B device).",
      "parentUuid": "bfc3e3ba_c7ede004",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "92ed6346_b9448c82",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-11-17T01:01:05Z",
      "side": 1,
      "message": "Do we know if there\u0027s any interest in moving any other unsuffixed partitions into super?  It looks like \u0027persist\u0027 is one that could sort of make sense, but we definitely wouldn\u0027t want to replicate it across super_a and super_b, so I could understand banning unsuffixed partitions for retrofit devices.\n\nWe could special case scratch?  Or we could think about scratch_a and scratch_b in general too?  It\u0027ll halve their size, which is a big con, but it seems strange to me that we\u0027d use a single scratch partition even when changing slots.",
      "parentUuid": "b052690b_64fea03f",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa9d6210_a4563765",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-11-17T01:03:27Z",
      "side": 1,
      "message": "re: unsuffixed partitions, I don\u0027t think so - for retrofit, everything should be A/B\u0027d.",
      "parentUuid": "92ed6346_b9448c82",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46757228_934e1de1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-11-19T18:14:36Z",
      "side": 1,
      "message": "scratch: on purpose fragile and aimed for simplicity (after much pushback with respect to the wishlists). For instance we delete override content on partition flash. eg: flash either vendor_a or vendor_b, remove /mnt/scratch/overlay/vendor tree. flashall, destroy scratch. etc.\n\nIf there is a problem, delete scratch and/or its contents.\n\nWe do not support a use case where developers are bouncing back and forth between A or B each individually overridden.\n\nWhen prototyped to support such, looked simpler with one scratch (or one /cache/overlay, or one /data/overlay ...) to switch to using suffixed directories as an implementation detail, eg: /mnt/scratch/overlay/vendor_a. Better space utilization (even despite scatch being created with half the free space as buffer) I think than playing games with two scratch_*. In the end I abandoned the effort as not useful and a corner case; since overlayfs is primarily used to update and investigate minor development changes and quickly deploy them on the device and not instead for maintaining two full builds representing each an a side and a b side with individual updates did not appear useful. If one wanted it, then a quick adb sync was in order in any case. Trying to make sure an override matched the underlying content was one of the issues too, we had to pull avb and verity metadata, leave that in the override directory, and check against what we were backing to match.\n\nSo special case scratch if you must, and if conflicted, destroy the partition if it is simpler, and add it to the list of caveats. All caveats can be solved, not all of them are worth solving. I can not entirely predict exactly how adb sync or adb push could be used/abused ;-|",
      "parentUuid": "fa9d6210_a4563765",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6f43f8b_93c0370c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 25,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2018-11-19T18:27:51Z",
      "side": 1,
      "message": "summary: I do not see a problem with this in the two supers case (as long as scratch does not become scratch_a or scratch_b; but even that can be dealt with a minor adjustment to fs_mgr_overlayfs.cpp policy).",
      "parentUuid": "46757228_934e1de1",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc139e8a_2510bbba",
        "filename": "fastboot/device/utility.cpp",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2018-11-16T23:06:04Z",
      "side": 1,
      "message": "Put this after the anonymous namespace?",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1cefa8b5_98416acd",
        "filename": "fastboot/device/utility.cpp",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1290458
      },
      "writtenOn": "2018-11-16T23:47:32Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "dc139e8a_2510bbba",
      "revId": "2da776f83f5bd05ad8268983f26f513a8da2ee35",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}