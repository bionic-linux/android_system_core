{
  "comments": [
    {
      "key": {
        "uuid": "b5526a4f_d8f2cdcd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 21,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-09-30T02:56:01Z",
      "side": 1,
      "message": "why you think the previous way may lose the error?",
      "range": {
        "startLine": 20,
        "startChar": 60,
        "endLine": 21,
        "endChar": 37
      },
      "revId": "b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "75439281_1eb54db4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 21,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-09-30T03:55:51Z",
      "side": 1,
      "message": "Good question. My theory is that the caller might be writing data until errno\u003dEAGAIN. Then fdevent_process() detects an error and the handler is called with func(fd, FDE_ERROR|FDE_READ, arg). if the handler is written like \"if (events \u0026 FDE_WRITE) { adb_write... }\", then it won\u0027t do anything and it won\u0027t see the error.\n\nMy theory could be wrong if the OS always returns POLLOUT when returning POLLERR/POLLHUP/POLLINVAL (because then the handler would be called with FDE_WRITE|FDE_ERROR even without my change).\n\nMy theory could also be wrong if no adb code does what I described. I just checked and I don\u0027t think adb gets into this situation, so then this would only benefit new code.",
      "parentUuid": "b5526a4f_d8f2cdcd",
      "range": {
        "startLine": 20,
        "startChar": 60,
        "endLine": 21,
        "endChar": 37
      },
      "revId": "b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "15a33681_d7918cd9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 21,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-10-01T02:30:45Z",
      "side": 1,
      "message": "I think if some fd only wants to read or only wants to write, it will call synchronized read/write directly, instead of going through fdevent. If you read services.cpp, you can find many services running in a separate thread and do synchronized read/write.\n\nI agree it is weird that why I get a FDE_READ when I only register for FDE_WRITE. Ideally I want to make all errors return FDE_ERROR. But I am not confident in making the change now. So I prefer to stay on using FDE_READ for error processing for stability.",
      "parentUuid": "75439281_1eb54db4",
      "range": {
        "startLine": 20,
        "startChar": 60,
        "endLine": 21,
        "endChar": 37
      },
      "revId": "b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d55b5e6b_083fcf77",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 21,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-10-01T02:55:58Z",
      "side": 1,
      "message": "Ok. Let me know how I should proceed with this review.\n\nBTW, sysdeps_win32.cpp says in a comment \u0027fdevents emulation: this is a very simple implementation, we rely on the fact that ADB doesn\u0027t use FDE_ERROR\u0027. I\u0027m not really sure if the code is really relying on that.\n\nBut I do think that the sysdeps_win32 fdevents code is somewhat scary:\n\n* Windows has select(), but because sysdeps has a custom socketpair implementation, select() won\u0027t work with it, so then WaitForMultipleObjects() + WSAEventSelect() was used instead.\n\n* (Even without the custom socketpair implementation, select() probably wouldn\u0027t work anyway because it is limited to 64 sockets on Windows. But WaitForSingleObjects() is also limited to 64 so sysdeps has a gross hack to make it work beyond 64.)\n\n* WSAEventSelect() requires that after an event occurs, that a \u0027re-enabling\u0027 function (like recv/send) be called, and if it isn\u0027t called, you won\u0027t get future events for a socket. Is this requirement satisfied by adb code? Perhaps, but I\u0027m not sure (maybe I will try to write a test case for this). The worst case scenario is hangs I guess.\n\n* Windows Vista has WSAPoll(), but from reading the web, it sounds buggy and not often used.\n\nBasically, Windows has a different I/O model than Unix. Windows really wants to use an I/O completion port with I/Os posted ahead of time instead of waiting for readiness. But that design is all about performance and I don\u0027t think Windows adb is having any performance issues (seems like reliability is the #1 issue hence why I\u0027m looking at this sysdeps code).\n\nAnyway, I just wanted to give you a sense of what the Windows side has to deal with to keep fdevents working.",
      "parentUuid": "15a33681_d7918cd9",
      "range": {
        "startLine": 20,
        "startChar": 60,
        "endLine": 21,
        "endChar": 37
      },
      "revId": "b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "953c86f3_1fa1c395",
        "filename": "adb/fdevent.cpp",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-09-30T02:56:01Z",
      "side": 1,
      "message": "good detective. I think you are right.",
      "range": {
        "startLine": 177,
        "startChar": 8,
        "endLine": 177,
        "endChar": 30
      },
      "revId": "b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "15a33681_836bdef7",
        "filename": "adb/fdevent.cpp",
        "patchSetId": 1
      },
      "lineNbr": 239,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2015-09-30T02:56:01Z",
      "side": 1,
      "message": "Do you have any reason to change the strategy?",
      "range": {
        "startLine": 238,
        "startChar": 12,
        "endLine": 239,
        "endChar": 36
      },
      "revId": "b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b5398a03_e068c2fc",
        "filename": "adb/fdevent.cpp",
        "patchSetId": 1
      },
      "lineNbr": 239,
      "author": {
        "id": 1065256
      },
      "writtenOn": "2015-09-30T03:55:51Z",
      "side": 1,
      "message": "No, this is only theoretical and might actually be impossible (as I described in the other comment).",
      "parentUuid": "15a33681_836bdef7",
      "range": {
        "startLine": 238,
        "startChar": 12,
        "endLine": 239,
        "endChar": 36
      },
      "revId": "b1f7c070ff21522384ce4d6e57c97e4a07ce3d0a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}