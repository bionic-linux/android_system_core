{
  "comments": [
    {
      "key": {
        "uuid": "af770c87_ac180059",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 31,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-01-30T19:11:09Z",
      "side": 1,
      "message": "Is this true currently?  Blueline and anything with lrap is not system-as-root in the \"kernel mounts system.img as / directly\", but I\u0027m pretty sure / can be mounted as RW.  I think as of Q that is true for all devices.",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bbb2181_e89755c0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 31,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-31T02:20:48Z",
      "side": 1,
      "message": "Yes. When the dynamic partition is used, / is still ro even after \u0027adb remount\u0027.\n\n$ adb root; adb remount; adb shell\ncrosshatch:/ # cat /proc/self/mountinfo \n...\n22 21 253:0 / / ro,nodev,relatime shared:1 - ext4 /dev/block/dm-0 ro,seclabel,block_validity,delalloc,barrier,user_xattr\n23 22 253:1 / /vendor ro,relatime shared:18 - ext4 /dev/block/dm-1 ro,seclabel,block_validity,delalloc,barrier,user_xattr\n24 22 253:2 / /product ro,relatime shared:20 - ext4 /dev/block/dm-2 ro,seclabel,block_validity,delalloc,barrier,user_xattr\n...\n1902 22 0:33 / /system rw,relatime shared:36 - overlay overlay rw,seclabel,lowerdir\u003d/system,upperdir\u003d/mnt/scratch/overlay/system/upper,workdir\u003d/mnt/scratch/overlay/system/work,override_creds\u003doff\n2097 23 0:34 / /vendor rw,relatime shared:37 - overlay overlay rw,seclabel,lowerdir\u003d/vendor,upperdir\u003d/mnt/scratch/overlay/vendor/upper,workdir\u003d/mnt/scratch/overlay/vendor/work,override_creds\u003doff\n2154 24 0:35 / /product rw,relatime shared:38 - overlay overlay rw,seclabel,lowerdir\u003d/product,upperdir\u003d/mnt/scratch/overlay/product/upper,workdir\u003d/mnt/scratch/overlay/product/work,override_creds\u003doff\n\n/system, /vendor, /product are rw, but / isn\u0027t.\n\ncrosshatch:/ # touch /system/foo\ncrosshatch:/ # touch /foo\ntouch: \u0027/foo\u0027: Read-only file system",
      "parentUuid": "af770c87_ac180059",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bb486b1_2d4e1a31",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 31,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-01-31T04:12:37Z",
      "side": 1,
      "message": "Hmmm; that\u0027s right, we didn\u0027t want to have layered overlayfs mounts, so / wasn\u0027t overlayed.\n\nWhat about a device like hikey before LRAP?  Does that mount \u0027/\u0027 RW?  I think it should be able to, since it\u0027ll mount that entire mount point RW instead of using overlayfs.\n\nBut point taken that it won\u0027t be possible with LRAP; at least not how we\u0027re handling overlayfs for it.",
      "parentUuid": "8bbb2181_e89755c0",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c0742fbc_6e0bae14",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 31,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-31T04:42:22Z",
      "side": 1,
      "message": "I don\u0027t have a hikey device, but yes, I think your reasoning is correct.",
      "parentUuid": "2bb486b1_2d4e1a31",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6f342f77_90be5dc5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-01-30T19:11:09Z",
      "side": 1,
      "message": "Quick question since I don\u0027t see it explicitly stated: when sync\u0027ing a new bionic, is that new bionic is used for both the boot strap bionic and the default bionic or only one of the two?  I assume both?\n\nI guess even more basic question: what happens when there\u0027s an apex module and I adb sync something in general?  I assume apex knows to no longer override that module, since it would make sense that the develop pushing a new module is specifically intending on that module to be used?",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f8309c2_0be9574c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-31T02:20:48Z",
      "side": 1,
      "message": "What we update via adb sync is on the system partition. So, it\u0027s bootstrap bionic which is updated and thus affects only the pre-apexd processes.\n\nI am not sure I understood your second question correctly. If you push an *.apex file, it will be used only after apexd re-activates the apex file (usually via rebooting). Until then, the old inode is associated with the loopback device that is mounted at /apex/\u003cname\u003e.",
      "parentUuid": "6f342f77_90be5dc5",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4718be4_8df9289b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-01-31T04:12:37Z",
      "side": 1,
      "message": "Might be worth calling that out explicitly; that only the bootstrap bionic gets updated.\n\nIn general, I\u0027m wondering why that\u0027s the intended behavior, and my second question was asking if that is the intended behavior for apex files.  Essentially, I find it strange that if I `adb push` or `adb sync` after making changes to the tree, that apex would override my \u0027new\u0027 files.  If I\u0027m explicitly pushing or syncing them, I figure I\u0027d be intending for them to be used.\n\nBut I guess for 99% of developers, we\u0027ll be running on a device that doesn\u0027t have any apex modules, so I\u0027m not actually concerned either way; just wanted to know.",
      "parentUuid": "6f8309c2_0be9574c",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4c7761fb_eb296fec",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-31T04:42:22Z",
      "side": 1,
      "message": "Even before this change, adb push/sync can\u0027t override files that are in-use. The updated file is only for new open() or new processes. Sams as APEX.\n\n\u003e But I guess for 99% of developers, we\u0027ll be running on a device that doesn\u0027t have any apex modules,\n\nNo, all Q devices have APEXes in the system partition though some of them won\u0027t support \"updating\" of APEXes due to lack of required patches in kernel.",
      "parentUuid": "b4718be4_8df9289b",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5e439c42_e763953d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-01-31T16:27:24Z",
      "side": 1,
      "message": "Right; I think I\u0027m not phrasing my question well.  \n\nI\u0027m talking about the case that a device has been used in the field and downloads a new APEX, so that there is an updated APEX running from /data.  And my question is when a developer `adb sync`s and that overwrites the apex in the system partition, is there a way to tell APEX, \"I know you have this update in /data, but I also updated the one in /system and that\u0027s the one that you should use\"?\n\nThat\u0027s what I mean by 99% of developers won\u0027t have this situation; since we\u0027ll likely not have updated APEX modules in /data.\n\nBut more specifically, I\u0027m also wondering what happens with the bootstrap vs default bionic.  I figure if I do the following:\n\n1) Flash a device\n2) Rebuild, including changes to bionic\n3) `adb sync`\n4) Both bionics on the device have the new changes that I made\n\nIs that the case?  If not, how do I make sure to update both bionics?",
      "parentUuid": "4c7761fb_eb296fec",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebd10110_3867e70e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-02-01T10:54:11Z",
      "side": 1,
      "message": "+dariofreni as he is directly working on that part.\n\nAFAIK, it depends on which version of APEX the developer has adb sync\u0027ed. If it is newer than the one in /data/apex, then the that one will be used from the next reboot. If the version is lower, it will be the opposite. If the version is the same, I don\u0027t know. Dario might be able to answer.\n\n------------\nAt the step 4) where reboot hasn\u0027t been done yet, only the bootstrap Bionic is be updated (\u003dvisible to new processes). In order to apply the default Bionic in the runtime APEX, the device has to be rebooted. \n\nBTW, we could make this better; for example, apexd might restart upon adb stop/start. Then the reboot won\u0027t be needed.",
      "parentUuid": "5e439c42_e763953d",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df13a998_fbd277ea",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1305591
      },
      "writtenOn": "2019-02-01T11:05:57Z",
      "side": 1,
      "message": "At the moment apexd will favour the version in /data/apex if the version is the same. We could favour the version in /system/apex but I guess it\u0027s a kind of arbitrary choice either way.\n\nb/123277052 will make sure that the version in /system will \"win\" if it\u0027s higher than the version in /data (we need this for prod devices too)",
      "parentUuid": "ebd10110_3867e70e",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbf6dd80_e6617ab9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-01T16:50:00Z",
      "side": 1,
      "message": "That makes sense to me; as long as there\u0027s a way to ensure that the /system version of the APEX is the one that is used, and since most often developers will be working on a very recent version of Android, that sounds like it\u0027ll likely be the case.\n\nAs for 4), that only applies to the bionic APEX due to the mount namespaces, etc, right?  Let\u0027s follow up on the bug that you filed; it\u0027d be good to get others\u0027 input too on this.",
      "parentUuid": "df13a998_fbd277ea",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdaab73b_f0611f16",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-02-02T05:38:30Z",
      "side": 1,
      "message": "For 4), it\u0027s not because we have mount namespaces, but because we access bionic via mounts at /bionic. Even if apexd mounts /apex/\u003cname\u003e with the updated *.apex files, /bionic/* still points to the existing loopback device backed by the inode of the old *.apex file.\n\nWe could resolve the problem,  by remounting /bionic mountpoints again when apexd finishes remounting APEXes. Filed b/123738645",
      "parentUuid": "bbf6dd80_e6617ab9",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e17d0dea_078008f0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-04T16:19:24Z",
      "side": 1,
      "message": "Not sure if I would call this a regression in behavior worth resolving. expectations are adb sync, when common shared resources like libraries are affected, has never guaranteed all are immediately affected, and the general rule of thumb is to reboot after sync to get them all in-line. I certainly do so when I update libc as there are so many users, I\u0027d expect a similar effect for runtime libc (restarting services notwithstanding). In fact, all my scripts that perform an adb sync are followed by a reboot \"just because\" regardless of what got updated (b/c, for example, what if I changed init, which is an executable that can never be killed or stopped).\n\nYes, it _would_ be nice is everything was using the new libraries immediately after, but bending over backwards to make it so without a 100% guarantee is not worth the trouble.",
      "parentUuid": "fdaab73b_f0611f16",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e81cf5e1_0a23d665",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-04T16:36:23Z",
      "side": 1,
      "message": "Agreed for existing processes I wouldn\u0027t expect anything old to pick up the new bionic, but newly exec\u0027ed processes should get the new libraries immediately though now, right?  If I adb sync a new version of libc and run the bionic unit tests; I\u0027d expect that I get the new libc for those unit tests.\n\nBut really the big thing that I care about is that both bionics are updated; the one in the apex on system (and that one becomes active) and the bootstrap one.  In other words, if I `adb sync` and run the bionic unit tests (preferably without a reboot, but definitely with one), that when I run the bionic unit tests, I\u0027m testing the bionic that I just sync\u0027ed.",
      "parentUuid": "e17d0dea_078008f0",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f97cb9a8_9dcac0b9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 18
      },
      "lineNbr": 44,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-04T17:09:08Z",
      "side": 1,
      "message": "I understand, I rescind my comment because you _are_ (b4 APEX) guaranteed new executables will use the libs and in this case it is a regression!",
      "parentUuid": "e81cf5e1_0a23d665",
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d3eea3c_09deb604",
        "filename": "adb/daemon/remount_service.cpp",
        "patchSetId": 18
      },
      "lineNbr": 343,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-01-30T15:47:52Z",
      "side": 1,
      "message": "NB: This also needs to be added to the (new) remount _command_ in https://android-review.googlesource.com/c/platform/system/core/+/885532\n\nMaybe _this_ functionality could be _moved_ to libfs_mgr for both to access; AFAIAC it is simple enough to just do it ...",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 343,
        "endChar": 33
      },
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b1d4f2f_576fb2a4",
        "filename": "adb/daemon/remount_service.cpp",
        "patchSetId": 18
      },
      "lineNbr": 343,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-01-30T15:52:22Z",
      "side": 1,
      "message": "sure. will do after this lands.",
      "parentUuid": "4d3eea3c_09deb604",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 343,
        "endChar": 33
      },
      "revId": "7c7189c46948761cc668c9362d0b5aefb4004c70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}