{
  "comments": [
    {
      "key": {
        "uuid": "ed9ab306_fdc9a5ae",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 121,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-07T19:11:27Z",
      "side": 1,
      "message": "I still think this would be cleaner if we broke this up into separate functions.  This for loop + auto overlayfs_candidates \u003d fs_mgr_overlayfs_candidate_list(\u0026fstab); can be factored out into a separate FindRemountablePartitions() function.",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b2b8e12_be676acd",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 121,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-07T21:41:50Z",
      "side": 1,
      "message": "This interacts with later CL modifications in the stack, arguments that would need to be supplied:\n\nfstab\noverlayfs_candidates\nverity\ncan_reboot\noverlayfs_valid\n\narguments returned:\n\nall\nall_overlayfs\n\nI will have to think about how I can split out all the mining into \"though chunks\" so that this request makes sense.",
      "parentUuid": "ed9ab306_fdc9a5ae",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f59a3159_1dda9d67",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-07T19:11:27Z",
      "side": 1,
      "message": "This too looks like it can be factored out along with auto verity \u003d fs_mgr_overlayfs_verity_enabled_list(); into a separate function.",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "594196c9_3bcb8db4",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-07T21:41:50Z",
      "side": 1,
      "message": "Above and here may be simplified if I had the ability to set some user-defined flags in FstabEntry like \u0027is_verity_protected\u0027 and \u0027is_wrapped_by_overlayfs\u0027.\n\nResisting making my own fstab class ...",
      "parentUuid": "f59a3159_1dda9d67",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ceb3a436_9d8bfc27",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-07T23:14:55Z",
      "side": 1,
      "message": "Honestly, maybe not the worst idea.  Or better yet, adding the parts you\u0027re missing to the current fstab.\n\nFor is_verity_protected, you\u0027re relying on fs_mgr_update_verity_state() which I already want to refactor.  Would it help if I did take https://android-review.googlesource.com/c/platform/system/core/+/863409 to completion?  In this case you wouldn\u0027t need the verity vector at all; you could just call this function on each of the items in the fstab.\n\nSame thing for is_wrapped_by_overlayfs; you mean using that to replace fs_mgr_overlayfs_candidate_list(), right?  Instead of a separate flag, could we make a IsOverlayFsWrapped() function that takes a single FstabEntry as a parameter?\n\nI think if both of those functions took just an FstabEntry as their parameter, then this code would simplify greatly.",
      "parentUuid": "594196c9_3bcb8db4",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "464debe0_4a67a6c2",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-07T23:33:34Z",
      "side": 1,
      "message": "I\u0027d say \u0027do it\u0027 for the refactor of verity state checking, this CL can wait as it is a \u0027second choice\u0027 fix to a P1 issue, and a \u0027first choice\u0027 fix for a P3 developer wish list (a remount command, and a refactor of the \u0027adb remount\u0027 operations).\n\nI was going to do something like this FYI:\n\n     // Generate the list of supported overlayfs mount points.\n     auto overlayfs_candidates \u003d fs_mgr_overlayfs_candidate_list(\u0026fstab);\n+    auto is_wrapped_by_overlayfs \u003d [\u0026overlayfs_candidates](const android::fs_mgr::FstabEntry\u0026 entry) {\n+        auto mount_point \u003d entry.mount_point;\n+        if (mount_point \u003d\u003d \"/\") mount_point \u003d \"/system\";\n+        return std::find(overlayfs_candidates.begin(), overlayfs_candidates.end(), mount_point) !\u003d overlayfs_candidates.end();\n+    };",
      "parentUuid": "ceb3a436_9d8bfc27",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5b010d8e_67a8f185",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-08T00:08:46Z",
      "side": 1,
      "message": "Probably better to just make the functions that query an individual FstabEntry than that.\n\nI revived the CL for fs_mgr_update_verity_state().  I\u0027m hoping breaking apart fs_mgr_overlayfs_candidate_list wouldn\u0027t be too hard.",
      "parentUuid": "464debe0_4a67a6c2",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e21c8578_f7dfc523",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-11T22:35:38Z",
      "side": 1,
      "message": "Because of the nesting checking (eg: /vendor/firmware_mnt not needing an entry b/c /vendor covers it) breaking apart fs_mgr_overlayfs_candidate_list needed the full fstab, and looked _uglier_; despite looking only marginally cleaner here (really on drops the lambda). Will continue to play with it to find something I find comfortable from the maintenance perspective; but will wait for your CLs to merge before I work on this in earnest.",
      "parentUuid": "5b010d8e_67a8f185",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0549e415_ebfc69e4",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-02-11T22:56:03Z",
      "side": 1,
      "message": "I don\u0027t fully understand.  /vendor covers /vendor/firmware_mnt since if we use overlayfs on /vendor, then we won\u0027t on /vendor/firmware_mnt, right?  But that doesn\u0027t interact with the \u0027verity\u0027 vector here, right?  We\u0027re searching for Basename of the mount_point, so we\u0027re not going to find firmware_mnt anywhere in \u0027verity\u0027.\n\nWhat happens when you run this program with verity enabled?  If I\u0027m reading this logic, we actually do remount /vendor/firmware_mnt as rw, since it never has verity enabled and it won\u0027t be a submount of any overlayfs mount (since we don\u0027t have any due to verity being enabled).  Then with verity disabled, we overlay /vendor entirely and do not remount /vendor/firmware_mnt as rw.  That seems like a bit strange behavior with the current code in any case.\n\nIt still seems like a good idea to land my changes then do the duplicate/more specific logic change explicitly?",
      "parentUuid": "e21c8578_f7dfc523",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "146e65b5_2812478f",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-11T23:41:17Z",
      "side": 1,
      "message": "We allow overlayfs on _anything_ read-only that is not protected by verity. We do not check or care if it has a verity sector, except if it is active, then we stay away from it!\n\nWe do not remount /vendor/firmware_mnt since /vendor exists and _covers_ it (candidate, but not enabled if verity is enabled). If the fstab was _missing_ /vendor, then we have a problem ...",
      "parentUuid": "0549e415_ebfc69e4",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09108325_a414b3bf",
        "filename": "fs_mgr/fs_mgr_remount.cpp",
        "patchSetId": 11
      },
      "lineNbr": 146,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2019-02-11T23:51:03Z",
      "side": 1,
      "message": "BTW, we are digressing! rabit hole. Just saying \"not as easy\" ...\n\nand yes, the current code is borken in some respects (mount point argument does not work like expected and /vendor/firmware_mnt works today because it is never 100% full), and is a hypothetical example.\n\nThe point is, I want to unroll the candidate list function; but it will start with a duplicate/more specific filter of a passed in fstab, then caller can remove any entries where verity is active, then a GetEntryForMountPoint probably in the code paths in the callers too. The exportable candidate list function should return an fstab that is a filtered version of the incoming fstab and nothing more I think.",
      "parentUuid": "146e65b5_2812478f",
      "revId": "8a6075c7a6c5bd15c4f097964d65b4f969427f33",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}