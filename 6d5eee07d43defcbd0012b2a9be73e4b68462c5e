{
  "comments": [
    {
      "key": {
        "uuid": "22d0113b_1e9591f5",
        "filename": "liblog/log_event_list.c",
        "patchSetId": 1
      },
      "lineNbr": 308,
      "author": {
        "id": 1020966
      },
      "writtenOn": "2016-02-22T18:49:56Z",
      "side": 1,
      "message": "What if the consumer of the log is expecting the log to be in the list format regardless of whether it has 1 or more elements?",
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62be89e4_b1401081",
        "filename": "liblog/log_event_list.c",
        "patchSetId": 1
      },
      "lineNbr": 308,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2016-02-22T20:52:16Z",
      "side": 1,
      "message": "A case of this code being too smart for it\u0027s own good?\n\nThe list handler is pre-loaded with a virtual list that catches and corrects the case of a list of elements without a list begin or end as a service to deal with intent and protocol accuracy. In essence, we _add_ a list to make it correct, not subtract a list because they submitted a single element. If the caller wants a list of 1 element, then they must specifically issue a list begin and end. Specifically specifying a list should always work consistently.\n\nI do need to document this in a way that makes sense to everyone (including me :-) ).\n\nI should have a test case for explicitly specifying a list begin and end for a single-element list (if I continue to like this idea).",
      "parentUuid": "22d0113b_1e9591f5",
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62be89e4_6bc60914",
        "filename": "liblog/log_event_list.c",
        "patchSetId": 1
      },
      "lineNbr": 367,
      "author": {
        "id": 1020966
      },
      "writtenOn": "2016-02-22T18:49:56Z",
      "side": 1,
      "message": "Nit: switch to true (as it is below) for consistency",
      "range": {
        "startLine": 367,
        "startChar": 24,
        "endLine": 367,
        "endChar": 25
      },
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "22d0113b_aaec13af",
        "filename": "liblog/log_event_list.c",
        "patchSetId": 1
      },
      "lineNbr": 367,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2016-02-22T20:52:16Z",
      "side": 1,
      "message": "Yes ... ((int)true) \u003d\u003d 1 according to the standard, but we are using stdbool.h? I expect landing this into a uint16_t should not be an issue. FYI: I expect at some future date, if we need more bits, this could be a bitfield, why I split your initial definition into a pair of uint16_t\u0027s",
      "parentUuid": "62be89e4_6bc60914",
      "range": {
        "startLine": 367,
        "startChar": 24,
        "endLine": 367,
        "endChar": 25
      },
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c2c1f56d_a1fafd22",
        "filename": "liblog/log_event_list.c",
        "patchSetId": 1
      },
      "lineNbr": 398,
      "author": {
        "id": 1020966
      },
      "writtenOn": "2016-02-22T18:49:56Z",
      "side": 1,
      "message": "Nit: switch to true (as it is below) for consistency",
      "range": {
        "startLine": 398,
        "startChar": 25,
        "endLine": 398,
        "endChar": 26
      },
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a29b218c_d65ca227",
        "filename": "liblog/log_event_list.c",
        "patchSetId": 1
      },
      "lineNbr": 418,
      "author": {
        "id": 1020966
      },
      "writtenOn": "2016-02-22T18:49:56Z",
      "side": 1,
      "message": "FYI: If you decide to support the empty list, then the count \u003d\u003d 0, and this pre-decrement will make the condition false.",
      "range": {
        "startLine": 418,
        "startChar": 33,
        "endLine": 418,
        "endChar": 38
      },
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62a5a9c6_f9e2f7bd",
        "filename": "liblog/log_event_list.c",
        "patchSetId": 1
      },
      "lineNbr": 418,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2016-02-22T20:52:16Z",
      "side": 1,
      "message": "Good catch ... this gets caught in the subsequent pass at line 356 to produce the expected result(s) but we get two objects back, rather than an early-stop indication as WAS the intent here.\n\nI failed to follow through with this design choice and create a test case.",
      "parentUuid": "a29b218c_d65ca227",
      "range": {
        "startLine": 418,
        "startChar": 33,
        "endLine": 418,
        "endChar": 38
      },
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62a5a9c6_ae19c7be",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2037,
      "author": {
        "id": 1020966
      },
      "writtenOn": "2016-02-22T18:49:56Z",
      "side": 1,
      "message": "How about a test that just has an empty list, \"[]\", or one that includes an empty list?",
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82bb7df1_150fa313",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2037,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2016-02-22T20:52:16Z",
      "side": 1,
      "message": "yes, agreed!",
      "parentUuid": "62a5a9c6_ae19c7be",
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62be89e4_912f4cd2",
        "filename": "liblog/tests/liblog_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2155,
      "author": {
        "id": 1032276
      },
      "writtenOn": "2016-02-22T20:52:16Z",
      "side": 1,
      "message": "We should expose in the API the maximum list nesting depth, rather than letting it remain internal.\n\nThis should turn into a loop based on that value.",
      "range": {
        "startLine": 2149,
        "startChar": 0,
        "endLine": 2155,
        "endChar": 56
      },
      "revId": "6d5eee07d43defcbd0012b2a9be73e4b68462c5e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}