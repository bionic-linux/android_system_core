{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9ac2cba1_2b88170b",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-03-31T19:34:13Z",
      "side": 1,
      "message": "We\u0027d like to limit new clients depending on libstatslog. Can we add module annotation support for Rust code generation? libstatslog includes generated code for all atoms and we want new clients to only use generated code for the atoms they care about.",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1856e2c_d572fef3",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-03-31T19:36:59Z",
      "side": 1,
      "message": "The support is already there, but how would that work with this?  Would each user have to define their own libstatspull_foo_rust that depends on their own libstatslog_foo_rust?",
      "parentUuid": "9ac2cba1_2b88170b",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1615c59_b168ac5a",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-03-31T19:52:13Z",
      "side": 1,
      "message": "Actually, I can probably do something like the C++ generator and split the autogenerated Rust code into a \"header\" that just declares the atoms and some other things and then the other one that has all the code.  The first would have to contain all the atoms as Rust enums are closed, but then this library would only have to depend on that and not all the implementations.  I\u0027ll try that after lunch...",
      "parentUuid": "e1856e2c_d572fef3",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "92bc9fb3_cbf7325b",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-03-31T21:43:58Z",
      "side": 1,
      "message": "Okay, how does this look?  I did what I described above, breaking the auto-generated Rust code into a header and the implementation.  This now depends only on the header part.",
      "parentUuid": "f1615c59_b168ac5a",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c6c9ab2_6a917d77",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-04-02T18:32:04Z",
      "side": 1,
      "message": "I think this is much better, thanks! Sometime in the future, we want to migrate all C++ clients away from libstatslog and have them use libstatslog_\u003cmodule_name\u003e which contains generated code for the atoms they care about only. When that is done, would we be able to get rid of libstatslog? Or are Rust clients still depending on it?",
      "parentUuid": "92bc9fb3_cbf7325b",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "90917be5_d38b16c1",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-04-02T18:38:02Z",
      "side": 1,
      "message": "I was actually going to ask you about that.  Right now the only Rust user is still using it, yes.  But we discussed it recently and it seemed easy to migrate (basically just add a new module to her atoms and then add some new rules), so I think she (or I) will do it soon.  Once we do that, then I was going to ask you if we should remove the \"full\" Rust library.",
      "parentUuid": "2c6c9ab2_6a917d77",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "926f9db8_14f6abb6",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1431413
      },
      "writtenOn": "2021-04-02T18:46:59Z",
      "side": 1,
      "message": "Yes, that would be great! If we can move the one client to use module and then if we don\u0027t need the full Rust library, we don\u0027t need to keep it.",
      "parentUuid": "90917be5_d38b16c1",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b531a92_ce1c15d6",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1208973
      },
      "writtenOn": "2021-04-02T18:48:29Z",
      "side": 1,
      "message": "Sounds good.  I\u0027ll follow up with her next week to update the existing use and then try to remove it.  Feel free to ping me sometime in case I forget. ;)",
      "parentUuid": "926f9db8_14f6abb6",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37214e6a_235bc5e2",
        "filename": "libstats/pull_rust/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 52,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2021-04-05T17:09:04Z",
      "side": 1,
      "message": "I am suspicious about the idea of breaking up the library into many submodules, even in the C++ case.\n\nUnless a small percentage of atoms are actually used *anywhere* on the device, I expect the extra overhead from having many distinct libraries and being unable to pack atom code into the same page (since they\u0027re in different modules now) will end up increasing rather than decreasing memory usage.\n\nThe library is currently ~300k. There are ~10092 atoms today. If we assume the per-atom code is similar in size, that\u0027s about 30 bytes per atom. Even if we assume that only 10% of those atoms are actually in use, modules would need to be on average at least 14 atoms before you\u0027d break even.\n\nI expect that in reality, more than 10% of atoms are in use, which means that the average module size would need to be *even higher* before you\u0027d even hit break-even. If we assume 50% of atoms are in use, you will waste space until modules are at least 69 atoms on average.\n\nIn the Rust case, all these calculations get worse. Since we don\u0027t have actual headers, the course taken here was to convert the \"header\" into an additional crate. That crate will take up a minimum of one additional page per process simply because it\u0027s another library loaded. That brings the minimum break-even module size to 28 for 10% of atoms in use, and 209 (!) for 50% of atoms in use.\n\ntl;dr splitting into modules seems like it will waste a nontrivial amount of space in practical usage, adds complexity, and the maximum gain for all the effort you\u0027re describing is the percentage of atoms not in use * 300k, which seems very slim...",
      "parentUuid": "7b531a92_ce1c15d6",
      "range": {
        "startLine": 52,
        "startChar": 9,
        "endLine": 52,
        "endChar": 25
      },
      "revId": "a6c0d77213d806f3aae1242c0c8957071a813c54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}