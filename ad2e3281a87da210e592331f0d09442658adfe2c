{
  "comments": [
    {
      "key": {
        "uuid": "5b1c6c7f_0e34590c",
        "filename": "libunwindstack/DwarfCfa.cpp",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-03-20T21:25:17Z",
      "side": 1,
      "message": "You can move this above the first if and remove the setting it before the loop starts. Or maybe, you could set it unconditionally only in the two return true cases since there are no other ways out of the loop.",
      "range": {
        "startLine": 63,
        "startChar": 4,
        "endLine": 63,
        "endChar": 33
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f702872c_9eefa11a",
        "filename": "libunwindstack/DwarfCfa.cpp",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-22T23:14:28Z",
      "side": 1,
      "message": "That would result in pc_start \u003d\u003d pc_end (i.e. empty valid PC range).\n\npc_start is the pc of the \"row\" (cur_pc_ when we create the row)\npc_end is address of the next row (i.e. cur_pc_ when we noticed we went too far or end of function if applicable)\n\n[pc_start, pc_end) define the range of PCs where the rules are valid (obviously).\n\nThe motivation is to cache the whole surrounding valid PC range, rather than the single PC.",
      "parentUuid": "5b1c6c7f_0e34590c",
      "range": {
        "startLine": 63,
        "startChar": 4,
        "endLine": 63,
        "endChar": 33
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dae067a5_a97f7503",
        "filename": "libunwindstack/DwarfCfa.cpp",
        "patchSetId": 1
      },
      "lineNbr": 63,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-03-23T02:57:55Z",
      "side": 1,
      "message": "Oops, yeah forget I said anything.",
      "parentUuid": "f702872c_9eefa11a",
      "range": {
        "startLine": 63,
        "startChar": 4,
        "endLine": 63,
        "endChar": 33
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "66765515_a0cefbfa",
        "filename": "libunwindstack/include/unwindstack/DwarfLocation.h",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2018-03-16T18:59:37Z",
      "side": 1,
      "message": "Is there any reason to init pc range to include everything?",
      "range": {
        "startLine": 46,
        "startChar": 23,
        "endLine": 46,
        "endChar": 24
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6394a5d8_d4eba8a5",
        "filename": "libunwindstack/include/unwindstack/DwarfLocation.h",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-16T19:08:23Z",
      "side": 1,
      "message": "I just like to initialize memory.\nThe decoder should set the range.",
      "parentUuid": "66765515_a0cefbfa",
      "range": {
        "startLine": 46,
        "startChar": 23,
        "endLine": 46,
        "endChar": 24
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d16331b_5f54bcc0",
        "filename": "libunwindstack/include/unwindstack/DwarfLocation.h",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2018-03-16T19:44:23Z",
      "side": 1,
      "message": "Then why not set pc_end to 0? Setting pc_start to 0 and pc_end to ~0 looks like some code is relying on that.",
      "parentUuid": "6394a5d8_d4eba8a5",
      "range": {
        "startLine": 46,
        "startChar": 23,
        "endLine": 46,
        "endChar": 24
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0c3e21b_4680851f",
        "filename": "libunwindstack/include/unwindstack/DwarfLocation.h",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-03-20T21:25:17Z",
      "side": 1,
      "message": "Yeah, I would probably init to zero too. Mostly, I assume that it might be possible to optimize the creation of the structure if everything is init\u0027d to zero, but I might be overthinking this.\n\nAlthough, looking at the code, there is no way to get out without setting both of these values, but this would help catch a logic bug.",
      "parentUuid": "8d16331b_5f54bcc0",
      "range": {
        "startLine": 46,
        "startChar": 23,
        "endLine": 46,
        "endChar": 24
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ca67672_b92337c7",
        "filename": "libunwindstack/include/unwindstack/DwarfLocation.h",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-22T23:14:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c0c3e21b_4680851f",
      "range": {
        "startLine": 46,
        "startChar": 23,
        "endLine": 46,
        "endChar": 24
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03231a14_56d8afac",
        "filename": "libunwindstack/include/unwindstack/DwarfSection.h",
        "patchSetId": 1
      },
      "lineNbr": 114,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-03-20T21:25:17Z",
      "side": 1,
      "message": "Is there a reason this is a pointer and not just the DwarfCie struct itself? I looked and it doesn\u0027t appear it avoids any copies because you still need to do the new which should be equivalent.\n\nMy understanding of the way I am using the unordered_map does the equivalent of a new, and the DwarfCie object itself should not be copied around.\n\nHowever, my knowledge of the internals of the STL is not very large, so I could be wrong.",
      "range": {
        "startLine": 114,
        "startChar": 31,
        "endLine": 114,
        "endChar": 56
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5036ca3e_fd5a573d",
        "filename": "libunwindstack/include/unwindstack/DwarfSection.h",
        "patchSetId": 1
      },
      "lineNbr": 114,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-22T23:14:28Z",
      "side": 1,
      "message": "I am not STL expert either.  I would assume that the hashmap could move the data when entries are added/removed.  I certainly wouldn\u0027t expect the hashmap do heap allocation for each entry.\n\nBut there is no strong reason - I needed CIE pointer at some point, and felt really uncomfortable having pointer to inside the internals of the hashmap.\n\nBetter safe than sorry?  CIEs are so rare the cost does not matter.",
      "parentUuid": "03231a14_56d8afac",
      "range": {
        "startLine": 114,
        "startChar": 31,
        "endLine": 114,
        "endChar": 56
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1517ea48_aa8a609c",
        "filename": "libunwindstack/include/unwindstack/DwarfSection.h",
        "patchSetId": 1
      },
      "lineNbr": 114,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-03-23T02:57:55Z",
      "side": 1,
      "message": "I forgot that I had looked this up before because I rely on this behavior. Here\u0027s the info from the stl on this:\n\nReferences and pointers to either key or data stored in the container are only invalidated by erasing that element, even when the corresponding iterator is invalidated.\n\nhttp://en.cppreference.com/w/cpp/container/unordered_map\n\nSo you don\u0027t need to do the unique_ptr stuff, you can keep a pointer to it without causing any issues (assuming our version of the STL conforms to the above).",
      "parentUuid": "5036ca3e_fd5a573d",
      "range": {
        "startLine": 114,
        "startChar": 31,
        "endLine": 114,
        "endChar": 56
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a5514d9_f71c091b",
        "filename": "libunwindstack/include/unwindstack/DwarfSection.h",
        "patchSetId": 1
      },
      "lineNbr": 114,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-24T01:01:22Z",
      "side": 1,
      "message": "I am surprised by this, but I believe you are right.",
      "parentUuid": "1517ea48_aa8a609c",
      "range": {
        "startLine": 114,
        "startChar": 31,
        "endLine": 114,
        "endChar": 56
      },
      "revId": "ad2e3281a87da210e592331f0d09442658adfe2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}